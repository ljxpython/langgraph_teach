"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge";
exports.ids = ["vendor-chunks/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChannel: () => (/* binding */ BaseChannel),\n/* harmony export */   createCheckpoint: () => (/* binding */ createCheckpoint),\n/* harmony export */   emptyChannels: () => (/* binding */ emptyChannels),\n/* harmony export */   isBaseChannel: () => (/* binding */ isBaseChannel)\n/* harmony export */ });\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph-checkpoint@0.0.17_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4__/node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n\n\nfunction isBaseChannel(obj) {\n    return obj != null && obj.lg_is_channel === true;\n}\nclass BaseChannel {\n    constructor() {\n        Object.defineProperty(this, \"ValueType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"UpdateType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"lg_is_channel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Mark the current value of the channel as consumed. By default, no-op.\n     * This is called by Pregel before the start of the next step, for all\n     * channels that triggered a node. If the channel was updated, return true.\n     */\n    consume() {\n        return false;\n    }\n}\nfunction emptyChannels(channels, checkpoint) {\n    const filteredChannels = Object.fromEntries(Object.entries(channels).filter(([, value]) => isBaseChannel(value)));\n    const newChannels = {};\n    for (const k in filteredChannels) {\n        if (Object.prototype.hasOwnProperty.call(filteredChannels, k)) {\n            const channelValue = checkpoint.channel_values[k];\n            newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);\n        }\n    }\n    return newChannels;\n}\nfunction createCheckpoint(checkpoint, channels, step) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let values;\n    if (channels === undefined) {\n        values = checkpoint.channel_values;\n    }\n    else {\n        values = {};\n        for (const k of Object.keys(channels)) {\n            try {\n                values[k] = channels[k].checkpoint();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (error) {\n                if (error.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                    // no-op\n                }\n                else {\n                    throw error; // Rethrow unexpected errors\n                }\n            }\n        }\n    }\n    return {\n        v: 1,\n        id: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.uuid6)(step),\n        ts: new Date().toISOString(),\n        channel_values: values,\n        channel_versions: { ...checkpoint.channel_versions },\n        versions_seen: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(checkpoint.versions_seen),\n        pending_sends: checkpoint.pending_sends ?? [],\n    };\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1FO0FBQ2xCO0FBQzFDO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUFLO0FBQ2pCO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELHVCQUF1Qix5RUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2Jhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVlcENvcHksIHV1aWQ2LCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG5pbXBvcnQgeyBFbXB0eUNoYW5uZWxFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VDaGFubmVsKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmoubGdfaXNfY2hhbm5lbCA9PT0gdHJ1ZTtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlZhbHVlVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJVcGRhdGVUeXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxnX2lzX2NoYW5uZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGNoYW5uZWwgYXMgY29uc3VtZWQuIEJ5IGRlZmF1bHQsIG5vLW9wLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJ5IFByZWdlbCBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHN0ZXAsIGZvciBhbGxcbiAgICAgKiBjaGFubmVscyB0aGF0IHRyaWdnZXJlZCBhIG5vZGUuIElmIHRoZSBjaGFubmVsIHdhcyB1cGRhdGVkLCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBjb25zdW1lKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5Q2hhbm5lbHMoY2hhbm5lbHMsIGNoZWNrcG9pbnQpIHtcbiAgICBjb25zdCBmaWx0ZXJlZENoYW5uZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNoYW5uZWxzKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gaXNCYXNlQ2hhbm5lbCh2YWx1ZSkpKTtcbiAgICBjb25zdCBuZXdDaGFubmVscyA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBmaWx0ZXJlZENoYW5uZWxzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZmlsdGVyZWRDaGFubmVscywgaykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxWYWx1ZSA9IGNoZWNrcG9pbnQuY2hhbm5lbF92YWx1ZXNba107XG4gICAgICAgICAgICBuZXdDaGFubmVsc1trXSA9IGZpbHRlcmVkQ2hhbm5lbHNba10uZnJvbUNoZWNrcG9pbnQoY2hhbm5lbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Q2hhbm5lbHM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hlY2twb2ludChjaGVja3BvaW50LCBjaGFubmVscywgc3RlcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IHZhbHVlcztcbiAgICBpZiAoY2hhbm5lbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXMgPSBjaGVja3BvaW50LmNoYW5uZWxfdmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhjaGFubmVscykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gY2hhbm5lbHNba10uY2hlY2twb2ludCgpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBSZXRocm93IHVuZXhwZWN0ZWQgZXJyb3JzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHY6IDEsXG4gICAgICAgIGlkOiB1dWlkNihzdGVwKSxcbiAgICAgICAgdHM6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgY2hhbm5lbF92YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgY2hhbm5lbF92ZXJzaW9uczogeyAuLi5jaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMgfSxcbiAgICAgICAgdmVyc2lvbnNfc2VlbjogZGVlcENvcHkoY2hlY2twb2ludC52ZXJzaW9uc19zZWVuKSxcbiAgICAgICAgcGVuZGluZ19zZW5kczogY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzID8/IFtdLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryOperatorAggregate: () => (/* binding */ BinaryOperatorAggregate)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\n/**\n * Stores the result of applying a binary operator to the current value and each new value.\n */\nclass BinaryOperatorAggregate extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(operator, initialValueFactory) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"BinaryOperatorAggregate\"\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"operator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"initialValueFactory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.operator = operator;\n        this.initialValueFactory = initialValueFactory;\n        this.value = initialValueFactory?.();\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new BinaryOperatorAggregate(this.operator, this.initialValueFactory);\n        if (checkpoint) {\n            empty.value = checkpoint;\n        }\n        return empty;\n    }\n    update(values) {\n        let newValues = values;\n        if (!newValues.length)\n            return false;\n        if (this.value === undefined) {\n            [this.value] = newValues;\n            newValues = newValues.slice(1);\n        }\n        for (const value of newValues) {\n            if (this.value !== undefined) {\n                this.value = this.operator(this.value, value);\n            }\n        }\n        return true;\n    }\n    get() {\n        if (this.value === undefined) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value;\n    }\n    checkpoint() {\n        if (this.value === undefined) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value;\n    }\n}\n//# sourceMappingURL=binop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2Jpbm9wLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNUO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQyxpREFBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2Jpbm9wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVtcHR5Q2hhbm5lbEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFN0b3JlcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgYmluYXJ5IG9wZXJhdG9yIHRvIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBlYWNoIG5ldyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlIGV4dGVuZHMgQmFzZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG9wZXJhdG9yLCBpbml0aWFsVmFsdWVGYWN0b3J5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiQmluYXJ5T3BlcmF0b3JBZ2dyZWdhdGVcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdGlhbFZhbHVlRmFjdG9yeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlRmFjdG9yeSA9IGluaXRpYWxWYWx1ZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBpbml0aWFsVmFsdWVGYWN0b3J5Py4oKTtcbiAgICB9XG4gICAgZnJvbUNoZWNrcG9pbnQoY2hlY2twb2ludCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IG5ldyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZSh0aGlzLm9wZXJhdG9yLCB0aGlzLmluaXRpYWxWYWx1ZUZhY3RvcnkpO1xuICAgICAgICBpZiAoY2hlY2twb2ludCkge1xuICAgICAgICAgICAgZW1wdHkudmFsdWUgPSBjaGVja3BvaW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgbmV3VmFsdWVzID0gdmFsdWVzO1xuICAgICAgICBpZiAoIW5ld1ZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFt0aGlzLnZhbHVlXSA9IG5ld1ZhbHVlcztcbiAgICAgICAgICAgIG5ld1ZhbHVlcyA9IG5ld1ZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG5ld1ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yKHRoaXMudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgY2hlY2twb2ludCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVtcHR5Q2hhbm5lbEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymlub3AuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EphemeralValue: () => (/* binding */ EphemeralValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/index.js\");\n\n\n/**\n * Stores the value received in the step immediately preceding, clears after.\n * @internal\n */\nclass EphemeralValue extends _index_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(guard = true) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"EphemeralValue\"\n        });\n        Object.defineProperty(this, \"guard\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // value is an array so we don't misinterpret an update to undefined as no write\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.guard = guard;\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new EphemeralValue(this.guard);\n        if (checkpoint) {\n            empty.value = [checkpoint];\n        }\n        return empty;\n    }\n    update(values) {\n        if (values.length === 0) {\n            const updated = this.value.length > 0;\n            // If there are no updates for this specific channel at the end of the step, wipe it.\n            this.value = [];\n            return updated;\n        }\n        if (values.length !== 1 && this.guard) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(\"EphemeralValue can only receive one value per step.\");\n        }\n        // eslint-disable-next-line prefer-destructuring\n        this.value = [values[values.length - 1]];\n        return true;\n    }\n    get() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n    checkpoint() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n}\n//# sourceMappingURL=ephemeral_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2VwaGVtZXJhbF92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDNUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsa0RBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jaGFubmVscy9lcGhlbWVyYWxfdmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEJhc2VDaGFubmVsIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbi8qKlxuICogU3RvcmVzIHRoZSB2YWx1ZSByZWNlaXZlZCBpbiB0aGUgc3RlcCBpbW1lZGlhdGVseSBwcmVjZWRpbmcsIGNsZWFycyBhZnRlci5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRXBoZW1lcmFsVmFsdWUgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiRXBoZW1lcmFsVmFsdWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3VhcmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdmFsdWUgaXMgYW4gYXJyYXkgc28gd2UgZG9uJ3QgbWlzaW50ZXJwcmV0IGFuIHVwZGF0ZSB0byB1bmRlZmluZWQgYXMgbm8gd3JpdGVcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmd1YXJkID0gZ3VhcmQ7XG4gICAgfVxuICAgIGZyb21DaGVja3BvaW50KGNoZWNrcG9pbnQpIHtcbiAgICAgICAgY29uc3QgZW1wdHkgPSBuZXcgRXBoZW1lcmFsVmFsdWUodGhpcy5ndWFyZCk7XG4gICAgICAgIGlmIChjaGVja3BvaW50KSB7XG4gICAgICAgICAgICBlbXB0eS52YWx1ZSA9IFtjaGVja3BvaW50XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBmb3IgdGhpcyBzcGVjaWZpYyBjaGFubmVsIGF0IHRoZSBlbmQgb2YgdGhlIHN0ZXAsIHdpcGUgaXQuXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gMSAmJiB0aGlzLmd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiRXBoZW1lcmFsVmFsdWUgY2FuIG9ubHkgcmVjZWl2ZSBvbmUgdmFsdWUgcGVyIHN0ZXAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB0aGlzLnZhbHVlID0gW3ZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUNoYW5uZWxFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgIH1cbiAgICBjaGVja3BvaW50KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUNoYW5uZWxFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVwaGVtZXJhbF92YWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/index.js":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/index.js ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseChannel: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChannel),\n/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _binop_js__WEBPACK_IMPORTED_MODULE_1__.BinaryOperatorAggregate),\n/* harmony export */   createCheckpoint: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.createCheckpoint),\n/* harmony export */   empty: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.emptyChannels)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _binop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binop.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js\");\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRjtBQUM5QjtBQUNyRCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEJhc2VDaGFubmVsLCBjcmVhdGVDaGVja3BvaW50LCBlbXB0eUNoYW5uZWxzIGFzIGVtcHR5LCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCB7IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlIH0gZnJvbSBcIi4vYmlub3AuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LastValue: () => (/* binding */ LastValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\n/**\n * Stores the last value received, can receive at most one value per step.\n *\n * Since `update` is only called once per step and value can only be of length 1,\n * LastValue always stores the last value of a single node. If multiple nodes attempt to\n * write to this channel in a single step, an error will be thrown.\n * @internal\n */\nclass LastValue extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"LastValue\"\n        });\n        // value is an array so we don't misinterpret an update to undefined as no write\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new LastValue();\n        if (checkpoint) {\n            empty.value = [checkpoint];\n        }\n        return empty;\n    }\n    update(values) {\n        if (values.length === 0) {\n            return false;\n        }\n        if (values.length !== 1) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(\"LastValue can only receive one value per step.\", {\n                lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\",\n            });\n        }\n        // eslint-disable-next-line prefer-destructuring\n        this.value = [values[values.length - 1]];\n        return true;\n    }\n    get() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n    checkpoint() {\n        if (this.value.length === 0) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return this.value[0];\n    }\n}\n//# sourceMappingURL=last_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2xhc3RfdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFO0FBQzdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsaURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFrQjtBQUN4QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL2xhc3RfdmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEJhc2VDaGFubmVsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBTdG9yZXMgdGhlIGxhc3QgdmFsdWUgcmVjZWl2ZWQsIGNhbiByZWNlaXZlIGF0IG1vc3Qgb25lIHZhbHVlIHBlciBzdGVwLlxuICpcbiAqIFNpbmNlIGB1cGRhdGVgIGlzIG9ubHkgY2FsbGVkIG9uY2UgcGVyIHN0ZXAgYW5kIHZhbHVlIGNhbiBvbmx5IGJlIG9mIGxlbmd0aCAxLFxuICogTGFzdFZhbHVlIGFsd2F5cyBzdG9yZXMgdGhlIGxhc3QgdmFsdWUgb2YgYSBzaW5nbGUgbm9kZS4gSWYgbXVsdGlwbGUgbm9kZXMgYXR0ZW1wdCB0b1xuICogd3JpdGUgdG8gdGhpcyBjaGFubmVsIGluIGEgc2luZ2xlIHN0ZXAsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXN0VmFsdWUgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiTGFzdFZhbHVlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHZhbHVlIGlzIGFuIGFycmF5IHNvIHdlIGRvbid0IG1pc2ludGVycHJldCBhbiB1cGRhdGUgdG8gdW5kZWZpbmVkIGFzIG5vIHdyaXRlXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnJvbUNoZWNrcG9pbnQoY2hlY2twb2ludCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IG5ldyBMYXN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQpIHtcbiAgICAgICAgICAgIGVtcHR5LnZhbHVlID0gW2NoZWNrcG9pbnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiTGFzdFZhbHVlIGNhbiBvbmx5IHJlY2VpdmUgb25lIHZhbHVlIHBlciBzdGVwLlwiLCB7XG4gICAgICAgICAgICAgICAgbGNfZXJyb3JfY29kZTogXCJJTlZBTElEX0NPTkNVUlJFTlRfR1JBUEhfVVBEQVRFXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdGhpcy52YWx1ZSA9IFt2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXTtcbiAgICB9XG4gICAgY2hlY2twb2ludCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0X3ZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NamedBarrierValue: () => (/* binding */ NamedBarrierValue),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n\n\nconst areSetsEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));\n/**\n * A channel that waits until all named values are received before making the value available.\n *\n * This ensures that if node N and node M both write to channel C, the value of C will not be updated\n * until N and M have completed updating.\n * @internal\n */\nclass NamedBarrierValue extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseChannel {\n    constructor(names) {\n        super();\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"NamedBarrierValue\"\n        });\n        Object.defineProperty(this, \"names\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        }); // Names of nodes that we want to wait for.\n        Object.defineProperty(this, \"seen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.names = names;\n        this.seen = new Set();\n    }\n    fromCheckpoint(checkpoint) {\n        const empty = new NamedBarrierValue(this.names);\n        if (checkpoint) {\n            empty.seen = new Set(checkpoint);\n        }\n        return empty;\n    }\n    update(values) {\n        let updated = false;\n        for (const nodeName of values) {\n            if (this.names.has(nodeName)) {\n                if (!this.seen.has(nodeName)) {\n                    this.seen.add(nodeName);\n                    updated = true;\n                }\n            }\n            else {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);\n            }\n        }\n        return updated;\n    }\n    // If we have not yet seen all the node names we want to wait for,\n    // throw an error to prevent continuing.\n    get() {\n        if (!areSetsEqual(this.names, this.seen)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError();\n        }\n        return undefined;\n    }\n    checkpoint() {\n        return [...this.seen];\n    }\n    consume() {\n        if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n            this.seen = new Set();\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=named_barrier_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL25hbWVkX2JhcnJpZXJfdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRTtBQUM3QjtBQUNqQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMERBQWtCLFVBQVUsMEJBQTBCLGVBQWUsMkJBQTJCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NoYW5uZWxzL25hbWVkX2JhcnJpZXJfdmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEJhc2VDaGFubmVsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGNvbnN0IGFyZVNldHNFcXVhbCA9IChhLCBiKSA9PiBhLnNpemUgPT09IGIuc2l6ZSAmJiBbLi4uYV0uZXZlcnkoKHZhbHVlKSA9PiBiLmhhcyh2YWx1ZSkpO1xuLyoqXG4gKiBBIGNoYW5uZWwgdGhhdCB3YWl0cyB1bnRpbCBhbGwgbmFtZWQgdmFsdWVzIGFyZSByZWNlaXZlZCBiZWZvcmUgbWFraW5nIHRoZSB2YWx1ZSBhdmFpbGFibGUuXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgaWYgbm9kZSBOIGFuZCBub2RlIE0gYm90aCB3cml0ZSB0byBjaGFubmVsIEMsIHRoZSB2YWx1ZSBvZiBDIHdpbGwgbm90IGJlIHVwZGF0ZWRcbiAqIHVudGlsIE4gYW5kIE0gaGF2ZSBjb21wbGV0ZWQgdXBkYXRpbmcuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVkQmFycmllclZhbHVlIGV4dGVuZHMgQmFzZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiTmFtZWRCYXJyaWVyVmFsdWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTsgLy8gTmFtZXMgb2Ygbm9kZXMgdGhhdCB3ZSB3YW50IHRvIHdhaXQgZm9yLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZXMgPSBuYW1lcztcbiAgICAgICAgdGhpcy5zZWVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBmcm9tQ2hlY2twb2ludChjaGVja3BvaW50KSB7XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gbmV3IE5hbWVkQmFycmllclZhbHVlKHRoaXMubmFtZXMpO1xuICAgICAgICBpZiAoY2hlY2twb2ludCkge1xuICAgICAgICAgICAgZW1wdHkuc2VlbiA9IG5ldyBTZXQoY2hlY2twb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZU5hbWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lcy5oYXMobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlZW4uaGFzKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZW4uYWRkKG5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgVmFsdWUgJHtKU09OLnN0cmluZ2lmeShub2RlTmFtZSl9IG5vdCBpbiBuYW1lcyAke0pTT04uc3RyaW5naWZ5KHRoaXMubmFtZXMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIG5vdCB5ZXQgc2VlbiBhbGwgdGhlIG5vZGUgbmFtZXMgd2Ugd2FudCB0byB3YWl0IGZvcixcbiAgICAvLyB0aHJvdyBhbiBlcnJvciB0byBwcmV2ZW50IGNvbnRpbnVpbmcuXG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbCh0aGlzLm5hbWVzLCB0aGlzLnNlZW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW1wdHlDaGFubmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaGVja3BvaW50KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc2Vlbl07XG4gICAgfVxuICAgIGNvbnN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZW4gJiYgdGhpcy5uYW1lcyAmJiBhcmVTZXRzRXF1YWwodGhpcy5zZWVuLCB0aGlzLm5hbWVzKSkge1xuICAgICAgICAgICAgdGhpcy5zZWVuID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVkX2JhcnJpZXJfdmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHECKPOINT_NAMESPACE_END: () => (/* binding */ CHECKPOINT_NAMESPACE_END),\n/* harmony export */   CHECKPOINT_NAMESPACE_SEPARATOR: () => (/* binding */ CHECKPOINT_NAMESPACE_SEPARATOR),\n/* harmony export */   CONFIG_KEY_ABORT_SIGNALS: () => (/* binding */ CONFIG_KEY_ABORT_SIGNALS),\n/* harmony export */   CONFIG_KEY_CALL: () => (/* binding */ CONFIG_KEY_CALL),\n/* harmony export */   CONFIG_KEY_CHECKPOINTER: () => (/* binding */ CONFIG_KEY_CHECKPOINTER),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_ID: () => (/* binding */ CONFIG_KEY_CHECKPOINT_ID),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_MAP: () => (/* binding */ CONFIG_KEY_CHECKPOINT_MAP),\n/* harmony export */   CONFIG_KEY_CHECKPOINT_NS: () => (/* binding */ CONFIG_KEY_CHECKPOINT_NS),\n/* harmony export */   CONFIG_KEY_NODE_FINISHED: () => (/* binding */ CONFIG_KEY_NODE_FINISHED),\n/* harmony export */   CONFIG_KEY_PREVIOUS_STATE: () => (/* binding */ CONFIG_KEY_PREVIOUS_STATE),\n/* harmony export */   CONFIG_KEY_READ: () => (/* binding */ CONFIG_KEY_READ),\n/* harmony export */   CONFIG_KEY_RESUME_VALUE: () => (/* binding */ CONFIG_KEY_RESUME_VALUE),\n/* harmony export */   CONFIG_KEY_RESUMING: () => (/* binding */ CONFIG_KEY_RESUMING),\n/* harmony export */   CONFIG_KEY_SCRATCHPAD: () => (/* binding */ CONFIG_KEY_SCRATCHPAD),\n/* harmony export */   CONFIG_KEY_SEND: () => (/* binding */ CONFIG_KEY_SEND),\n/* harmony export */   CONFIG_KEY_STREAM: () => (/* binding */ CONFIG_KEY_STREAM),\n/* harmony export */   CONFIG_KEY_TASK_ID: () => (/* binding */ CONFIG_KEY_TASK_ID),\n/* harmony export */   COPY: () => (/* binding */ COPY),\n/* harmony export */   Command: () => (/* binding */ Command),\n/* harmony export */   END: () => (/* binding */ END),\n/* harmony export */   ERROR: () => (/* binding */ ERROR),\n/* harmony export */   INPUT: () => (/* binding */ INPUT),\n/* harmony export */   INTERRUPT: () => (/* binding */ INTERRUPT),\n/* harmony export */   NO_WRITES: () => (/* binding */ NO_WRITES),\n/* harmony export */   NULL_TASK_ID: () => (/* binding */ NULL_TASK_ID),\n/* harmony export */   PREVIOUS: () => (/* binding */ PREVIOUS),\n/* harmony export */   PULL: () => (/* binding */ PULL),\n/* harmony export */   PUSH: () => (/* binding */ PUSH),\n/* harmony export */   RECURSION_LIMIT_DEFAULT: () => (/* binding */ RECURSION_LIMIT_DEFAULT),\n/* harmony export */   RESERVED: () => (/* binding */ RESERVED),\n/* harmony export */   RESUME: () => (/* binding */ RESUME),\n/* harmony export */   RETURN: () => (/* binding */ RETURN),\n/* harmony export */   RUNTIME_PLACEHOLDER: () => (/* binding */ RUNTIME_PLACEHOLDER),\n/* harmony export */   SELF: () => (/* binding */ SELF),\n/* harmony export */   START: () => (/* binding */ START),\n/* harmony export */   Send: () => (/* binding */ Send),\n/* harmony export */   TAG_HIDDEN: () => (/* binding */ TAG_HIDDEN),\n/* harmony export */   TAG_NOSTREAM: () => (/* binding */ TAG_NOSTREAM),\n/* harmony export */   TASKS: () => (/* binding */ TASKS),\n/* harmony export */   TASK_NAMESPACE: () => (/* binding */ TASK_NAMESPACE),\n/* harmony export */   _deserializeCommandSendObjectGraph: () => (/* binding */ _deserializeCommandSendObjectGraph),\n/* harmony export */   _isSend: () => (/* binding */ _isSend),\n/* harmony export */   _isSendInterface: () => (/* binding */ _isSendInterface),\n/* harmony export */   isCommand: () => (/* binding */ isCommand)\n/* harmony export */ });\n/** Special reserved node name denoting the start of a graph. */\nconst START = \"__start__\";\n/** Special reserved node name denoting the end of a graph. */\nconst END = \"__end__\";\nconst INPUT = \"__input__\";\nconst COPY = \"__copy__\";\nconst ERROR = \"__error__\";\nconst CONFIG_KEY_SEND = \"__pregel_send\";\n/** config key containing function used to call a node (push task) */\nconst CONFIG_KEY_CALL = \"__pregel_call\";\nconst CONFIG_KEY_READ = \"__pregel_read\";\nconst CONFIG_KEY_CHECKPOINTER = \"__pregel_checkpointer\";\nconst CONFIG_KEY_RESUMING = \"__pregel_resuming\";\nconst CONFIG_KEY_TASK_ID = \"__pregel_task_id\";\nconst CONFIG_KEY_STREAM = \"__pregel_stream\";\nconst CONFIG_KEY_RESUME_VALUE = \"__pregel_resume_value\";\nconst CONFIG_KEY_SCRATCHPAD = \"__pregel_scratchpad\";\n/** config key containing state from previous invocation of graph for the given thread */\nconst CONFIG_KEY_PREVIOUS_STATE = \"__pregel_previous\";\nconst CONFIG_KEY_CHECKPOINT_ID = \"checkpoint_id\";\nconst CONFIG_KEY_CHECKPOINT_NS = \"checkpoint_ns\";\nconst CONFIG_KEY_NODE_FINISHED = \"__pregel_node_finished\";\n// this one is part of public API\nconst CONFIG_KEY_CHECKPOINT_MAP = \"checkpoint_map\";\nconst CONFIG_KEY_ABORT_SIGNALS = \"__pregel_abort_signals\";\n/** Special channel reserved for graph interrupts */\nconst INTERRUPT = \"__interrupt__\";\n/** Special channel reserved for graph resume */\nconst RESUME = \"__resume__\";\n/** Special channel reserved for cases when a task exits without any writes */\nconst NO_WRITES = \"__no_writes__\";\n/** Special channel reserved for graph return */\nconst RETURN = \"__return__\";\n/** Special channel reserved for graph previous state */\nconst PREVIOUS = \"__previous__\";\nconst RUNTIME_PLACEHOLDER = \"__pregel_runtime_placeholder__\";\nconst RECURSION_LIMIT_DEFAULT = 25;\nconst TAG_HIDDEN = \"langsmith:hidden\";\nconst TAG_NOSTREAM = \"langsmith:nostream\";\nconst SELF = \"__self__\";\nconst TASKS = \"__pregel_tasks\";\nconst PUSH = \"__pregel_push\";\nconst PULL = \"__pregel_pull\";\nconst TASK_NAMESPACE = \"6ba7b831-9dad-11d1-80b4-00c04fd430c8\";\nconst NULL_TASK_ID = \"00000000-0000-0000-0000-000000000000\";\nconst RESERVED = [\n    TAG_HIDDEN,\n    INPUT,\n    INTERRUPT,\n    RESUME,\n    ERROR,\n    NO_WRITES,\n    TASKS,\n    // reserved config.configurable keys\n    CONFIG_KEY_SEND,\n    CONFIG_KEY_READ,\n    CONFIG_KEY_CHECKPOINTER,\n    CONFIG_KEY_STREAM,\n    CONFIG_KEY_RESUMING,\n    CONFIG_KEY_TASK_ID,\n    CONFIG_KEY_CALL,\n    CONFIG_KEY_RESUME_VALUE,\n    CONFIG_KEY_SCRATCHPAD,\n    CONFIG_KEY_PREVIOUS_STATE,\n    CONFIG_KEY_CHECKPOINT_MAP,\n    CONFIG_KEY_CHECKPOINT_NS,\n    CONFIG_KEY_CHECKPOINT_ID,\n];\nconst CHECKPOINT_NAMESPACE_SEPARATOR = \"|\";\nconst CHECKPOINT_NAMESPACE_END = \":\";\nfunction _isSendInterface(x) {\n    const operation = x;\n    return (operation !== null &&\n        operation !== undefined &&\n        typeof operation.node === \"string\" &&\n        operation.args !== undefined);\n}\n/**\n *\n * A message or packet to send to a specific node in the graph.\n *\n * The `Send` class is used within a `StateGraph`'s conditional edges to\n * dynamically invoke a node with a custom state at the next step.\n *\n * Importantly, the sent state can differ from the core graph's state,\n * allowing for flexible and dynamic workflow management.\n *\n * One such example is a \"map-reduce\" workflow where your graph invokes\n * the same node multiple times in parallel with different states,\n * before aggregating the results back into the main graph's state.\n *\n * @example\n * ```typescript\n * import { Annotation, Send, StateGraph } from \"@langchain/langgraph\";\n *\n * const ChainState = Annotation.Root({\n *   subjects: Annotation<string[]>,\n *   jokes: Annotation<string[]>({\n *     reducer: (a, b) => a.concat(b),\n *   }),\n * });\n *\n * const continueToJokes = async (state: typeof ChainState.State) => {\n *   return state.subjects.map((subject) => {\n *     return new Send(\"generate_joke\", { subjects: [subject] });\n *   });\n * };\n *\n * const graph = new StateGraph(ChainState)\n *   .addNode(\"generate_joke\", (state) => ({\n *     jokes: [`Joke about ${state.subjects}`],\n *   }))\n *   .addConditionalEdges(\"__start__\", continueToJokes)\n *   .addEdge(\"generate_joke\", \"__end__\")\n *   .compile();\n *\n * const res = await graph.invoke({ subjects: [\"cats\", \"dogs\"] });\n * console.log(res);\n *\n * // Invoking with two subjects results in a generated joke for each\n * // { subjects: [\"cats\", \"dogs\"], jokes: [`Joke about cats`, `Joke about dogs`] }\n * ```\n */\nclass Send {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(node, args) {\n        Object.defineProperty(this, \"lg_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Send\"\n        });\n        Object.defineProperty(this, \"node\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"args\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.node = node;\n        this.args = _deserializeCommandSendObjectGraph(args);\n    }\n    toJSON() {\n        return {\n            lg_name: this.lg_name,\n            node: this.node,\n            args: this.args,\n        };\n    }\n}\nfunction _isSend(x) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    return x instanceof Send;\n}\n/**\n * One or more commands to update the graph's state and send messages to nodes.\n * Can be used to combine routing logic with state updates in lieu of conditional edges\n *\n * @example\n * ```ts\n * import { Annotation, Command } from \"@langchain/langgraph\";\n *\n * // Define graph state\n * const StateAnnotation = Annotation.Root({\n *   foo: Annotation<string>,\n * });\n *\n * // Define the nodes\n * const nodeA = async (_state: typeof StateAnnotation.State) => {\n *   console.log(\"Called A\");\n *   // this is a replacement for a real conditional edge function\n *   const goto = Math.random() > .5 ? \"nodeB\" : \"nodeC\";\n *   // note how Command allows you to BOTH update the graph state AND route to the next node\n *   return new Command({\n *     // this is the state update\n *     update: {\n *       foo: \"a\",\n *     },\n *     // this is a replacement for an edge\n *     goto,\n *   });\n * };\n *\n * // Nodes B and C are unchanged\n * const nodeB = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called B\");\n *   return {\n *     foo: state.foo + \"|b\",\n *   };\n * }\n *\n * const nodeC = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called C\");\n *   return {\n *     foo: state.foo + \"|c\",\n *   };\n * }\n *\n * import { StateGraph } from \"@langchain/langgraph\";\n\n * // NOTE: there are no edges between nodes A, B and C!\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(\"nodeA\", nodeA, {\n *     ends: [\"nodeB\", \"nodeC\"],\n *   })\n *   .addNode(\"nodeB\", nodeB)\n *   .addNode(\"nodeC\", nodeC)\n *   .addEdge(\"__start__\", \"nodeA\")\n *   .compile();\n *\n * await graph.invoke({ foo: \"\" });\n *\n * // Randomly oscillates between\n * // { foo: 'a|c' } and { foo: 'a|b' }\n * ```\n */\nclass Command {\n    constructor(args) {\n        Object.defineProperty(this, \"lg_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Command\"\n        });\n        Object.defineProperty(this, \"lc_direct_tool_output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Graph to send the command to. Supported values are:\n         *   - None: the current graph (default)\n         *   - The specific name of the graph to send the command to\n         *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n         */\n        Object.defineProperty(this, \"graph\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Update to apply to the graph's state as a result of executing the node that is returning the command.\n         * Written to the state as if the node had simply returned this value instead of the Command object.\n         */\n        Object.defineProperty(this, \"update\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Value to resume execution with. To be used together with {@link interrupt}.\n         */\n        Object.defineProperty(this, \"resume\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Can be one of the following:\n         *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n         *   - sequence of node names to navigate to next\n         *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)\n         *   - sequence of {@link Send} objects\n         */\n        Object.defineProperty(this, \"goto\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.resume = args.resume;\n        this.graph = args.graph;\n        this.update = args.update;\n        if (args.goto) {\n            this.goto = Array.isArray(args.goto)\n                ? _deserializeCommandSendObjectGraph(args.goto)\n                : [_deserializeCommandSendObjectGraph(args.goto)];\n        }\n    }\n    /**\n     * Convert the update field to a list of {@link PendingWrite} tuples\n     * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.\n     * @internal\n     */\n    _updateAsTuples() {\n        if (this.update &&\n            typeof this.update === \"object\" &&\n            !Array.isArray(this.update)) {\n            return Object.entries(this.update);\n        }\n        else if (Array.isArray(this.update) &&\n            this.update.every((t) => Array.isArray(t) && t.length === 2 && typeof t[0] === \"string\")) {\n            return this.update;\n        }\n        else {\n            return [[\"__root__\", this.update]];\n        }\n    }\n    toJSON() {\n        let serializedGoto;\n        if (typeof this.goto === \"string\") {\n            serializedGoto = this.goto;\n        }\n        else if (_isSend(this.goto)) {\n            serializedGoto = this.goto.toJSON();\n        }\n        else {\n            serializedGoto = this.goto?.map((innerGoto) => {\n                if (typeof innerGoto === \"string\") {\n                    return innerGoto;\n                }\n                else {\n                    return innerGoto.toJSON();\n                }\n            });\n        }\n        return {\n            lg_name: this.lg_name,\n            update: this.update,\n            resume: this.resume,\n            goto: serializedGoto,\n        };\n    }\n}\nObject.defineProperty(Command, \"PARENT\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__parent__\"\n});\n/**\n * A type guard to check if the given value is a {@link Command}.\n *\n * Useful for type narrowing when working with the {@link Command} object.\n *\n * @param x - The value to check.\n * @returns `true` if the value is a {@link Command}, `false` otherwise.\n */\nfunction isCommand(x) {\n    if (typeof x !== \"object\") {\n        return false;\n    }\n    if (x === null || x === undefined) {\n        return false;\n    }\n    if (\"lg_name\" in x && x.lg_name === \"Command\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Reconstructs Command and Send objects from a deeply nested tree of anonymous objects\n * matching their interfaces.\n *\n * This is only exported for testing purposes. It is NOT intended to be used outside of\n * the Command and Send classes.\n *\n * @internal\n *\n * @param x - The command send tree to convert.\n * @param seen - A map of seen objects to avoid infinite loops.\n * @returns The converted command send tree.\n */\nfunction _deserializeCommandSendObjectGraph(x, seen = new Map()) {\n    if (x !== undefined && x !== null && typeof x === \"object\") {\n        // If we've already processed this object, return the transformed version\n        if (seen.has(x)) {\n            return seen.get(x);\n        }\n        let result;\n        if (Array.isArray(x)) {\n            // Create the array first, then populate it\n            result = [];\n            // Add to seen map before processing elements to handle self-references\n            seen.set(x, result);\n            // Now populate the array\n            x.forEach((item, index) => {\n                result[index] = _deserializeCommandSendObjectGraph(item, seen);\n            });\n            // eslint-disable-next-line no-instanceof/no-instanceof\n        }\n        else if (isCommand(x) && !(x instanceof Command)) {\n            result = new Command(x);\n            seen.set(x, result);\n            // eslint-disable-next-line no-instanceof/no-instanceof\n        }\n        else if (_isSendInterface(x) && !(x instanceof Send)) {\n            result = new Send(x.node, x.args);\n            seen.set(x, result);\n        }\n        else if (isCommand(x) || _isSend(x)) {\n            result = x;\n            seen.set(x, result);\n        }\n        else if (\"lc_serializable\" in x && x.lc_serializable) {\n            result = x;\n            seen.set(x, result);\n        }\n        else {\n            // Create empty object first\n            result = {};\n            // Add to seen map before processing properties to handle self-references\n            seen.set(x, result);\n            // Now populate the object\n            for (const [key, value] of Object.entries(x)) {\n                result[key] =\n                    _deserializeCommandSendObjectGraph(value, seen);\n            }\n        }\n        return result;\n    }\n    return x;\n}\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsUUFBUSxhQUFhLE1BQU07QUFDM0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLGdFQUFnRSxZQUFZO0FBQ3hHLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEUseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFNwZWNpYWwgcmVzZXJ2ZWQgbm9kZSBuYW1lIGRlbm90aW5nIHRoZSBzdGFydCBvZiBhIGdyYXBoLiAqL1xuZXhwb3J0IGNvbnN0IFNUQVJUID0gXCJfX3N0YXJ0X19cIjtcbi8qKiBTcGVjaWFsIHJlc2VydmVkIG5vZGUgbmFtZSBkZW5vdGluZyB0aGUgZW5kIG9mIGEgZ3JhcGguICovXG5leHBvcnQgY29uc3QgRU5EID0gXCJfX2VuZF9fXCI7XG5leHBvcnQgY29uc3QgSU5QVVQgPSBcIl9faW5wdXRfX1wiO1xuZXhwb3J0IGNvbnN0IENPUFkgPSBcIl9fY29weV9fXCI7XG5leHBvcnQgY29uc3QgRVJST1IgPSBcIl9fZXJyb3JfX1wiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfU0VORCA9IFwiX19wcmVnZWxfc2VuZFwiO1xuLyoqIGNvbmZpZyBrZXkgY29udGFpbmluZyBmdW5jdGlvbiB1c2VkIHRvIGNhbGwgYSBub2RlIChwdXNoIHRhc2spICovXG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9DQUxMID0gXCJfX3ByZWdlbF9jYWxsXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9SRUFEID0gXCJfX3ByZWdlbF9yZWFkXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9DSEVDS1BPSU5URVIgPSBcIl9fcHJlZ2VsX2NoZWNrcG9pbnRlclwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfUkVTVU1JTkcgPSBcIl9fcHJlZ2VsX3Jlc3VtaW5nXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9UQVNLX0lEID0gXCJfX3ByZWdlbF90YXNrX2lkXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9TVFJFQU0gPSBcIl9fcHJlZ2VsX3N0cmVhbVwiO1xuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfUkVTVU1FX1ZBTFVFID0gXCJfX3ByZWdlbF9yZXN1bWVfdmFsdWVcIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX1NDUkFUQ0hQQUQgPSBcIl9fcHJlZ2VsX3NjcmF0Y2hwYWRcIjtcbi8qKiBjb25maWcga2V5IGNvbnRhaW5pbmcgc3RhdGUgZnJvbSBwcmV2aW91cyBpbnZvY2F0aW9uIG9mIGdyYXBoIGZvciB0aGUgZ2l2ZW4gdGhyZWFkICovXG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9QUkVWSU9VU19TVEFURSA9IFwiX19wcmVnZWxfcHJldmlvdXNcIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX0NIRUNLUE9JTlRfSUQgPSBcImNoZWNrcG9pbnRfaWRcIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTlMgPSBcImNoZWNrcG9pbnRfbnNcIjtcbmV4cG9ydCBjb25zdCBDT05GSUdfS0VZX05PREVfRklOSVNIRUQgPSBcIl9fcHJlZ2VsX25vZGVfZmluaXNoZWRcIjtcbi8vIHRoaXMgb25lIGlzIHBhcnQgb2YgcHVibGljIEFQSVxuZXhwb3J0IGNvbnN0IENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVAgPSBcImNoZWNrcG9pbnRfbWFwXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0tFWV9BQk9SVF9TSUdOQUxTID0gXCJfX3ByZWdlbF9hYm9ydF9zaWduYWxzXCI7XG4vKiogU3BlY2lhbCBjaGFubmVsIHJlc2VydmVkIGZvciBncmFwaCBpbnRlcnJ1cHRzICovXG5leHBvcnQgY29uc3QgSU5URVJSVVBUID0gXCJfX2ludGVycnVwdF9fXCI7XG4vKiogU3BlY2lhbCBjaGFubmVsIHJlc2VydmVkIGZvciBncmFwaCByZXN1bWUgKi9cbmV4cG9ydCBjb25zdCBSRVNVTUUgPSBcIl9fcmVzdW1lX19cIjtcbi8qKiBTcGVjaWFsIGNoYW5uZWwgcmVzZXJ2ZWQgZm9yIGNhc2VzIHdoZW4gYSB0YXNrIGV4aXRzIHdpdGhvdXQgYW55IHdyaXRlcyAqL1xuZXhwb3J0IGNvbnN0IE5PX1dSSVRFUyA9IFwiX19ub193cml0ZXNfX1wiO1xuLyoqIFNwZWNpYWwgY2hhbm5lbCByZXNlcnZlZCBmb3IgZ3JhcGggcmV0dXJuICovXG5leHBvcnQgY29uc3QgUkVUVVJOID0gXCJfX3JldHVybl9fXCI7XG4vKiogU3BlY2lhbCBjaGFubmVsIHJlc2VydmVkIGZvciBncmFwaCBwcmV2aW91cyBzdGF0ZSAqL1xuZXhwb3J0IGNvbnN0IFBSRVZJT1VTID0gXCJfX3ByZXZpb3VzX19cIjtcbmV4cG9ydCBjb25zdCBSVU5USU1FX1BMQUNFSE9MREVSID0gXCJfX3ByZWdlbF9ydW50aW1lX3BsYWNlaG9sZGVyX19cIjtcbmV4cG9ydCBjb25zdCBSRUNVUlNJT05fTElNSVRfREVGQVVMVCA9IDI1O1xuZXhwb3J0IGNvbnN0IFRBR19ISURERU4gPSBcImxhbmdzbWl0aDpoaWRkZW5cIjtcbmV4cG9ydCBjb25zdCBUQUdfTk9TVFJFQU0gPSBcImxhbmdzbWl0aDpub3N0cmVhbVwiO1xuZXhwb3J0IGNvbnN0IFNFTEYgPSBcIl9fc2VsZl9fXCI7XG5leHBvcnQgY29uc3QgVEFTS1MgPSBcIl9fcHJlZ2VsX3Rhc2tzXCI7XG5leHBvcnQgY29uc3QgUFVTSCA9IFwiX19wcmVnZWxfcHVzaFwiO1xuZXhwb3J0IGNvbnN0IFBVTEwgPSBcIl9fcHJlZ2VsX3B1bGxcIjtcbmV4cG9ydCBjb25zdCBUQVNLX05BTUVTUEFDRSA9IFwiNmJhN2I4MzEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4XCI7XG5leHBvcnQgY29uc3QgTlVMTF9UQVNLX0lEID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIjtcbmV4cG9ydCBjb25zdCBSRVNFUlZFRCA9IFtcbiAgICBUQUdfSElEREVOLFxuICAgIElOUFVULFxuICAgIElOVEVSUlVQVCxcbiAgICBSRVNVTUUsXG4gICAgRVJST1IsXG4gICAgTk9fV1JJVEVTLFxuICAgIFRBU0tTLFxuICAgIC8vIHJlc2VydmVkIGNvbmZpZy5jb25maWd1cmFibGUga2V5c1xuICAgIENPTkZJR19LRVlfU0VORCxcbiAgICBDT05GSUdfS0VZX1JFQUQsXG4gICAgQ09ORklHX0tFWV9DSEVDS1BPSU5URVIsXG4gICAgQ09ORklHX0tFWV9TVFJFQU0sXG4gICAgQ09ORklHX0tFWV9SRVNVTUlORyxcbiAgICBDT05GSUdfS0VZX1RBU0tfSUQsXG4gICAgQ09ORklHX0tFWV9DQUxMLFxuICAgIENPTkZJR19LRVlfUkVTVU1FX1ZBTFVFLFxuICAgIENPTkZJR19LRVlfU0NSQVRDSFBBRCxcbiAgICBDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFLFxuICAgIENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVAsXG4gICAgQ09ORklHX0tFWV9DSEVDS1BPSU5UX05TLFxuICAgIENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9JRCxcbl07XG5leHBvcnQgY29uc3QgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SID0gXCJ8XCI7XG5leHBvcnQgY29uc3QgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5EID0gXCI6XCI7XG5leHBvcnQgZnVuY3Rpb24gX2lzU2VuZEludGVyZmFjZSh4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0geDtcbiAgICByZXR1cm4gKG9wZXJhdGlvbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcGVyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLm5vZGUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgb3BlcmF0aW9uLmFyZ3MgIT09IHVuZGVmaW5lZCk7XG59XG4vKipcbiAqXG4gKiBBIG1lc3NhZ2Ugb3IgcGFja2V0IHRvIHNlbmQgdG8gYSBzcGVjaWZpYyBub2RlIGluIHRoZSBncmFwaC5cbiAqXG4gKiBUaGUgYFNlbmRgIGNsYXNzIGlzIHVzZWQgd2l0aGluIGEgYFN0YXRlR3JhcGhgJ3MgY29uZGl0aW9uYWwgZWRnZXMgdG9cbiAqIGR5bmFtaWNhbGx5IGludm9rZSBhIG5vZGUgd2l0aCBhIGN1c3RvbSBzdGF0ZSBhdCB0aGUgbmV4dCBzdGVwLlxuICpcbiAqIEltcG9ydGFudGx5LCB0aGUgc2VudCBzdGF0ZSBjYW4gZGlmZmVyIGZyb20gdGhlIGNvcmUgZ3JhcGgncyBzdGF0ZSxcbiAqIGFsbG93aW5nIGZvciBmbGV4aWJsZSBhbmQgZHluYW1pYyB3b3JrZmxvdyBtYW5hZ2VtZW50LlxuICpcbiAqIE9uZSBzdWNoIGV4YW1wbGUgaXMgYSBcIm1hcC1yZWR1Y2VcIiB3b3JrZmxvdyB3aGVyZSB5b3VyIGdyYXBoIGludm9rZXNcbiAqIHRoZSBzYW1lIG5vZGUgbXVsdGlwbGUgdGltZXMgaW4gcGFyYWxsZWwgd2l0aCBkaWZmZXJlbnQgc3RhdGVzLFxuICogYmVmb3JlIGFnZ3JlZ2F0aW5nIHRoZSByZXN1bHRzIGJhY2sgaW50byB0aGUgbWFpbiBncmFwaCdzIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBBbm5vdGF0aW9uLCBTZW5kLCBTdGF0ZUdyYXBoIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKlxuICogY29uc3QgQ2hhaW5TdGF0ZSA9IEFubm90YXRpb24uUm9vdCh7XG4gKiAgIHN1YmplY3RzOiBBbm5vdGF0aW9uPHN0cmluZ1tdPixcbiAqICAgam9rZXM6IEFubm90YXRpb248c3RyaW5nW10+KHtcbiAqICAgICByZWR1Y2VyOiAoYSwgYikgPT4gYS5jb25jYXQoYiksXG4gKiAgIH0pLFxuICogfSk7XG4gKlxuICogY29uc3QgY29udGludWVUb0pva2VzID0gYXN5bmMgKHN0YXRlOiB0eXBlb2YgQ2hhaW5TdGF0ZS5TdGF0ZSkgPT4ge1xuICogICByZXR1cm4gc3RhdGUuc3ViamVjdHMubWFwKChzdWJqZWN0KSA9PiB7XG4gKiAgICAgcmV0dXJuIG5ldyBTZW5kKFwiZ2VuZXJhdGVfam9rZVwiLCB7IHN1YmplY3RzOiBbc3ViamVjdF0gfSk7XG4gKiAgIH0pO1xuICogfTtcbiAqXG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKENoYWluU3RhdGUpXG4gKiAgIC5hZGROb2RlKFwiZ2VuZXJhdGVfam9rZVwiLCAoc3RhdGUpID0+ICh7XG4gKiAgICAgam9rZXM6IFtgSm9rZSBhYm91dCAke3N0YXRlLnN1YmplY3RzfWBdLFxuICogICB9KSlcbiAqICAgLmFkZENvbmRpdGlvbmFsRWRnZXMoXCJfX3N0YXJ0X19cIiwgY29udGludWVUb0pva2VzKVxuICogICAuYWRkRWRnZShcImdlbmVyYXRlX2pva2VcIiwgXCJfX2VuZF9fXCIpXG4gKiAgIC5jb21waWxlKCk7XG4gKlxuICogY29uc3QgcmVzID0gYXdhaXQgZ3JhcGguaW52b2tlKHsgc3ViamVjdHM6IFtcImNhdHNcIiwgXCJkb2dzXCJdIH0pO1xuICogY29uc29sZS5sb2cocmVzKTtcbiAqXG4gKiAvLyBJbnZva2luZyB3aXRoIHR3byBzdWJqZWN0cyByZXN1bHRzIGluIGEgZ2VuZXJhdGVkIGpva2UgZm9yIGVhY2hcbiAqIC8vIHsgc3ViamVjdHM6IFtcImNhdHNcIiwgXCJkb2dzXCJdLCBqb2tlczogW2BKb2tlIGFib3V0IGNhdHNgLCBgSm9rZSBhYm91dCBkb2dzYF0gfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTZW5kIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGFyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGdfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJTZW5kXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmFyZ3MgPSBfZGVzZXJpYWxpemVDb21tYW5kU2VuZE9iamVjdEdyYXBoKGFyZ3MpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZ19uYW1lOiB0aGlzLmxnX25hbWUsXG4gICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICBhcmdzOiB0aGlzLmFyZ3MsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIF9pc1NlbmQoeCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIFNlbmQ7XG59XG4vKipcbiAqIE9uZSBvciBtb3JlIGNvbW1hbmRzIHRvIHVwZGF0ZSB0aGUgZ3JhcGgncyBzdGF0ZSBhbmQgc2VuZCBtZXNzYWdlcyB0byBub2Rlcy5cbiAqIENhbiBiZSB1c2VkIHRvIGNvbWJpbmUgcm91dGluZyBsb2dpYyB3aXRoIHN0YXRlIHVwZGF0ZXMgaW4gbGlldSBvZiBjb25kaXRpb25hbCBlZGdlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQW5ub3RhdGlvbiwgQ29tbWFuZCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIC8vIERlZmluZSBncmFwaCBzdGF0ZVxuICogY29uc3QgU3RhdGVBbm5vdGF0aW9uID0gQW5ub3RhdGlvbi5Sb290KHtcbiAqICAgZm9vOiBBbm5vdGF0aW9uPHN0cmluZz4sXG4gKiB9KTtcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIG5vZGVzXG4gKiBjb25zdCBub2RlQSA9IGFzeW5jIChfc3RhdGU6IHR5cGVvZiBTdGF0ZUFubm90YXRpb24uU3RhdGUpID0+IHtcbiAqICAgY29uc29sZS5sb2coXCJDYWxsZWQgQVwiKTtcbiAqICAgLy8gdGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBhIHJlYWwgY29uZGl0aW9uYWwgZWRnZSBmdW5jdGlvblxuICogICBjb25zdCBnb3RvID0gTWF0aC5yYW5kb20oKSA+IC41ID8gXCJub2RlQlwiIDogXCJub2RlQ1wiO1xuICogICAvLyBub3RlIGhvdyBDb21tYW5kIGFsbG93cyB5b3UgdG8gQk9USCB1cGRhdGUgdGhlIGdyYXBoIHN0YXRlIEFORCByb3V0ZSB0byB0aGUgbmV4dCBub2RlXG4gKiAgIHJldHVybiBuZXcgQ29tbWFuZCh7XG4gKiAgICAgLy8gdGhpcyBpcyB0aGUgc3RhdGUgdXBkYXRlXG4gKiAgICAgdXBkYXRlOiB7XG4gKiAgICAgICBmb286IFwiYVwiLFxuICogICAgIH0sXG4gKiAgICAgLy8gdGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBhbiBlZGdlXG4gKiAgICAgZ290byxcbiAqICAgfSk7XG4gKiB9O1xuICpcbiAqIC8vIE5vZGVzIEIgYW5kIEMgYXJlIHVuY2hhbmdlZFxuICogY29uc3Qgbm9kZUIgPSBhc3luYyAoc3RhdGU6IHR5cGVvZiBTdGF0ZUFubm90YXRpb24uU3RhdGUpID0+IHtcbiAqICAgY29uc29sZS5sb2coXCJDYWxsZWQgQlwiKTtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBmb286IHN0YXRlLmZvbyArIFwifGJcIixcbiAqICAgfTtcbiAqIH1cbiAqXG4gKiBjb25zdCBub2RlQyA9IGFzeW5jIChzdGF0ZTogdHlwZW9mIFN0YXRlQW5ub3RhdGlvbi5TdGF0ZSkgPT4ge1xuICogICBjb25zb2xlLmxvZyhcIkNhbGxlZCBDXCIpO1xuICogICByZXR1cm4ge1xuICogICAgIGZvbzogc3RhdGUuZm9vICsgXCJ8Y1wiLFxuICogICB9O1xuICogfVxuICpcbiAqIGltcG9ydCB7IFN0YXRlR3JhcGggfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcblxuICogLy8gTk9URTogdGhlcmUgYXJlIG5vIGVkZ2VzIGJldHdlZW4gbm9kZXMgQSwgQiBhbmQgQyFcbiAqIGNvbnN0IGdyYXBoID0gbmV3IFN0YXRlR3JhcGgoU3RhdGVBbm5vdGF0aW9uKVxuICogICAuYWRkTm9kZShcIm5vZGVBXCIsIG5vZGVBLCB7XG4gKiAgICAgZW5kczogW1wibm9kZUJcIiwgXCJub2RlQ1wiXSxcbiAqICAgfSlcbiAqICAgLmFkZE5vZGUoXCJub2RlQlwiLCBub2RlQilcbiAqICAgLmFkZE5vZGUoXCJub2RlQ1wiLCBub2RlQylcbiAqICAgLmFkZEVkZ2UoXCJfX3N0YXJ0X19cIiwgXCJub2RlQVwiKVxuICogICAuY29tcGlsZSgpO1xuICpcbiAqIGF3YWl0IGdyYXBoLmludm9rZSh7IGZvbzogXCJcIiB9KTtcbiAqXG4gKiAvLyBSYW5kb21seSBvc2NpbGxhdGVzIGJldHdlZW5cbiAqIC8vIHsgZm9vOiAnYXxjJyB9IGFuZCB7IGZvbzogJ2F8YicgfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxnX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiQ29tbWFuZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19kaXJlY3RfdG9vbF9vdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCB0byBzZW5kIHRoZSBjb21tYW5kIHRvLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZTpcbiAgICAgICAgICogICAtIE5vbmU6IHRoZSBjdXJyZW50IGdyYXBoIChkZWZhdWx0KVxuICAgICAgICAgKiAgIC0gVGhlIHNwZWNpZmljIG5hbWUgb2YgdGhlIGdyYXBoIHRvIHNlbmQgdGhlIGNvbW1hbmQgdG9cbiAgICAgICAgICogICAtIHtAbGluayBDb21tYW5kLlBBUkVOVH06IGNsb3Nlc3QgcGFyZW50IGdyYXBoIChvbmx5IHN1cHBvcnRlZCB3aGVuIHJldHVybmVkIGZyb20gYSBub2RlIGluIGEgc3ViZ3JhcGgpXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJncmFwaFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBncmFwaCdzIHN0YXRlIGFzIGEgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgbm9kZSB0aGF0IGlzIHJldHVybmluZyB0aGUgY29tbWFuZC5cbiAgICAgICAgICogV3JpdHRlbiB0byB0aGUgc3RhdGUgYXMgaWYgdGhlIG5vZGUgaGFkIHNpbXBseSByZXR1cm5lZCB0aGlzIHZhbHVlIGluc3RlYWQgb2YgdGhlIENvbW1hbmQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXBkYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSB0byByZXN1bWUgZXhlY3V0aW9uIHdpdGguIFRvIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB7QGxpbmsgaW50ZXJydXB0fS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3VtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKiAgIC0gbmFtZSBvZiB0aGUgbm9kZSB0byBuYXZpZ2F0ZSB0byBuZXh0IChhbnkgbm9kZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIHNwZWNpZmllZCBgZ3JhcGhgKVxuICAgICAgICAgKiAgIC0gc2VxdWVuY2Ugb2Ygbm9kZSBuYW1lcyB0byBuYXZpZ2F0ZSB0byBuZXh0XG4gICAgICAgICAqICAgLSB7QGxpbmsgU2VuZH0gb2JqZWN0ICh0byBleGVjdXRlIGEgbm9kZSB3aXRoIHRoZSBleGFjdCBpbnB1dCBwcm92aWRlZCBpbiB0aGUge0BsaW5rIFNlbmR9IG9iamVjdClcbiAgICAgICAgICogICAtIHNlcXVlbmNlIG9mIHtAbGluayBTZW5kfSBvYmplY3RzXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnb3RvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN1bWUgPSBhcmdzLnJlc3VtZTtcbiAgICAgICAgdGhpcy5ncmFwaCA9IGFyZ3MuZ3JhcGg7XG4gICAgICAgIHRoaXMudXBkYXRlID0gYXJncy51cGRhdGU7XG4gICAgICAgIGlmIChhcmdzLmdvdG8pIHtcbiAgICAgICAgICAgIHRoaXMuZ290byA9IEFycmF5LmlzQXJyYXkoYXJncy5nb3RvKVxuICAgICAgICAgICAgICAgID8gX2Rlc2VyaWFsaXplQ29tbWFuZFNlbmRPYmplY3RHcmFwaChhcmdzLmdvdG8pXG4gICAgICAgICAgICAgICAgOiBbX2Rlc2VyaWFsaXplQ29tbWFuZFNlbmRPYmplY3RHcmFwaChhcmdzLmdvdG8pXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSB1cGRhdGUgZmllbGQgdG8gYSBsaXN0IG9mIHtAbGluayBQZW5kaW5nV3JpdGV9IHR1cGxlc1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Yge0BsaW5rIFBlbmRpbmdXcml0ZX0gdHVwbGVzIG9mIHRoZSBmb3JtIGBbY2hhbm5lbEtleSwgdmFsdWVdYC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdXBkYXRlQXNUdXBsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMudXBkYXRlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0aGlzLnVwZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVwZGF0ZSkgJiZcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmV2ZXJ5KCh0KSA9PiBBcnJheS5pc0FycmF5KHQpICYmIHQubGVuZ3RoID09PSAyICYmIHR5cGVvZiB0WzBdID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtbXCJfX3Jvb3RfX1wiLCB0aGlzLnVwZGF0ZV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWRHb3RvO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ290byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2VyaWFsaXplZEdvdG8gPSB0aGlzLmdvdG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzU2VuZCh0aGlzLmdvdG8pKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkR290byA9IHRoaXMuZ290by50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRHb3RvID0gdGhpcy5nb3RvPy5tYXAoKGlubmVyR290bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5uZXJHb3RvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckdvdG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJHb3RvLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZ19uYW1lOiB0aGlzLmxnX25hbWUsXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMudXBkYXRlLFxuICAgICAgICAgICAgcmVzdW1lOiB0aGlzLnJlc3VtZSxcbiAgICAgICAgICAgIGdvdG86IHNlcmlhbGl6ZWRHb3RvLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tYW5kLCBcIlBBUkVOVFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IFwiX19wYXJlbnRfX1wiXG59KTtcbi8qKlxuICogQSB0eXBlIGd1YXJkIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDb21tYW5kfS5cbiAqXG4gKiBVc2VmdWwgZm9yIHR5cGUgbmFycm93aW5nIHdoZW4gd29ya2luZyB3aXRoIHRoZSB7QGxpbmsgQ29tbWFuZH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB4IC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDb21tYW5kfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW1hbmQoeCkge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcImxnX25hbWVcIiBpbiB4ICYmIHgubGdfbmFtZSA9PT0gXCJDb21tYW5kXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmVjb25zdHJ1Y3RzIENvbW1hbmQgYW5kIFNlbmQgb2JqZWN0cyBmcm9tIGEgZGVlcGx5IG5lc3RlZCB0cmVlIG9mIGFub255bW91cyBvYmplY3RzXG4gKiBtYXRjaGluZyB0aGVpciBpbnRlcmZhY2VzLlxuICpcbiAqIFRoaXMgaXMgb25seSBleHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gSXQgaXMgTk9UIGludGVuZGVkIHRvIGJlIHVzZWQgb3V0c2lkZSBvZlxuICogdGhlIENvbW1hbmQgYW5kIFNlbmQgY2xhc3Nlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcGFyYW0geCAtIFRoZSBjb21tYW5kIHNlbmQgdHJlZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHNlZW4gLSBBIG1hcCBvZiBzZWVuIG9iamVjdHMgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGNvbW1hbmQgc2VuZCB0cmVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2VyaWFsaXplQ29tbWFuZFNlbmRPYmplY3RHcmFwaCh4LCBzZWVuID0gbmV3IE1hcCgpKSB7XG4gICAgaWYgKHggIT09IHVuZGVmaW5lZCAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgb2JqZWN0LCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIHZlcnNpb25cbiAgICAgICAgaWYgKHNlZW4uaGFzKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vlbi5nZXQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYXJyYXkgZmlyc3QsIHRoZW4gcG9wdWxhdGUgaXRcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHNlZW4gbWFwIGJlZm9yZSBwcm9jZXNzaW5nIGVsZW1lbnRzIHRvIGhhbmRsZSBzZWxmLXJlZmVyZW5jZXNcbiAgICAgICAgICAgIHNlZW4uc2V0KHgsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBOb3cgcG9wdWxhdGUgdGhlIGFycmF5XG4gICAgICAgICAgICB4LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IF9kZXNlcmlhbGl6ZUNvbW1hbmRTZW5kT2JqZWN0R3JhcGgoaXRlbSwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbW1hbmQoeCkgJiYgISh4IGluc3RhbmNlb2YgQ29tbWFuZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21tYW5kKHgpO1xuICAgICAgICAgICAgc2Vlbi5zZXQoeCwgcmVzdWx0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNTZW5kSW50ZXJmYWNlKHgpICYmICEoeCBpbnN0YW5jZW9mIFNlbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgU2VuZCh4Lm5vZGUsIHguYXJncyk7XG4gICAgICAgICAgICBzZWVuLnNldCh4LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29tbWFuZCh4KSB8fCBfaXNTZW5kKHgpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB4O1xuICAgICAgICAgICAgc2Vlbi5zZXQoeCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImxjX3NlcmlhbGl6YWJsZVwiIGluIHggJiYgeC5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHg7XG4gICAgICAgICAgICBzZWVuLnNldCh4LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IG9iamVjdCBmaXJzdFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAvLyBBZGQgdG8gc2VlbiBtYXAgYmVmb3JlIHByb2Nlc3NpbmcgcHJvcGVydGllcyB0byBoYW5kbGUgc2VsZi1yZWZlcmVuY2VzXG4gICAgICAgICAgICBzZWVuLnNldCh4LCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gTm93IHBvcHVsYXRlIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPVxuICAgICAgICAgICAgICAgICAgICBfZGVzZXJpYWxpemVDb21tYW5kU2VuZE9iamVjdEdyYXBoKHZhbHVlLCBzZWVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLangGraphError: () => (/* binding */ BaseLangGraphError),\n/* harmony export */   EmptyChannelError: () => (/* binding */ EmptyChannelError),\n/* harmony export */   EmptyInputError: () => (/* binding */ EmptyInputError),\n/* harmony export */   GraphBubbleUp: () => (/* binding */ GraphBubbleUp),\n/* harmony export */   GraphInterrupt: () => (/* binding */ GraphInterrupt),\n/* harmony export */   GraphRecursionError: () => (/* binding */ GraphRecursionError),\n/* harmony export */   GraphValueError: () => (/* binding */ GraphValueError),\n/* harmony export */   InvalidUpdateError: () => (/* binding */ InvalidUpdateError),\n/* harmony export */   MultipleSubgraphsError: () => (/* binding */ MultipleSubgraphsError),\n/* harmony export */   NodeInterrupt: () => (/* binding */ NodeInterrupt),\n/* harmony export */   ParentCommand: () => (/* binding */ ParentCommand),\n/* harmony export */   RemoteException: () => (/* binding */ RemoteException),\n/* harmony export */   UnreachableNodeError: () => (/* binding */ UnreachableNodeError),\n/* harmony export */   getSubgraphsSeenSet: () => (/* binding */ getSubgraphsSeenSet),\n/* harmony export */   isGraphBubbleUp: () => (/* binding */ isGraphBubbleUp),\n/* harmony export */   isGraphInterrupt: () => (/* binding */ isGraphInterrupt),\n/* harmony export */   isParentCommand: () => (/* binding */ isParentCommand)\n/* harmony export */ });\n// TODO: Merge with base LangChain error class when we drop support for core@0.2.0\nclass BaseLangGraphError extends Error {\n    constructor(message, fields) {\n        let finalMessage = message ?? \"\";\n        if (fields?.lc_error_code) {\n            finalMessage = `${finalMessage}\\n\\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${fields.lc_error_code}/\\n`;\n        }\n        super(finalMessage);\n        Object.defineProperty(this, \"lc_error_code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lc_error_code = fields?.lc_error_code;\n    }\n}\nclass GraphBubbleUp extends BaseLangGraphError {\n    get is_bubble_up() {\n        return true;\n    }\n}\nclass GraphRecursionError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"GraphRecursionError\";\n    }\n    static get unminifiable_name() {\n        return \"GraphRecursionError\";\n    }\n}\nclass GraphValueError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"GraphValueError\";\n    }\n    static get unminifiable_name() {\n        return \"GraphValueError\";\n    }\n}\nclass GraphInterrupt extends GraphBubbleUp {\n    constructor(interrupts, fields) {\n        super(JSON.stringify(interrupts, null, 2), fields);\n        Object.defineProperty(this, \"interrupts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"GraphInterrupt\";\n        this.interrupts = interrupts ?? [];\n    }\n    static get unminifiable_name() {\n        return \"GraphInterrupt\";\n    }\n}\n/** Raised by a node to interrupt execution. */\nclass NodeInterrupt extends GraphInterrupt {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(message, fields) {\n        super([\n            {\n                value: message,\n                when: \"during\",\n            },\n        ], fields);\n        this.name = \"NodeInterrupt\";\n    }\n    static get unminifiable_name() {\n        return \"NodeInterrupt\";\n    }\n}\nclass ParentCommand extends GraphBubbleUp {\n    constructor(command) {\n        super();\n        Object.defineProperty(this, \"command\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"ParentCommand\";\n        this.command = command;\n    }\n    static get unminifiable_name() {\n        return \"ParentCommand\";\n    }\n}\nfunction isParentCommand(e) {\n    return (e !== undefined &&\n        e.name === ParentCommand.unminifiable_name);\n}\nfunction isGraphBubbleUp(e) {\n    return e !== undefined && e.is_bubble_up === true;\n}\nfunction isGraphInterrupt(e) {\n    return (e !== undefined &&\n        [\n            GraphInterrupt.unminifiable_name,\n            NodeInterrupt.unminifiable_name,\n        ].includes(e.name));\n}\nclass EmptyInputError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"EmptyInputError\";\n    }\n    static get unminifiable_name() {\n        return \"EmptyInputError\";\n    }\n}\nclass EmptyChannelError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"EmptyChannelError\";\n    }\n    static get unminifiable_name() {\n        return \"EmptyChannelError\";\n    }\n}\nclass InvalidUpdateError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"InvalidUpdateError\";\n    }\n    static get unminifiable_name() {\n        return \"InvalidUpdateError\";\n    }\n}\n/**\n * @deprecated This exception type is no longer thrown.\n */\nclass MultipleSubgraphsError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"MultipleSubgraphError\";\n    }\n    static get unminifiable_name() {\n        return \"MultipleSubgraphError\";\n    }\n}\nclass UnreachableNodeError extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"UnreachableNodeError\";\n    }\n    static get unminifiable_name() {\n        return \"UnreachableNodeError\";\n    }\n}\n/**\n * Exception raised when an error occurs in the remote graph.\n */\nclass RemoteException extends BaseLangGraphError {\n    constructor(message, fields) {\n        super(message, fields);\n        this.name = \"RemoteException\";\n    }\n    static get unminifiable_name() {\n        return \"RemoteException\";\n    }\n}\n/**\n * Used for subgraph detection.\n */\nconst getSubgraphsSeenSet = () => {\n    if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] = new Set();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return globalThis[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")];\n};\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxnRkFBZ0YscUJBQXFCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBNZXJnZSB3aXRoIGJhc2UgTGFuZ0NoYWluIGVycm9yIGNsYXNzIHdoZW4gd2UgZHJvcCBzdXBwb3J0IGZvciBjb3JlQDAuMi4wXG5leHBvcnQgY2xhc3MgQmFzZUxhbmdHcmFwaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcykge1xuICAgICAgICBsZXQgZmluYWxNZXNzYWdlID0gbWVzc2FnZSA/PyBcIlwiO1xuICAgICAgICBpZiAoZmllbGRzPy5sY19lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICBmaW5hbE1lc3NhZ2UgPSBgJHtmaW5hbE1lc3NhZ2V9XFxuXFxuVHJvdWJsZXNob290aW5nIFVSTDogaHR0cHM6Ly9qcy5sYW5nY2hhaW4uY29tL2RvY3MvdHJvdWJsZXNob290aW5nL2Vycm9ycy8ke2ZpZWxkcy5sY19lcnJvcl9jb2RlfS9cXG5gO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpbmFsTWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2Vycm9yX2NvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sY19lcnJvcl9jb2RlID0gZmllbGRzPy5sY19lcnJvcl9jb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHcmFwaEJ1YmJsZVVwIGV4dGVuZHMgQmFzZUxhbmdHcmFwaEVycm9yIHtcbiAgICBnZXQgaXNfYnViYmxlX3VwKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGhSZWN1cnNpb25FcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhSZWN1cnNpb25FcnJvclwiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHVubWluaWZpYWJsZV9uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHcmFwaFJlY3Vyc2lvbkVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdyYXBoVmFsdWVFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiR3JhcGhWYWx1ZUVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoVmFsdWVFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHcmFwaEludGVycnVwdCBleHRlbmRzIEdyYXBoQnViYmxlVXAge1xuICAgIGNvbnN0cnVjdG9yKGludGVycnVwdHMsIGZpZWxkcykge1xuICAgICAgICBzdXBlcihKU09OLnN0cmluZ2lmeShpbnRlcnJ1cHRzLCBudWxsLCAyKSwgZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJydXB0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkdyYXBoSW50ZXJydXB0XCI7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0cyA9IGludGVycnVwdHMgPz8gW107XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkdyYXBoSW50ZXJydXB0XCI7XG4gICAgfVxufVxuLyoqIFJhaXNlZCBieSBhIG5vZGUgdG8gaW50ZXJydXB0IGV4ZWN1dGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlSW50ZXJydXB0IGV4dGVuZHMgR3JhcGhJbnRlcnJ1cHQge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB3aGVuOiBcImR1cmluZ1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb2RlSW50ZXJydXB0XCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk5vZGVJbnRlcnJ1cHRcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGFyZW50Q29tbWFuZCBleHRlbmRzIEdyYXBoQnViYmxlVXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tbWFuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlBhcmVudENvbW1hbmRcIjtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUGFyZW50Q29tbWFuZFwiO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmVudENvbW1hbmQoZSkge1xuICAgIHJldHVybiAoZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGUubmFtZSA9PT0gUGFyZW50Q29tbWFuZC51bm1pbmlmaWFibGVfbmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHcmFwaEJ1YmJsZVVwKGUpIHtcbiAgICByZXR1cm4gZSAhPT0gdW5kZWZpbmVkICYmIGUuaXNfYnViYmxlX3VwID09PSB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzR3JhcGhJbnRlcnJ1cHQoZSkge1xuICAgIHJldHVybiAoZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIFtcbiAgICAgICAgICAgIEdyYXBoSW50ZXJydXB0LnVubWluaWZpYWJsZV9uYW1lLFxuICAgICAgICAgICAgTm9kZUludGVycnVwdC51bm1pbmlmaWFibGVfbmFtZSxcbiAgICAgICAgXS5pbmNsdWRlcyhlLm5hbWUpKTtcbn1cbmV4cG9ydCBjbGFzcyBFbXB0eUlucHV0RXJyb3IgZXh0ZW5kcyBCYXNlTGFuZ0dyYXBoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBmaWVsZHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVtcHR5SW5wdXRFcnJvclwiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHVubWluaWZpYWJsZV9uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJFbXB0eUlucHV0RXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRW1wdHlDaGFubmVsRXJyb3IgZXh0ZW5kcyBCYXNlTGFuZ0dyYXBoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBmaWVsZHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVtcHR5Q2hhbm5lbEVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkVtcHR5Q2hhbm5lbEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRVcGRhdGVFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZFVwZGF0ZUVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWRVcGRhdGVFcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBleGNlcHRpb24gdHlwZSBpcyBubyBsb25nZXIgdGhyb3duLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwbGVTdWJncmFwaHNFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTXVsdGlwbGVTdWJncmFwaEVycm9yXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk11bHRpcGxlU3ViZ3JhcGhFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnJlYWNoYWJsZU5vZGVFcnJvciBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiVW5yZWFjaGFibGVOb2RlRXJyb3JcIjtcbiAgICB9XG4gICAgc3RhdGljIGdldCB1bm1pbmlmaWFibGVfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5yZWFjaGFibGVOb2RlRXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIHJlbW90ZSBncmFwaC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbW90ZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VMYW5nR3JhcGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVtb3RlRXhjZXB0aW9uXCI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdW5taW5pZmlhYmxlX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJlbW90ZUV4Y2VwdGlvblwiO1xuICAgIH1cbn1cbi8qKlxuICogVXNlZCBmb3Igc3ViZ3JhcGggZGV0ZWN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgZ2V0U3ViZ3JhcGhzU2VlblNldCA9ICgpID0+IHtcbiAgICBpZiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnbG9iYWxUaGlzW1N5bWJvbC5mb3IoXCJMR19DSEVDS1BPSU5UX1NFRU5fTlNfU0VUXCIpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGdsb2JhbFRoaXNbU3ltYm9sLmZvcihcIkxHX0NIRUNLUE9JTlRfU0VFTl9OU19TRVRcIildID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBnbG9iYWxUaGlzW1N5bWJvbC5mb3IoXCJMR19DSEVDS1BPSU5UX1NFRU5fTlNfU0VUXCIpXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/func/index.js":
/*!**********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/func/index.js ***!
  \**********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entrypoint: () => (/* binding */ entrypoint),\n/* harmony export */   getPreviousState: () => (/* binding */ getPreviousState),\n/* harmony export */   task: () => (/* binding */ task)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _pregel_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pregel/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/index.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pregel/read.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _pregel_call_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pregel/call.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/call.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../channels/last_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pregel/write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Define a LangGraph task using the `task` function.\n *\n * Tasks can only be called from within an {@link entrypoint} or from within a StateGraph.\n * A task can be called like a regular function with the following differences:\n *\n * - When a checkpointer is enabled, the function inputs and outputs must be serializable.\n * - The wrapped function can only be called from within an entrypoint or StateGraph.\n * - Calling the function produces a promise. This makes it easy to parallelize tasks.\n *\n * @typeParam ArgsT - The type of arguments the task function accepts\n * @typeParam OutputT - The type of value the task function returns\n * @param optionsOrName - Either an {@link TaskOptions} object, or a string for the name of the task\n * @param func - The function that executes this task\n * @returns A proxy function that accepts the same arguments as the original and always returns the result as a Promise\n *\n * @example basic example\n * ```typescript\n * const addOne = task(\"add\", async (a: number) => a + 1);\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n *\n * // Call the entrypoint\n * await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @example using a retry policy\n * ```typescript\n * const addOne = task({\n *     name: \"add\",\n *     retry: { maxAttempts: 3 }\n *   },\n *   async (a: number) => a + 1\n * );\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n * ```\n */\nfunction task(optionsOrName, func) {\n    const { name, retry } = typeof optionsOrName === \"string\"\n        ? { name: optionsOrName, retry: undefined }\n        : optionsOrName;\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isAsyncGeneratorFunction)(func) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isGeneratorFunction)(func)) {\n        throw new Error(\"Generators are disallowed as tasks. For streaming responses, use config.write.\");\n    }\n    return (...args) => {\n        return (0,_pregel_call_js__WEBPACK_IMPORTED_MODULE_5__.call)({ func, name, retry }, ...args);\n    };\n}\n/**\n * Define a LangGraph workflow using the `entrypoint` function.\n *\n * ### Function signature\n *\n * The wrapped function must accept at most **two parameters**. The first parameter\n * is the input to the function. The second (optional) parameter is a\n * {@link LangGraphRunnableConfig} object. If you wish to pass multiple parameters to\n * the function, you can pass them as an object.\n *\n * ### Helper functions\n *\n * #### Streaming\n * To write data to the \"custom\" stream, use the {@link getWriter} function, or the\n * {@link LangGraphRunnableConfig.writer} property.\n *\n * #### State management\n * The {@link getPreviousState} function can be used to access the previous state\n * that was returned from the last invocation of the entrypoint on the same thread id.\n *\n * If you wish to save state other than the return value, you can use the\n * {@link entrypoint.final} function.\n *\n * @typeParam InputT - The type of input the entrypoint accepts\n * @typeParam OutputT - The type of output the entrypoint produces\n * @param optionsOrName - Either an {@link EntrypointOptions} object, or a string for the name of the entrypoint\n * @param func - The function that executes this entrypoint\n * @returns A {@link Pregel} instance that can be run to execute the workflow\n *\n * @example Using entrypoint and tasks\n * ```typescript\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n * import { interrupt, Command } from \"@langchain/langgraph\";\n *\n * const composeEssay = task(\"compose\", async (topic: string) => {\n *   await new Promise(r => setTimeout(r, 1000)); // Simulate slow operation\n *   return `An essay about ${topic}`;\n * });\n *\n * const reviewWorkflow = entrypoint({\n *   name: \"review\",\n *   checkpointer: new MemorySaver()\n * }, async (topic: string) => {\n *   const essay = await composeEssay(topic);\n *   const humanReview = await interrupt({\n *     question: \"Please provide a review\",\n *     essay\n *   });\n *   return {\n *     essay,\n *     review: humanReview\n *   };\n * });\n *\n * // Example configuration for the workflow\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * // Topic for the essay\n * const topic = \"cats\";\n *\n * // Stream the workflow to generate the essay and await human review\n * for await (const result of reviewWorkflow.stream(topic, config)) {\n *   console.log(result);\n * }\n *\n * // Example human review provided after the interrupt\n * const humanReview = \"This essay is great.\";\n *\n * // Resume the workflow with the provided human review\n * for await (const result of reviewWorkflow.stream(new Command({ resume: humanReview }), config)) {\n *   console.log(result);\n * }\n * ```\n *\n * @example Accessing the previous return value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const accumulator = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (input: string) => {\n *   const previous = getPreviousState<number>();\n *   return previous !== undefined ? `${previous } ${input}` : input;\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n * await accumulator.invoke(\"hello\", config); // returns \"hello\"\n * await accumulator.invoke(\"world\", config); // returns \"hello world\"\n * ```\n *\n * @example Using entrypoint.final to save a value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const myWorkflow = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (num: number) => {\n *   const previous = getPreviousState<number>();\n *\n *   // This will return the previous value to the caller, saving\n *   // 2 * num to the checkpoint, which will be used in the next invocation\n *   // for the `previous` parameter.\n *   return entrypoint.final({\n *     value: previous ?? 0,\n *     save: 2 * num\n *   });\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * await myWorkflow.invoke(3, config); // 0 (previous was undefined)\n * await myWorkflow.invoke(1, config); // 6 (previous was 3 * 2 from the previous invocation)\n * ```\n */\nconst entrypoint = function entrypoint(optionsOrName, func) {\n    const { name, checkpointer, store } = typeof optionsOrName === \"string\"\n        ? { name: optionsOrName, checkpointer: undefined, store: undefined }\n        : optionsOrName;\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isAsyncGeneratorFunction)(func) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isGeneratorFunction)(func)) {\n        throw new Error(\"Generators are disallowed as entrypoints. For streaming responses, use config.write.\");\n    }\n    const streamMode = \"updates\";\n    const bound = (0,_pregel_call_js__WEBPACK_IMPORTED_MODULE_5__.getRunnableForEntrypoint)(name, func);\n    // Helper to check if a value is an EntrypointFinal\n    function isEntrypointFinal(value) {\n        return (typeof value === \"object\" &&\n            value !== null &&\n            \"__lg_type\" in value &&\n            value.__lg_type === \"__pregel_final\");\n    }\n    // Helper function to pluck the return value from EntrypointFinal or passthrough\n    const pluckReturnValue = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        name: \"pluckReturnValue\",\n        func: (value) => {\n            return isEntrypointFinal(value) ? value.value : value;\n        },\n    });\n    // Helper function to pluck the save value from EntrypointFinal or passthrough\n    const pluckSaveValue = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        name: \"pluckSaveValue\",\n        func: (value) => {\n            return isEntrypointFinal(value) ? value.save : value;\n        },\n    });\n    const entrypointNode = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__.PregelNode({\n        bound,\n        triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START],\n        channels: [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START],\n        writers: [\n            new _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.ChannelWrite([\n                { channel: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.PASSTHROUGH, mapper: pluckReturnValue },\n                { channel: _constants_js__WEBPACK_IMPORTED_MODULE_3__.PREVIOUS, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_8__.PASSTHROUGH, mapper: pluckSaveValue },\n            ], [_constants_js__WEBPACK_IMPORTED_MODULE_3__.TAG_HIDDEN]),\n        ],\n    });\n    return new _pregel_index_js__WEBPACK_IMPORTED_MODULE_1__.Pregel({\n        name,\n        checkpointer,\n        nodes: {\n            [name]: entrypointNode,\n        },\n        channels: {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.END]: new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__.LastValue(),\n            [_constants_js__WEBPACK_IMPORTED_MODULE_3__.PREVIOUS]: new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_6__.LastValue(),\n        },\n        inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.START,\n        outputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END,\n        streamChannels: _constants_js__WEBPACK_IMPORTED_MODULE_3__.END,\n        streamMode,\n        store,\n    });\n};\n// documented by the EntrypointFunction interface\nentrypoint.final = function final({ value, save, }) {\n    return { value, save, __lg_type: \"__pregel_final\" };\n};\n/**\n * A helper utility function for use with the functional API that returns the previous\n * state from the checkpoint from the last invocation of the current thread.\n *\n * This function allows workflows to access state that was saved in previous runs\n * using {@link entrypoint.final}.\n *\n * @typeParam StateT - The type of the state that was previously saved\n * @returns The previous saved state from the last invocation of the current thread\n *\n * @example\n * ```typescript\n * const previousState = getPreviousState<{ counter: number }>();\n * const newCount = (previousState?.counter ?? 0) + 1;\n * ```\n */\nfunction getPreviousState() {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    return config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_3__.CONFIG_KEY_PREVIOUS_STATE];\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2Z1bmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQ3BDO0FBQ0c7QUFDZ0Q7QUFDL0I7QUFDRztBQUNiO0FBQ3lDO0FBQ2hDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1AsWUFBWSxjQUFjO0FBQzFCLFlBQVk7QUFDWjtBQUNBLFFBQVEsbUVBQXdCLFVBQVUsOERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUksR0FBRyxtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQkFBaUI7QUFDbkUsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxjQUFjO0FBQzFCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsOEJBQThCLE1BQU07QUFDcEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHdDQUF3QyxXQUFXLEVBQUUsTUFBTTtBQUMzRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNPO0FBQ1AsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWTtBQUNaO0FBQ0EsUUFBUSxtRUFBd0IsVUFBVSw4REFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0JBQStCLHVEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLCtCQUErQix1REFBVTtBQUN6QztBQUNBLG1CQUFtQixnREFBSztBQUN4QixtQkFBbUIsZ0RBQUs7QUFDeEI7QUFDQSxnQkFBZ0IsMERBQVk7QUFDNUIsa0JBQWtCLFNBQVMsOENBQUcsU0FBUyx5REFBVyw0QkFBNEI7QUFDOUUsa0JBQWtCLFNBQVMsbURBQVEsU0FBUyx5REFBVywwQkFBMEI7QUFDakYsZ0JBQWdCLHFEQUFVO0FBQzFCO0FBQ0EsS0FBSztBQUNMLGVBQWUsb0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLGdEQUFLLE9BQU8sd0VBQWM7QUFDdkMsYUFBYSw4Q0FBRyxPQUFPLDhEQUFTO0FBQ2hDLGFBQWEsbURBQVEsT0FBTyw4REFBUztBQUNyQyxTQUFTO0FBQ1QsdUJBQXVCLGdEQUFLO0FBQzVCLHdCQUF3Qiw4Q0FBRztBQUMzQix3QkFBd0IsOENBQUc7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsMEZBQWtDO0FBQ3JELGlDQUFpQyxvRUFBeUI7QUFDMUQ7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2Z1bmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvc2luZ2xldG9uc1wiO1xuaW1wb3J0IHsgUHJlZ2VsIH0gZnJvbSBcIi4uL3ByZWdlbC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUHJlZ2VsTm9kZSB9IGZyb20gXCIuLi9wcmVnZWwvcmVhZC5qc1wiO1xuaW1wb3J0IHsgQ09ORklHX0tFWV9QUkVWSU9VU19TVEFURSwgRU5ELCBQUkVWSU9VUywgU1RBUlQsIFRBR19ISURERU4sIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgRXBoZW1lcmFsVmFsdWUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvZXBoZW1lcmFsX3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyBjYWxsLCBnZXRSdW5uYWJsZUZvckVudHJ5cG9pbnQgfSBmcm9tIFwiLi4vcHJlZ2VsL2NhbGwuanNcIjtcbmltcG9ydCB7IExhc3RWYWx1ZSB9IGZyb20gXCIuLi9jaGFubmVscy9sYXN0X3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZUNhbGxhYmxlLCBpc0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24sIGlzR2VuZXJhdG9yRnVuY3Rpb24sIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBDaGFubmVsV3JpdGUsIFBBU1NUSFJPVUdIIH0gZnJvbSBcIi4uL3ByZWdlbC93cml0ZS5qc1wiO1xuLyoqXG4gKiBEZWZpbmUgYSBMYW5nR3JhcGggdGFzayB1c2luZyB0aGUgYHRhc2tgIGZ1bmN0aW9uLlxuICpcbiAqIFRhc2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhbiB7QGxpbmsgZW50cnlwb2ludH0gb3IgZnJvbSB3aXRoaW4gYSBTdGF0ZUdyYXBoLlxuICogQSB0YXNrIGNhbiBiZSBjYWxsZWQgbGlrZSBhIHJlZ3VsYXIgZnVuY3Rpb24gd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICpcbiAqIC0gV2hlbiBhIGNoZWNrcG9pbnRlciBpcyBlbmFibGVkLCB0aGUgZnVuY3Rpb24gaW5wdXRzIGFuZCBvdXRwdXRzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICogLSBUaGUgd3JhcHBlZCBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYW4gZW50cnlwb2ludCBvciBTdGF0ZUdyYXBoLlxuICogLSBDYWxsaW5nIHRoZSBmdW5jdGlvbiBwcm9kdWNlcyBhIHByb21pc2UuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwYXJhbGxlbGl6ZSB0YXNrcy5cbiAqXG4gKiBAdHlwZVBhcmFtIEFyZ3NUIC0gVGhlIHR5cGUgb2YgYXJndW1lbnRzIHRoZSB0YXNrIGZ1bmN0aW9uIGFjY2VwdHNcbiAqIEB0eXBlUGFyYW0gT3V0cHV0VCAtIFRoZSB0eXBlIG9mIHZhbHVlIHRoZSB0YXNrIGZ1bmN0aW9uIHJldHVybnNcbiAqIEBwYXJhbSBvcHRpb25zT3JOYW1lIC0gRWl0aGVyIGFuIHtAbGluayBUYXNrT3B0aW9uc30gb2JqZWN0LCBvciBhIHN0cmluZyBmb3IgdGhlIG5hbWUgb2YgdGhlIHRhc2tcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgdGhpcyB0YXNrXG4gKiBAcmV0dXJucyBBIHByb3h5IGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG9yaWdpbmFsIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgUHJvbWlzZVxuICpcbiAqIEBleGFtcGxlIGJhc2ljIGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGFkZE9uZSA9IHRhc2soXCJhZGRcIiwgYXN5bmMgKGE6IG51bWJlcikgPT4gYSArIDEpO1xuICpcbiAqIGNvbnN0IHdvcmtmbG93ID0gZW50cnlwb2ludChcImV4YW1wbGVcIiwgYXN5bmMgKG51bWJlcnM6IG51bWJlcltdKSA9PiB7XG4gKiAgIGNvbnN0IHByb21pc2VzID0gbnVtYmVycy5tYXAobiA9PiBhZGRPbmUobikpO1xuICogICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICogICByZXR1cm4gcmVzdWx0cztcbiAqIH0pO1xuICpcbiAqIC8vIENhbGwgdGhlIGVudHJ5cG9pbnRcbiAqIGF3YWl0IHdvcmtmbG93Lmludm9rZShbMSwgMiwgM10pOyAvLyBSZXR1cm5zIFsyLCAzLCA0XVxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgdXNpbmcgYSByZXRyeSBwb2xpY3lcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGFkZE9uZSA9IHRhc2soe1xuICogICAgIG5hbWU6IFwiYWRkXCIsXG4gKiAgICAgcmV0cnk6IHsgbWF4QXR0ZW1wdHM6IDMgfVxuICogICB9LFxuICogICBhc3luYyAoYTogbnVtYmVyKSA9PiBhICsgMVxuICogKTtcbiAqXG4gKiBjb25zdCB3b3JrZmxvdyA9IGVudHJ5cG9pbnQoXCJleGFtcGxlXCIsIGFzeW5jIChudW1iZXJzOiBudW1iZXJbXSkgPT4ge1xuICogICBjb25zdCBwcm9taXNlcyA9IG51bWJlcnMubWFwKG4gPT4gYWRkT25lKG4pKTtcbiAqICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAqICAgcmV0dXJuIHJlc3VsdHM7XG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFzayhvcHRpb25zT3JOYW1lLCBmdW5jKSB7XG4gICAgY29uc3QgeyBuYW1lLCByZXRyeSB9ID0gdHlwZW9mIG9wdGlvbnNPck5hbWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyB7IG5hbWU6IG9wdGlvbnNPck5hbWUsIHJldHJ5OiB1bmRlZmluZWQgfVxuICAgICAgICA6IG9wdGlvbnNPck5hbWU7XG4gICAgaWYgKGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbihmdW5jKSB8fCBpc0dlbmVyYXRvckZ1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvcnMgYXJlIGRpc2FsbG93ZWQgYXMgdGFza3MuIEZvciBzdHJlYW1pbmcgcmVzcG9uc2VzLCB1c2UgY29uZmlnLndyaXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsKHsgZnVuYywgbmFtZSwgcmV0cnkgfSwgLi4uYXJncyk7XG4gICAgfTtcbn1cbi8qKlxuICogRGVmaW5lIGEgTGFuZ0dyYXBoIHdvcmtmbG93IHVzaW5nIHRoZSBgZW50cnlwb2ludGAgZnVuY3Rpb24uXG4gKlxuICogIyMjIEZ1bmN0aW9uIHNpZ25hdHVyZVxuICpcbiAqIFRoZSB3cmFwcGVkIGZ1bmN0aW9uIG11c3QgYWNjZXB0IGF0IG1vc3QgKip0d28gcGFyYW1ldGVycyoqLiBUaGUgZmlyc3QgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaW5wdXQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgc2Vjb25kIChvcHRpb25hbCkgcGFyYW1ldGVyIGlzIGFcbiAqIHtAbGluayBMYW5nR3JhcGhSdW5uYWJsZUNvbmZpZ30gb2JqZWN0LiBJZiB5b3Ugd2lzaCB0byBwYXNzIG11bHRpcGxlIHBhcmFtZXRlcnMgdG9cbiAqIHRoZSBmdW5jdGlvbiwgeW91IGNhbiBwYXNzIHRoZW0gYXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIyBIZWxwZXIgZnVuY3Rpb25zXG4gKlxuICogIyMjIyBTdHJlYW1pbmdcbiAqIFRvIHdyaXRlIGRhdGEgdG8gdGhlIFwiY3VzdG9tXCIgc3RyZWFtLCB1c2UgdGhlIHtAbGluayBnZXRXcml0ZXJ9IGZ1bmN0aW9uLCBvciB0aGVcbiAqIHtAbGluayBMYW5nR3JhcGhSdW5uYWJsZUNvbmZpZy53cml0ZXJ9IHByb3BlcnR5LlxuICpcbiAqICMjIyMgU3RhdGUgbWFuYWdlbWVudFxuICogVGhlIHtAbGluayBnZXRQcmV2aW91c1N0YXRlfSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlIHByZXZpb3VzIHN0YXRlXG4gKiB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHRoZSBsYXN0IGludm9jYXRpb24gb2YgdGhlIGVudHJ5cG9pbnQgb24gdGhlIHNhbWUgdGhyZWFkIGlkLlxuICpcbiAqIElmIHlvdSB3aXNoIHRvIHNhdmUgc3RhdGUgb3RoZXIgdGhhbiB0aGUgcmV0dXJuIHZhbHVlLCB5b3UgY2FuIHVzZSB0aGVcbiAqIHtAbGluayBlbnRyeXBvaW50LmZpbmFsfSBmdW5jdGlvbi5cbiAqXG4gKiBAdHlwZVBhcmFtIElucHV0VCAtIFRoZSB0eXBlIG9mIGlucHV0IHRoZSBlbnRyeXBvaW50IGFjY2VwdHNcbiAqIEB0eXBlUGFyYW0gT3V0cHV0VCAtIFRoZSB0eXBlIG9mIG91dHB1dCB0aGUgZW50cnlwb2ludCBwcm9kdWNlc1xuICogQHBhcmFtIG9wdGlvbnNPck5hbWUgLSBFaXRoZXIgYW4ge0BsaW5rIEVudHJ5cG9pbnRPcHRpb25zfSBvYmplY3QsIG9yIGEgc3RyaW5nIGZvciB0aGUgbmFtZSBvZiB0aGUgZW50cnlwb2ludFxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB0aGlzIGVudHJ5cG9pbnRcbiAqIEByZXR1cm5zIEEge0BsaW5rIFByZWdlbH0gaW5zdGFuY2UgdGhhdCBjYW4gYmUgcnVuIHRvIGV4ZWN1dGUgdGhlIHdvcmtmbG93XG4gKlxuICogQGV4YW1wbGUgVXNpbmcgZW50cnlwb2ludCBhbmQgdGFza3NcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHRhc2ssIGVudHJ5cG9pbnQgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqIGltcG9ydCB7IE1lbW9yeVNhdmVyIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoLWNoZWNrcG9pbnRcIjtcbiAqIGltcG9ydCB7IGludGVycnVwdCwgQ29tbWFuZCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VFc3NheSA9IHRhc2soXCJjb21wb3NlXCIsIGFzeW5jICh0b3BpYzogc3RyaW5nKSA9PiB7XG4gKiAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAxMDAwKSk7IC8vIFNpbXVsYXRlIHNsb3cgb3BlcmF0aW9uXG4gKiAgIHJldHVybiBgQW4gZXNzYXkgYWJvdXQgJHt0b3BpY31gO1xuICogfSk7XG4gKlxuICogY29uc3QgcmV2aWV3V29ya2Zsb3cgPSBlbnRyeXBvaW50KHtcbiAqICAgbmFtZTogXCJyZXZpZXdcIixcbiAqICAgY2hlY2twb2ludGVyOiBuZXcgTWVtb3J5U2F2ZXIoKVxuICogfSwgYXN5bmMgKHRvcGljOiBzdHJpbmcpID0+IHtcbiAqICAgY29uc3QgZXNzYXkgPSBhd2FpdCBjb21wb3NlRXNzYXkodG9waWMpO1xuICogICBjb25zdCBodW1hblJldmlldyA9IGF3YWl0IGludGVycnVwdCh7XG4gKiAgICAgcXVlc3Rpb246IFwiUGxlYXNlIHByb3ZpZGUgYSByZXZpZXdcIixcbiAqICAgICBlc3NheVxuICogICB9KTtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBlc3NheSxcbiAqICAgICByZXZpZXc6IGh1bWFuUmV2aWV3XG4gKiAgIH07XG4gKiB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSB3b3JrZmxvd1xuICogY29uc3QgY29uZmlnID0ge1xuICogICBjb25maWd1cmFibGU6IHtcbiAqICAgICB0aHJlYWRfaWQ6IFwic29tZV90aHJlYWRcIlxuICogICB9XG4gKiB9O1xuICpcbiAqIC8vIFRvcGljIGZvciB0aGUgZXNzYXlcbiAqIGNvbnN0IHRvcGljID0gXCJjYXRzXCI7XG4gKlxuICogLy8gU3RyZWFtIHRoZSB3b3JrZmxvdyB0byBnZW5lcmF0ZSB0aGUgZXNzYXkgYW5kIGF3YWl0IGh1bWFuIHJldmlld1xuICogZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgcmV2aWV3V29ya2Zsb3cuc3RyZWFtKHRvcGljLCBjb25maWcpKSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKlxuICogLy8gRXhhbXBsZSBodW1hbiByZXZpZXcgcHJvdmlkZWQgYWZ0ZXIgdGhlIGludGVycnVwdFxuICogY29uc3QgaHVtYW5SZXZpZXcgPSBcIlRoaXMgZXNzYXkgaXMgZ3JlYXQuXCI7XG4gKlxuICogLy8gUmVzdW1lIHRoZSB3b3JrZmxvdyB3aXRoIHRoZSBwcm92aWRlZCBodW1hbiByZXZpZXdcbiAqIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIHJldmlld1dvcmtmbG93LnN0cmVhbShuZXcgQ29tbWFuZCh7IHJlc3VtZTogaHVtYW5SZXZpZXcgfSksIGNvbmZpZykpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIEFjY2Vzc2luZyB0aGUgcHJldmlvdXMgcmV0dXJuIHZhbHVlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnRyeXBvaW50LCBnZXRQcmV2aW91c1N0YXRlIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKiBpbXBvcnQgeyBNZW1vcnlTYXZlciB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG4gKlxuICogY29uc3QgYWNjdW11bGF0b3IgPSBlbnRyeXBvaW50KHtcbiAqICAgbmFtZTogXCJhY2N1bXVsYXRvclwiLFxuICogICBjaGVja3BvaW50ZXI6IG5ldyBNZW1vcnlTYXZlcigpXG4gKiB9LCBhc3luYyAoaW5wdXQ6IHN0cmluZykgPT4ge1xuICogICBjb25zdCBwcmV2aW91cyA9IGdldFByZXZpb3VzU3RhdGU8bnVtYmVyPigpO1xuICogICByZXR1cm4gcHJldmlvdXMgIT09IHVuZGVmaW5lZCA/IGAke3ByZXZpb3VzIH0gJHtpbnB1dH1gIDogaW5wdXQ7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb25maWcgPSB7XG4gKiAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgIHRocmVhZF9pZDogXCJzb21lX3RocmVhZFwiXG4gKiAgIH1cbiAqIH07XG4gKiBhd2FpdCBhY2N1bXVsYXRvci5pbnZva2UoXCJoZWxsb1wiLCBjb25maWcpOyAvLyByZXR1cm5zIFwiaGVsbG9cIlxuICogYXdhaXQgYWNjdW11bGF0b3IuaW52b2tlKFwid29ybGRcIiwgY29uZmlnKTsgLy8gcmV0dXJucyBcImhlbGxvIHdvcmxkXCJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIFVzaW5nIGVudHJ5cG9pbnQuZmluYWwgdG8gc2F2ZSBhIHZhbHVlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnRyeXBvaW50LCBnZXRQcmV2aW91c1N0YXRlIH0gZnJvbSBcIkBsYW5nY2hhaW4vbGFuZ2dyYXBoXCI7XG4gKiBpbXBvcnQgeyBNZW1vcnlTYXZlciB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaC1jaGVja3BvaW50XCI7XG4gKlxuICogY29uc3QgbXlXb3JrZmxvdyA9IGVudHJ5cG9pbnQoe1xuICogICBuYW1lOiBcImFjY3VtdWxhdG9yXCIsXG4gKiAgIGNoZWNrcG9pbnRlcjogbmV3IE1lbW9yeVNhdmVyKClcbiAqIH0sIGFzeW5jIChudW06IG51bWJlcikgPT4ge1xuICogICBjb25zdCBwcmV2aW91cyA9IGdldFByZXZpb3VzU3RhdGU8bnVtYmVyPigpO1xuICpcbiAqICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgcHJldmlvdXMgdmFsdWUgdG8gdGhlIGNhbGxlciwgc2F2aW5nXG4gKiAgIC8vIDIgKiBudW0gdG8gdGhlIGNoZWNrcG9pbnQsIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiB0aGUgbmV4dCBpbnZvY2F0aW9uXG4gKiAgIC8vIGZvciB0aGUgYHByZXZpb3VzYCBwYXJhbWV0ZXIuXG4gKiAgIHJldHVybiBlbnRyeXBvaW50LmZpbmFsKHtcbiAqICAgICB2YWx1ZTogcHJldmlvdXMgPz8gMCxcbiAqICAgICBzYXZlOiAyICogbnVtXG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogY29uc3QgY29uZmlnID0ge1xuICogICBjb25maWd1cmFibGU6IHtcbiAqICAgICB0aHJlYWRfaWQ6IFwic29tZV90aHJlYWRcIlxuICogICB9XG4gKiB9O1xuICpcbiAqIGF3YWl0IG15V29ya2Zsb3cuaW52b2tlKDMsIGNvbmZpZyk7IC8vIDAgKHByZXZpb3VzIHdhcyB1bmRlZmluZWQpXG4gKiBhd2FpdCBteVdvcmtmbG93Lmludm9rZSgxLCBjb25maWcpOyAvLyA2IChwcmV2aW91cyB3YXMgMyAqIDIgZnJvbSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbilcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgZW50cnlwb2ludCA9IGZ1bmN0aW9uIGVudHJ5cG9pbnQob3B0aW9uc09yTmFtZSwgZnVuYykge1xuICAgIGNvbnN0IHsgbmFtZSwgY2hlY2twb2ludGVyLCBzdG9yZSB9ID0gdHlwZW9mIG9wdGlvbnNPck5hbWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyB7IG5hbWU6IG9wdGlvbnNPck5hbWUsIGNoZWNrcG9pbnRlcjogdW5kZWZpbmVkLCBzdG9yZTogdW5kZWZpbmVkIH1cbiAgICAgICAgOiBvcHRpb25zT3JOYW1lO1xuICAgIGlmIChpc0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24oZnVuYykgfHwgaXNHZW5lcmF0b3JGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3JzIGFyZSBkaXNhbGxvd2VkIGFzIGVudHJ5cG9pbnRzLiBGb3Igc3RyZWFtaW5nIHJlc3BvbnNlcywgdXNlIGNvbmZpZy53cml0ZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbU1vZGUgPSBcInVwZGF0ZXNcIjtcbiAgICBjb25zdCBib3VuZCA9IGdldFJ1bm5hYmxlRm9yRW50cnlwb2ludChuYW1lLCBmdW5jKTtcbiAgICAvLyBIZWxwZXIgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBFbnRyeXBvaW50RmluYWxcbiAgICBmdW5jdGlvbiBpc0VudHJ5cG9pbnRGaW5hbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIFwiX19sZ190eXBlXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLl9fbGdfdHlwZSA9PT0gXCJfX3ByZWdlbF9maW5hbFwiKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBsdWNrIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBFbnRyeXBvaW50RmluYWwgb3IgcGFzc3Rocm91Z2hcbiAgICBjb25zdCBwbHVja1JldHVyblZhbHVlID0gbmV3IFJ1bm5hYmxlQ2FsbGFibGUoe1xuICAgICAgICBuYW1lOiBcInBsdWNrUmV0dXJuVmFsdWVcIixcbiAgICAgICAgZnVuYzogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbnRyeXBvaW50RmluYWwodmFsdWUpID8gdmFsdWUudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGx1Y2sgdGhlIHNhdmUgdmFsdWUgZnJvbSBFbnRyeXBvaW50RmluYWwgb3IgcGFzc3Rocm91Z2hcbiAgICBjb25zdCBwbHVja1NhdmVWYWx1ZSA9IG5ldyBSdW5uYWJsZUNhbGxhYmxlKHtcbiAgICAgICAgbmFtZTogXCJwbHVja1NhdmVWYWx1ZVwiLFxuICAgICAgICBmdW5jOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0VudHJ5cG9pbnRGaW5hbCh2YWx1ZSkgPyB2YWx1ZS5zYXZlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZW50cnlwb2ludE5vZGUgPSBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgIGJvdW5kLFxuICAgICAgICB0cmlnZ2VyczogW1NUQVJUXSxcbiAgICAgICAgY2hhbm5lbHM6IFtTVEFSVF0sXG4gICAgICAgIHdyaXRlcnM6IFtcbiAgICAgICAgICAgIG5ldyBDaGFubmVsV3JpdGUoW1xuICAgICAgICAgICAgICAgIHsgY2hhbm5lbDogRU5ELCB2YWx1ZTogUEFTU1RIUk9VR0gsIG1hcHBlcjogcGx1Y2tSZXR1cm5WYWx1ZSB9LFxuICAgICAgICAgICAgICAgIHsgY2hhbm5lbDogUFJFVklPVVMsIHZhbHVlOiBQQVNTVEhST1VHSCwgbWFwcGVyOiBwbHVja1NhdmVWYWx1ZSB9LFxuICAgICAgICAgICAgXSwgW1RBR19ISURERU5dKSxcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByZWdlbCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrcG9pbnRlcixcbiAgICAgICAgbm9kZXM6IHtcbiAgICAgICAgICAgIFtuYW1lXTogZW50cnlwb2ludE5vZGUsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICBbU1RBUlRdOiBuZXcgRXBoZW1lcmFsVmFsdWUoKSxcbiAgICAgICAgICAgIFtFTkRdOiBuZXcgTGFzdFZhbHVlKCksXG4gICAgICAgICAgICBbUFJFVklPVVNdOiBuZXcgTGFzdFZhbHVlKCksXG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0Q2hhbm5lbHM6IFNUQVJULFxuICAgICAgICBvdXRwdXRDaGFubmVsczogRU5ELFxuICAgICAgICBzdHJlYW1DaGFubmVsczogRU5ELFxuICAgICAgICBzdHJlYW1Nb2RlLFxuICAgICAgICBzdG9yZSxcbiAgICB9KTtcbn07XG4vLyBkb2N1bWVudGVkIGJ5IHRoZSBFbnRyeXBvaW50RnVuY3Rpb24gaW50ZXJmYWNlXG5lbnRyeXBvaW50LmZpbmFsID0gZnVuY3Rpb24gZmluYWwoeyB2YWx1ZSwgc2F2ZSwgfSkge1xuICAgIHJldHVybiB7IHZhbHVlLCBzYXZlLCBfX2xnX3R5cGU6IFwiX19wcmVnZWxfZmluYWxcIiB9O1xufTtcbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSBmdW5jdGlvbiBmb3IgdXNlIHdpdGggdGhlIGZ1bmN0aW9uYWwgQVBJIHRoYXQgcmV0dXJucyB0aGUgcHJldmlvdXNcbiAqIHN0YXRlIGZyb20gdGhlIGNoZWNrcG9pbnQgZnJvbSB0aGUgbGFzdCBpbnZvY2F0aW9uIG9mIHRoZSBjdXJyZW50IHRocmVhZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB3b3JrZmxvd3MgdG8gYWNjZXNzIHN0YXRlIHRoYXQgd2FzIHNhdmVkIGluIHByZXZpb3VzIHJ1bnNcbiAqIHVzaW5nIHtAbGluayBlbnRyeXBvaW50LmZpbmFsfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFN0YXRlVCAtIFRoZSB0eXBlIG9mIHRoZSBzdGF0ZSB0aGF0IHdhcyBwcmV2aW91c2x5IHNhdmVkXG4gKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgc2F2ZWQgc3RhdGUgZnJvbSB0aGUgbGFzdCBpbnZvY2F0aW9uIG9mIHRoZSBjdXJyZW50IHRocmVhZFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcmV2aW91c1N0YXRlID0gZ2V0UHJldmlvdXNTdGF0ZTx7IGNvdW50ZXI6IG51bWJlciB9PigpO1xuICogY29uc3QgbmV3Q291bnQgPSAocHJldmlvdXNTdGF0ZT8uY291bnRlciA/PyAwKSArIDE7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFByZXZpb3VzU3RhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xuICAgIHJldHVybiBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9QUkVWSU9VU19TVEFURV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/func/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js":
/*!****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js ***!
  \****************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationRoot: () => (/* binding */ AnnotationRoot),\n/* harmony export */   getChannel: () => (/* binding */ getChannel)\n/* harmony export */ });\n/* harmony import */ var _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../channels/binop.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/last_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../managed/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n\n\n\n/**\n * Should not be instantiated directly. See {@link Annotation}.\n */\nclass AnnotationRoot {\n    constructor(s) {\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AnnotationRoot\"\n        });\n        Object.defineProperty(this, \"spec\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.spec = s;\n    }\n}\n/**\n * Helper that instantiates channels within a StateGraph state.\n *\n * Can be used as a field in an {@link Annotation.Root} wrapper in one of two ways:\n * 1. **Directly**: Creates a channel that stores the most recent value returned from a node.\n * 2. **With a reducer**: Creates a channel that applies the reducer on a node's return value.\n *\n * @example\n * ```ts\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single string key named \"currentOutput\"\n * const SimpleAnnotation = Annotation.Root({\n *   currentOutput: Annotation<string>,\n * });\n *\n * const graphBuilder = new StateGraph(SimpleAnnotation);\n *\n * // A node in the graph that returns an object with a \"currentOutput\" key\n * // replaces the value in the state. You can get the state type as shown below:\n * const myNode = (state: typeof SimpleAnnotation.State) => {\n *   return {\n *     currentOutput: \"some_new_value\",\n *   };\n * }\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n *\n * @example\n * ```ts\n * import { type BaseMessage, AIMessage } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const AnnotationWithReducer = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     // Different types are allowed for updates\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(AnnotationWithReducer);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof AnnotationWithReducer.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n * @namespace\n * @property Root\n * Helper function that instantiates a StateGraph state. See {@link Annotation} for usage.\n */\nconst Annotation = function (annotation) {\n    if ((0,_managed_base_js__WEBPACK_IMPORTED_MODULE_2__.isConfiguredManagedValue)(annotation)) {\n        return annotation;\n    }\n    else if (annotation) {\n        return getChannel(annotation);\n    }\n    else {\n        // @ts-expect-error - Annotation without reducer\n        return new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n    }\n};\nAnnotation.Root = (sd) => new AnnotationRoot(sd);\nfunction getChannel(reducer) {\n    if (typeof reducer === \"object\" &&\n        reducer &&\n        \"reducer\" in reducer &&\n        reducer.reducer) {\n        return new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(reducer.reducer, reducer.default);\n    }\n    if (typeof reducer === \"object\" &&\n        reducer &&\n        \"value\" in reducer &&\n        reducer.value) {\n        return new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(reducer.value, reducer.default);\n    }\n    // @ts-expect-error - Annotation without reducer\n    return new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n}\n//# sourceMappingURL=annotation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL2Fubm90YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStEO0FBQ1Q7QUFDUztBQUMvRDtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNPO0FBQ1AsUUFBUSwwRUFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1RUFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1RUFBdUI7QUFDMUM7QUFDQTtBQUNBLGVBQWUsOERBQVM7QUFDeEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL2Fubm90YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmluYXJ5T3BlcmF0b3JBZ2dyZWdhdGUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmlub3AuanNcIjtcbmltcG9ydCB7IExhc3RWYWx1ZSB9IGZyb20gXCIuLi9jaGFubmVscy9sYXN0X3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyBpc0NvbmZpZ3VyZWRNYW5hZ2VkVmFsdWUsIH0gZnJvbSBcIi4uL21hbmFnZWQvYmFzZS5qc1wiO1xuLyoqXG4gKiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gU2VlIHtAbGluayBBbm5vdGF0aW9ufS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFubm90YXRpb25Sb290IHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiQW5ub3RhdGlvblJvb3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3BlY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNwZWMgPSBzO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRoYXQgaW5zdGFudGlhdGVzIGNoYW5uZWxzIHdpdGhpbiBhIFN0YXRlR3JhcGggc3RhdGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgYXMgYSBmaWVsZCBpbiBhbiB7QGxpbmsgQW5ub3RhdGlvbi5Sb290fSB3cmFwcGVyIGluIG9uZSBvZiB0d28gd2F5czpcbiAqIDEuICoqRGlyZWN0bHkqKjogQ3JlYXRlcyBhIGNoYW5uZWwgdGhhdCBzdG9yZXMgdGhlIG1vc3QgcmVjZW50IHZhbHVlIHJldHVybmVkIGZyb20gYSBub2RlLlxuICogMi4gKipXaXRoIGEgcmVkdWNlcioqOiBDcmVhdGVzIGEgY2hhbm5lbCB0aGF0IGFwcGxpZXMgdGhlIHJlZHVjZXIgb24gYSBub2RlJ3MgcmV0dXJuIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3RhdGVHcmFwaCwgQW5ub3RhdGlvbiB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIC8vIERlZmluZSBhIHN0YXRlIHdpdGggYSBzaW5nbGUgc3RyaW5nIGtleSBuYW1lZCBcImN1cnJlbnRPdXRwdXRcIlxuICogY29uc3QgU2ltcGxlQW5ub3RhdGlvbiA9IEFubm90YXRpb24uUm9vdCh7XG4gKiAgIGN1cnJlbnRPdXRwdXQ6IEFubm90YXRpb248c3RyaW5nPixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGdyYXBoQnVpbGRlciA9IG5ldyBTdGF0ZUdyYXBoKFNpbXBsZUFubm90YXRpb24pO1xuICpcbiAqIC8vIEEgbm9kZSBpbiB0aGUgZ3JhcGggdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJjdXJyZW50T3V0cHV0XCIga2V5XG4gKiAvLyByZXBsYWNlcyB0aGUgdmFsdWUgaW4gdGhlIHN0YXRlLiBZb3UgY2FuIGdldCB0aGUgc3RhdGUgdHlwZSBhcyBzaG93biBiZWxvdzpcbiAqIGNvbnN0IG15Tm9kZSA9IChzdGF0ZTogdHlwZW9mIFNpbXBsZUFubm90YXRpb24uU3RhdGUpID0+IHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBjdXJyZW50T3V0cHV0OiBcInNvbWVfbmV3X3ZhbHVlXCIsXG4gKiAgIH07XG4gKiB9XG4gKlxuICogY29uc3QgZ3JhcGggPSBncmFwaEJ1aWxkZXJcbiAqICAgLmFkZE5vZGUoXCJteU5vZGVcIiwgbXlOb2RlKVxuICogICAuLi5cbiAqICAgLmNvbXBpbGUoKTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdHlwZSBCYXNlTWVzc2FnZSwgQUlNZXNzYWdlIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiO1xuICogaW1wb3J0IHsgU3RhdGVHcmFwaCwgQW5ub3RhdGlvbiB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIC8vIERlZmluZSBhIHN0YXRlIHdpdGggYSBzaW5nbGUga2V5IG5hbWVkIFwibWVzc2FnZXNcIiB0aGF0IHdpbGxcbiAqIC8vIGNvbWJpbmUgYSByZXR1cm5lZCBCYXNlTWVzc2FnZSBvciBhcnJheXMgb2YgQmFzZU1lc3NhZ2VzXG4gKiBjb25zdCBBbm5vdGF0aW9uV2l0aFJlZHVjZXIgPSBBbm5vdGF0aW9uLlJvb3Qoe1xuICogICBtZXNzYWdlczogQW5ub3RhdGlvbjxCYXNlTWVzc2FnZVtdPih7XG4gKiAgICAgLy8gRGlmZmVyZW50IHR5cGVzIGFyZSBhbGxvd2VkIGZvciB1cGRhdGVzXG4gKiAgICAgcmVkdWNlcjogKGxlZnQ6IEJhc2VNZXNzYWdlW10sIHJpZ2h0OiBCYXNlTWVzc2FnZSB8IEJhc2VNZXNzYWdlW10pID0+IHtcbiAqICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICogICAgICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KFtyaWdodF0pO1xuICogICAgIH0sXG4gKiAgICAgZGVmYXVsdDogKCkgPT4gW10sXG4gKiAgIH0pLFxuICogfSk7XG4gKlxuICogY29uc3QgZ3JhcGhCdWlsZGVyID0gbmV3IFN0YXRlR3JhcGgoQW5ub3RhdGlvbldpdGhSZWR1Y2VyKTtcbiAqXG4gKiAvLyBBIG5vZGUgaW4gdGhlIGdyYXBoIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIFwibWVzc2FnZXNcIiBrZXlcbiAqIC8vIHdpbGwgdXBkYXRlIHRoZSBzdGF0ZSBieSBjb21iaW5pbmcgdGhlIGV4aXN0aW5nIHZhbHVlIHdpdGggdGhlIHJldHVybmVkIG9uZS5cbiAqIGNvbnN0IG15Tm9kZSA9IChzdGF0ZTogdHlwZW9mIEFubm90YXRpb25XaXRoUmVkdWNlci5TdGF0ZSkgPT4ge1xuICogICByZXR1cm4ge1xuICogICAgIG1lc3NhZ2VzOiBbbmV3IEFJTWVzc2FnZShcIlNvbWUgbmV3IHJlc3BvbnNlXCIpXSxcbiAqICAgfTtcbiAqIH07XG4gKlxuICogY29uc3QgZ3JhcGggPSBncmFwaEJ1aWxkZXJcbiAqICAgLmFkZE5vZGUoXCJteU5vZGVcIiwgbXlOb2RlKVxuICogICAuLi5cbiAqICAgLmNvbXBpbGUoKTtcbiAqIGBgYFxuICogQG5hbWVzcGFjZVxuICogQHByb3BlcnR5IFJvb3RcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGluc3RhbnRpYXRlcyBhIFN0YXRlR3JhcGggc3RhdGUuIFNlZSB7QGxpbmsgQW5ub3RhdGlvbn0gZm9yIHVzYWdlLlxuICovXG5leHBvcnQgY29uc3QgQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKGlzQ29uZmlndXJlZE1hbmFnZWRWYWx1ZShhbm5vdGF0aW9uKSkge1xuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChhbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBBbm5vdGF0aW9uIHdpdGhvdXQgcmVkdWNlclxuICAgICAgICByZXR1cm4gbmV3IExhc3RWYWx1ZSgpO1xuICAgIH1cbn07XG5Bbm5vdGF0aW9uLlJvb3QgPSAoc2QpID0+IG5ldyBBbm5vdGF0aW9uUm9vdChzZCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbChyZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHJlZHVjZXIgJiZcbiAgICAgICAgXCJyZWR1Y2VyXCIgaW4gcmVkdWNlciAmJlxuICAgICAgICByZWR1Y2VyLnJlZHVjZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZShyZWR1Y2VyLnJlZHVjZXIsIHJlZHVjZXIuZGVmYXVsdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICByZWR1Y2VyICYmXG4gICAgICAgIFwidmFsdWVcIiBpbiByZWR1Y2VyICYmXG4gICAgICAgIHJlZHVjZXIudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZShyZWR1Y2VyLnZhbHVlLCByZWR1Y2VyLmRlZmF1bHQpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gQW5ub3RhdGlvbiB3aXRob3V0IHJlZHVjZXJcbiAgICByZXR1cm4gbmV3IExhc3RWYWx1ZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ub3RhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/graph.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/graph.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Branch: () => (/* binding */ Branch),\n/* harmony export */   CompiledGraph: () => (/* binding */ CompiledGraph),\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/runnables/graph */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables/graph.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/.pnpm/zod@3.24.4/node_modules/zod/lib/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pregel/read.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pregel/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/index.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pregel/write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pregel/utils/subgraph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n\n\n\n\n\n\n\n\n\n\n\nclass Branch {\n    constructor(options) {\n        Object.defineProperty(this, \"condition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ends\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(options.path)) {\n            this.condition = options.path;\n        }\n        else {\n            this.condition = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(options.path).withConfig({\n                runName: `Branch`,\n            });\n        }\n        this.ends = Array.isArray(options.pathMap)\n            ? options.pathMap.reduce((acc, n) => {\n                acc[n] = n;\n                return acc;\n            }, {})\n            : options.pathMap;\n    }\n    run(writer, reader) {\n        return _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite.registerWriter(new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n            name: \"<branch_run>\",\n            trace: false,\n            func: async (input, config) => {\n                try {\n                    return await this._route(input, config, writer, reader);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    // Detect & warn if NodeInterrupt is thrown in a conditional edge\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_8__.NodeInterrupt.unminifiable_name) {\n                        console.warn(\"[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\\n\" +\n                            \"NodeInterrupt should only be thrown inside a node, not in edge conditions.\");\n                    }\n                    throw e;\n                }\n            },\n        }));\n    }\n    async _route(input, config, writer, reader\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        let result = await this.condition.invoke(reader ? reader(config) : input, config);\n        if (!Array.isArray(result)) {\n            result = [result];\n        }\n        let destinations;\n        if (this.ends) {\n            destinations = result.map((r) => ((0,_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend)(r) ? r : this.ends[r]));\n        }\n        else {\n            destinations = result;\n        }\n        if (destinations.some((dest) => !dest)) {\n            throw new Error(\"Branch condition returned unknown or null destination\");\n        }\n        if (destinations.filter(_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend).some((packet) => packet.node === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidUpdateError(\"Cannot send a packet to the END node\");\n        }\n        const writeResult = await writer(destinations, config);\n        return writeResult ?? input;\n    }\n}\nclass Graph {\n    constructor() {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"entryPoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"compiled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.nodes = {};\n        this.edges = new Set();\n        this.branches = {};\n    }\n    warnIfCompiled(message) {\n        if (this.compiled) {\n            console.warn(message);\n        }\n    }\n    get allEdges() {\n        return this.edges;\n    }\n    addNode(key, action, options) {\n        for (const reservedChar of [\n            _constants_js__WEBPACK_IMPORTED_MODULE_6__.CHECKPOINT_NAMESPACE_SEPARATOR,\n            _constants_js__WEBPACK_IMPORTED_MODULE_6__.CHECKPOINT_NAMESPACE_END,\n        ]) {\n            if (key.includes(reservedChar)) {\n                throw new Error(`\"${reservedChar}\" is a reserved character and is not allowed in node names.`);\n            }\n        }\n        this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n        if (key in this.nodes) {\n            throw new Error(`Node \\`${key}\\` already present.`);\n        }\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n            throw new Error(`Node \\`${key}\\` is reserved.`);\n        }\n        const runnable = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(\n        // Account for arbitrary state due to Send API\n        action);\n        this.nodes[key] = {\n            runnable,\n            metadata: options?.metadata,\n            subgraphs: (0,_pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_9__.isPregelLike)(runnable) ? [runnable] : options?.subgraphs,\n            ends: options?.ends,\n        };\n        return this;\n    }\n    addEdge(startKey, endKey) {\n        this.warnIfCompiled(`Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n        if (startKey === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n            throw new Error(\"END cannot be a start node\");\n        }\n        if (endKey === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START) {\n            throw new Error(\"START cannot be an end node\");\n        }\n        if (Array.from(this.edges).some(([start]) => start === startKey) &&\n            !(\"channels\" in this)) {\n            throw new Error(`Already found path for ${startKey}. For multiple edges, use StateGraph.`);\n        }\n        this.edges.add([startKey, endKey]);\n        return this;\n    }\n    addConditionalEdges(source, path, pathMap) {\n        const options = typeof source === \"object\"\n            ? source\n            : {\n                source,\n                path: path,\n                pathMap,\n            };\n        this.warnIfCompiled(\"Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        if (!_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(options.path)) {\n            const pathDisplayValues = Array.isArray(options.pathMap)\n                ? options.pathMap.join(\",\")\n                : Object.keys(options.pathMap ?? {}).join(\",\");\n            options.path = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(options.path).withConfig({\n                runName: `Branch<${options.source}${pathDisplayValues !== \"\" ? `,${pathDisplayValues}` : \"\"}>`.slice(0, 63),\n            });\n        }\n        // find a name for condition\n        const name = options.path.getName() === \"RunnableLambda\"\n            ? \"condition\"\n            : options.path.getName();\n        // validate condition\n        if (this.branches[options.source] && this.branches[options.source][name]) {\n            throw new Error(`Condition \\`${name}\\` already present for node \\`${source}\\``);\n        }\n        // save it\n        if (!this.branches[options.source]) {\n            this.branches[options.source] = {};\n        }\n        this.branches[options.source][name] = new Branch(options);\n        return this;\n    }\n    /**\n     * @deprecated use `addEdge(START, key)` instead\n     */\n    setEntryPoint(key) {\n        this.warnIfCompiled(\"Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        return this.addEdge(_constants_js__WEBPACK_IMPORTED_MODULE_6__.START, key);\n    }\n    /**\n     * @deprecated use `addEdge(key, END)` instead\n     */\n    setFinishPoint(key) {\n        this.warnIfCompiled(\"Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.\");\n        return this.addEdge(key, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n    }\n    compile({ checkpointer, interruptBefore, interruptAfter, name, } = {}) {\n        // validate the graph\n        this.validate([\n            ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n            ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n        ]);\n        // create empty compiled graph\n        const compiled = new CompiledGraph({\n            builder: this,\n            checkpointer,\n            interruptAfter,\n            interruptBefore,\n            autoValidate: false,\n            nodes: {},\n            channels: {\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue(),\n            },\n            inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_6__.START,\n            outputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            streamChannels: [],\n            streamMode: \"values\",\n            name,\n        });\n        // attach nodes, edges and branches\n        for (const [key, node] of Object.entries(this.nodes)) {\n            compiled.attachNode(key, node);\n        }\n        for (const [start, end] of this.edges) {\n            compiled.attachEdge(start, end);\n        }\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const [name, branch] of Object.entries(branches)) {\n                compiled.attachBranch(start, name, branch);\n            }\n        }\n        return compiled.validate();\n    }\n    validate(interrupt) {\n        // assemble sources\n        const allSources = new Set([...this.allEdges].map(([src, _]) => src));\n        for (const [start] of Object.entries(this.branches)) {\n            allSources.add(start);\n        }\n        for (const source of allSources) {\n            if (source !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.START && !(source in this.nodes)) {\n                throw new Error(`Found edge starting at unknown node \\`${source}\\``);\n            }\n        }\n        // assemble targets\n        const allTargets = new Set([...this.allEdges].map(([_, target]) => target));\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const branch of Object.values(branches)) {\n                if (branch.ends) {\n                    for (const end of Object.values(branch.ends)) {\n                        allTargets.add(end);\n                    }\n                }\n                else {\n                    allTargets.add(_constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n                    for (const node of Object.keys(this.nodes)) {\n                        if (node !== start) {\n                            allTargets.add(node);\n                        }\n                    }\n                }\n            }\n        }\n        for (const node of Object.values(this.nodes)) {\n            for (const target of node.ends ?? []) {\n                allTargets.add(target);\n            }\n        }\n        // validate targets\n        for (const node of Object.keys(this.nodes)) {\n            if (!allTargets.has(node)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.UnreachableNodeError([\n                    `Node \\`${node}\\` is not reachable.`,\n                    \"\",\n                    \"If you are returning Command objects from your node,\",\n                    'make sure you are passing names of potential destination nodes as an \"ends\" array',\n                    'into \".addNode(..., { ends: [\"node1\", \"node2\"] })\".',\n                ].join(\"\\n\"), {\n                    lc_error_code: \"UNREACHABLE_NODE\",\n                });\n            }\n        }\n        for (const target of allTargets) {\n            if (target !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && !(target in this.nodes)) {\n                throw new Error(`Found edge ending at unknown node \\`${target}\\``);\n            }\n        }\n        // validate interrupts\n        if (interrupt) {\n            for (const node of interrupt) {\n                if (!(node in this.nodes)) {\n                    throw new Error(`Interrupt node \\`${node}\\` is not present`);\n                }\n            }\n        }\n        this.compiled = true;\n    }\n}\nclass CompiledGraph extends _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__.Pregel {\n    constructor({ builder, ...rest }) {\n        super(rest);\n        Object.defineProperty(this, \"builder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.builder = builder;\n    }\n    attachNode(key, node) {\n        this.channels[key] = new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue();\n        this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_2__.PregelNode({\n            channels: [],\n            triggers: [],\n            metadata: node.metadata,\n            subgraphs: node.subgraphs,\n            ends: node.ends,\n        })\n            .pipe(node.runnable)\n            .pipe(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite([{ channel: key, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]));\n        this.streamChannels.push(key);\n    }\n    attachEdge(start, end) {\n        if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n            if (start === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START) {\n                throw new Error(\"Cannot have an edge from START to END\");\n            }\n            this.nodes[start].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite([{ channel: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END, value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]));\n        }\n        else {\n            this.nodes[end].triggers.push(start);\n            this.nodes[end].channels.push(start);\n        }\n    }\n    attachBranch(start, name, branch) {\n        // add hidden start node\n        if (start === _constants_js__WEBPACK_IMPORTED_MODULE_6__.START && !this.nodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]) {\n            this.nodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.START] = _pregel_index_js__WEBPACK_IMPORTED_MODULE_3__.Channel.subscribeTo(_constants_js__WEBPACK_IMPORTED_MODULE_6__.START, { tags: [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN] });\n        }\n        // attach branch writer\n        this.nodes[start].pipe(branch.run((dests) => {\n            const writes = dests.map((dest) => {\n                if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_6__._isSend)(dest)) {\n                    return dest;\n                }\n                return {\n                    channel: dest === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END ? _constants_js__WEBPACK_IMPORTED_MODULE_6__.END : `branch:${start}:${name}:${dest}`,\n                    value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.PASSTHROUGH,\n                };\n            });\n            return new _pregel_write_js__WEBPACK_IMPORTED_MODULE_5__.ChannelWrite(writes, [_constants_js__WEBPACK_IMPORTED_MODULE_6__.TAG_HIDDEN]);\n        }));\n        // attach branch readers\n        const ends = branch.ends\n            ? Object.values(branch.ends)\n            : Object.keys(this.nodes);\n        for (const end of ends) {\n            if (end !== _constants_js__WEBPACK_IMPORTED_MODULE_6__.END) {\n                const channelName = `branch:${start}:${name}:${end}`;\n                this.channels[channelName] =\n                    new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_4__.EphemeralValue();\n                this.nodes[end].triggers.push(channelName);\n                this.nodes[end].channels.push(channelName);\n            }\n        }\n    }\n    /**\n     * Returns a drawable representation of the computation graph.\n     */\n    async getGraphAsync(config) {\n        const xray = config?.xray;\n        const graph = new _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__.Graph();\n        const startNodes = {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: graph.addNode({\n                schema: zod__WEBPACK_IMPORTED_MODULE_10__.z.any(),\n            }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.START),\n        };\n        const endNodes = {};\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let subgraphs = {};\n        if (xray) {\n            subgraphs = Object.fromEntries((await (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.gatherIterator)(this.getSubgraphsAsync())).filter(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (x) => isCompiledGraph(x[1])));\n        }\n        function addEdge(start, end, label, conditional = false) {\n            if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] === undefined) {\n                endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] = graph.addNode({ schema: zod__WEBPACK_IMPORTED_MODULE_10__.z.any() }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n            }\n            if (startNodes[start] === undefined) {\n                return;\n            }\n            if (endNodes[end] === undefined) {\n                throw new Error(`End node ${end} not found!`);\n            }\n            return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : undefined, conditional);\n        }\n        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {\n            const displayKey = _escapeMermaidKeywords(key);\n            const node = nodeSpec.runnable;\n            const metadata = nodeSpec.metadata ?? {};\n            if (this.interruptBefore?.includes(key) &&\n                this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"before,after\";\n            }\n            else if (this.interruptBefore?.includes(key)) {\n                metadata.__interrupt = \"before\";\n            }\n            else if (this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"after\";\n            }\n            if (xray) {\n                const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n                const drawableSubgraph = subgraphs[key] !== undefined\n                    ? await subgraphs[key].getGraphAsync({\n                        ...config,\n                        xray: newXrayValue,\n                    })\n                    : node.getGraph(config);\n                drawableSubgraph.trimFirstNode();\n                drawableSubgraph.trimLastNode();\n                if (Object.keys(drawableSubgraph.nodes).length > 1) {\n                    const [e, s] = graph.extend(drawableSubgraph, displayKey);\n                    if (e === undefined) {\n                        throw new Error(`Could not extend subgraph \"${key}\" due to missing entrypoint.`);\n                    }\n                    // TODO: Remove default name once we stop supporting core 0.2.0\n                    // eslint-disable-next-line no-inner-declarations\n                    function _isRunnableInterface(\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    thing) {\n                        return thing ? thing.lc_runnable : false;\n                    }\n                    // eslint-disable-next-line no-inner-declarations\n                    function _nodeDataStr(id, data) {\n                        if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(id)) {\n                            return id;\n                        }\n                        else if (_isRunnableInterface(data)) {\n                            try {\n                                let dataStr = data.getName();\n                                dataStr = dataStr.startsWith(\"Runnable\")\n                                    ? dataStr.slice(\"Runnable\".length)\n                                    : dataStr;\n                                return dataStr;\n                            }\n                            catch (error) {\n                                return data.getName();\n                            }\n                        }\n                        else {\n                            return data.name ?? \"UnknownSchema\";\n                        }\n                    }\n                    // TODO: Remove casts when we stop supporting core 0.2.0\n                    if (s !== undefined) {\n                        startNodes[displayKey] = {\n                            name: _nodeDataStr(s.id, s.data),\n                            ...s,\n                        };\n                    }\n                    endNodes[displayKey] = {\n                        name: _nodeDataStr(e.id, e.data),\n                        ...e,\n                    };\n                }\n                else {\n                    // TODO: Remove when we stop supporting core 0.2.0\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const newNode = graph.addNode(node, displayKey, metadata);\n                    startNodes[displayKey] = newNode;\n                    endNodes[displayKey] = newNode;\n                }\n            }\n            else {\n                // TODO: Remove when we stop supporting core 0.2.0\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                const newNode = graph.addNode(node, displayKey, metadata);\n                startNodes[displayKey] = newNode;\n                endNodes[displayKey] = newNode;\n            }\n        }\n        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n            if (a < b) {\n                return -1;\n            }\n            else if (b > a) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        for (const [start, end] of sortedEdges) {\n            addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n        }\n        for (const [start, branches] of Object.entries(this.builder.branches)) {\n            const defaultEnds = {\n                ...Object.fromEntries(Object.keys(this.builder.nodes)\n                    .filter((k) => k !== start)\n                    .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            };\n            for (const branch of Object.values(branches)) {\n                let ends;\n                if (branch.ends !== undefined) {\n                    ends = branch.ends;\n                }\n                else {\n                    ends = defaultEnds;\n                }\n                for (const [label, end] of Object.entries(ends)) {\n                    addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);\n                }\n            }\n        }\n        for (const [key, node] of Object.entries(this.builder.nodes)) {\n            if (node.ends !== undefined) {\n                for (const end of node.ends) {\n                    addEdge(_escapeMermaidKeywords(key), _escapeMermaidKeywords(end), undefined, true);\n                }\n            }\n        }\n        return graph;\n    }\n    /**\n     * Returns a drawable representation of the computation graph.\n     *\n     * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.\n     */\n    getGraph(config) {\n        const xray = config?.xray;\n        const graph = new _langchain_core_runnables_graph__WEBPACK_IMPORTED_MODULE_1__.Graph();\n        const startNodes = {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_6__.START]: graph.addNode({\n                schema: zod__WEBPACK_IMPORTED_MODULE_10__.z.any(),\n            }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.START),\n        };\n        const endNodes = {};\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let subgraphs = {};\n        if (xray) {\n            subgraphs = Object.fromEntries((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.gatherIteratorSync)(this.getSubgraphs()).filter(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (x) => isCompiledGraph(x[1])));\n        }\n        function addEdge(start, end, label, conditional = false) {\n            if (end === _constants_js__WEBPACK_IMPORTED_MODULE_6__.END && endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] === undefined) {\n                endNodes[_constants_js__WEBPACK_IMPORTED_MODULE_6__.END] = graph.addNode({ schema: zod__WEBPACK_IMPORTED_MODULE_10__.z.any() }, _constants_js__WEBPACK_IMPORTED_MODULE_6__.END);\n            }\n            return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : undefined, conditional);\n        }\n        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {\n            const displayKey = _escapeMermaidKeywords(key);\n            const node = nodeSpec.runnable;\n            const metadata = nodeSpec.metadata ?? {};\n            if (this.interruptBefore?.includes(key) &&\n                this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"before,after\";\n            }\n            else if (this.interruptBefore?.includes(key)) {\n                metadata.__interrupt = \"before\";\n            }\n            else if (this.interruptAfter?.includes(key)) {\n                metadata.__interrupt = \"after\";\n            }\n            if (xray) {\n                const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n                const drawableSubgraph = subgraphs[key] !== undefined\n                    ? subgraphs[key].getGraph({\n                        ...config,\n                        xray: newXrayValue,\n                    })\n                    : node.getGraph(config);\n                drawableSubgraph.trimFirstNode();\n                drawableSubgraph.trimLastNode();\n                if (Object.keys(drawableSubgraph.nodes).length > 1) {\n                    const [e, s] = graph.extend(drawableSubgraph, displayKey);\n                    if (e === undefined) {\n                        throw new Error(`Could not extend subgraph \"${key}\" due to missing entrypoint.`);\n                    }\n                    // TODO: Remove default name once we stop supporting core 0.2.0\n                    // eslint-disable-next-line no-inner-declarations\n                    function _isRunnableInterface(\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    thing) {\n                        return thing ? thing.lc_runnable : false;\n                    }\n                    // eslint-disable-next-line no-inner-declarations\n                    function _nodeDataStr(id, data) {\n                        if (id !== undefined && !(0,uuid__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(id)) {\n                            return id;\n                        }\n                        else if (_isRunnableInterface(data)) {\n                            try {\n                                let dataStr = data.getName();\n                                dataStr = dataStr.startsWith(\"Runnable\")\n                                    ? dataStr.slice(\"Runnable\".length)\n                                    : dataStr;\n                                return dataStr;\n                            }\n                            catch (error) {\n                                return data.getName();\n                            }\n                        }\n                        else {\n                            return data.name ?? \"UnknownSchema\";\n                        }\n                    }\n                    // TODO: Remove casts when we stop supporting core 0.2.0\n                    if (s !== undefined) {\n                        startNodes[displayKey] = {\n                            name: _nodeDataStr(s.id, s.data),\n                            ...s,\n                        };\n                    }\n                    endNodes[displayKey] = {\n                        name: _nodeDataStr(e.id, e.data),\n                        ...e,\n                    };\n                }\n                else {\n                    // TODO: Remove when we stop supporting core 0.2.0\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const newNode = graph.addNode(node, displayKey, metadata);\n                    startNodes[displayKey] = newNode;\n                    endNodes[displayKey] = newNode;\n                }\n            }\n            else {\n                // TODO: Remove when we stop supporting core 0.2.0\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                const newNode = graph.addNode(node, displayKey, metadata);\n                startNodes[displayKey] = newNode;\n                endNodes[displayKey] = newNode;\n            }\n        }\n        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n            if (a < b) {\n                return -1;\n            }\n            else if (b > a) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        for (const [start, end] of sortedEdges) {\n            addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n        }\n        for (const [start, branches] of Object.entries(this.builder.branches)) {\n            const defaultEnds = {\n                ...Object.fromEntries(Object.keys(this.builder.nodes)\n                    .filter((k) => k !== start)\n                    .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),\n                [_constants_js__WEBPACK_IMPORTED_MODULE_6__.END]: _constants_js__WEBPACK_IMPORTED_MODULE_6__.END,\n            };\n            for (const branch of Object.values(branches)) {\n                let ends;\n                if (branch.ends !== undefined) {\n                    ends = branch.ends;\n                }\n                else {\n                    ends = defaultEnds;\n                }\n                for (const [label, end] of Object.entries(ends)) {\n                    addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);\n                }\n            }\n        }\n        return graph;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isCompiledGraph(x) {\n    return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof x.attachNode === \"function\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof x.attachEdge === \"function\");\n}\nfunction _escapeMermaidKeywords(key) {\n    if (key === \"subgraph\") {\n        return `\"${key}\"`;\n    }\n    return key;\n}\n//# sourceMappingURL=graph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL2dyYXBoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3lFO0FBQ0M7QUFDbEQ7QUFDa0I7QUFDSztBQUNNO0FBQ1c7QUFDRDtBQUM4RDtBQUN6QztBQUNJO0FBQzdCO0FBQ3BEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSwrREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEVBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBWSxvQkFBb0IsdURBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTyxtQ0FBbUMsOENBQUc7QUFDN0Usc0JBQXNCLDBEQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlFQUE4QjtBQUMxQyxZQUFZLG1FQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBLG9CQUFvQiw4Q0FBRztBQUN2QixzQ0FBc0MsSUFBSTtBQUMxQztBQUNBLHlCQUF5Qiw0RUFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQUc7QUFDNUI7QUFDQTtBQUNBLHVCQUF1QixnREFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrREFBUTtBQUNyQjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDJCQUEyQiw0RUFBaUI7QUFDNUMsbUNBQW1DLGVBQWUsRUFBRSwrQkFBK0Isa0JBQWtCLE9BQU87QUFDNUcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUssZ0NBQWdDLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhDQUFHO0FBQ3BDO0FBQ0EsY0FBYyx1REFBdUQsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUIsZ0RBQUssT0FBTyx3RUFBYztBQUMzQyxpQkFBaUIsOENBQUcsT0FBTyx3RUFBYztBQUN6QyxhQUFhO0FBQ2IsMkJBQTJCLGdEQUFLO0FBQ2hDLDRCQUE0Qiw4Q0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFLO0FBQ2hDLHlFQUF5RSxPQUFPO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0REFBb0I7QUFDOUMsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBRztBQUM5Qix1RUFBdUUsT0FBTztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsb0RBQU07QUFDekMsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdFQUFjO0FBQy9DLDhCQUE4Qix1REFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLDBEQUFZLElBQUkscUJBQXFCLHlEQUFXLEVBQUUsSUFBSSxxREFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQUc7QUFDdkIsMEJBQTBCLGdEQUFLO0FBQy9CO0FBQ0E7QUFDQSwrQ0FBK0MsMERBQVksSUFBSSxTQUFTLDhDQUFHLFNBQVMseURBQVcsRUFBRSxJQUFJLHFEQUFVO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQUssZ0JBQWdCLGdEQUFLO0FBQ2hELHVCQUF1QixnREFBSyxJQUFJLHFEQUFPLGFBQWEsZ0RBQUssSUFBSSxPQUFPLHFEQUFVLEdBQUc7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUFHLEdBQUcsOENBQUcsYUFBYSxNQUFNLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDbEYsMkJBQTJCLHlEQUFXO0FBQ3RDO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QiwwREFBWSxVQUFVLHFEQUFVO0FBQ3ZELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFHO0FBQzNCLDhDQUE4QyxNQUFNLEdBQUcsS0FBSyxHQUFHLElBQUk7QUFDbkU7QUFDQSx3QkFBd0Isd0VBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQWE7QUFDdkM7QUFDQSxhQUFhLGdEQUFLO0FBQ2xCLHdCQUF3QixtQ0FBQztBQUN6QixhQUFhLEVBQUUsZ0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5REFBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBRyxhQUFhLDhDQUFHO0FBQzNDLHlCQUF5Qiw4Q0FBRyxvQkFBb0IsUUFBUSxtQ0FBQyxRQUFRLEVBQUUsOENBQUc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaURBQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBRyxHQUFHLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBYTtBQUN2QztBQUNBLGFBQWEsZ0RBQUs7QUFDbEIsd0JBQXdCLG1DQUFDO0FBQ3pCLGFBQWEsRUFBRSxnREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZEQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBRyxhQUFhLDhDQUFHO0FBQzNDLHlCQUF5Qiw4Q0FBRyxvQkFBb0IsUUFBUSxtQ0FBQyxRQUFRLEVBQUUsOENBQUc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpREFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFHLEdBQUcsOENBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9ncmFwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmltcG9ydCB7IF9jb2VyY2VUb1J1bm5hYmxlLCBSdW5uYWJsZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuaW1wb3J0IHsgR3JhcGggYXMgRHJhd2FibGVHcmFwaCwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy9ncmFwaFwiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IHZhbGlkYXRlIGFzIGlzVXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBQcmVnZWxOb2RlIH0gZnJvbSBcIi4uL3ByZWdlbC9yZWFkLmpzXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBQcmVnZWwgfSBmcm9tIFwiLi4vcHJlZ2VsL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFcGhlbWVyYWxWYWx1ZSB9IGZyb20gXCIuLi9jaGFubmVscy9lcGhlbWVyYWxfdmFsdWUuanNcIjtcbmltcG9ydCB7IENoYW5uZWxXcml0ZSwgUEFTU1RIUk9VR0ggfSBmcm9tIFwiLi4vcHJlZ2VsL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBfaXNTZW5kLCBDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiwgRU5ELCBTVEFSVCwgVEFHX0hJRERFTiwgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnYXRoZXJJdGVyYXRvciwgZ2F0aGVySXRlcmF0b3JTeW5jLCBSdW5uYWJsZUNhbGxhYmxlLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZFVwZGF0ZUVycm9yLCBOb2RlSW50ZXJydXB0LCBVbnJlYWNoYWJsZU5vZGVFcnJvciwgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBpc1ByZWdlbExpa2UgfSBmcm9tIFwiLi4vcHJlZ2VsL3V0aWxzL3N1YmdyYXBoLmpzXCI7XG5leHBvcnQgY2xhc3MgQnJhbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmRpdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKG9wdGlvbnMucGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW9ucy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBfY29lcmNlVG9SdW5uYWJsZShvcHRpb25zLnBhdGgpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IGBCcmFuY2hgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhNYXApXG4gICAgICAgICAgICA/IG9wdGlvbnMucGF0aE1hcC5yZWR1Y2UoKGFjYywgbikgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tuXSA9IG47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgOiBvcHRpb25zLnBhdGhNYXA7XG4gICAgfVxuICAgIHJ1bih3cml0ZXIsIHJlYWRlcikge1xuICAgICAgICByZXR1cm4gQ2hhbm5lbFdyaXRlLnJlZ2lzdGVyV3JpdGVyKG5ldyBSdW5uYWJsZUNhbGxhYmxlKHtcbiAgICAgICAgICAgIG5hbWU6IFwiPGJyYW5jaF9ydW4+XCIsXG4gICAgICAgICAgICB0cmFjZTogZmFsc2UsXG4gICAgICAgICAgICBmdW5jOiBhc3luYyAoaW5wdXQsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yb3V0ZShpbnB1dCwgY29uZmlnLCB3cml0ZXIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdCAmIHdhcm4gaWYgTm9kZUludGVycnVwdCBpcyB0aHJvd24gaW4gYSBjb25kaXRpb25hbCBlZGdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IE5vZGVJbnRlcnJ1cHQudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXTogJ05vZGVJbnRlcnJ1cHQnIHRocm93biBpbiBjb25kaXRpb25hbCBlZGdlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiB5b3VyIGdyYXBoIGltcGxlbWVudGF0aW9uLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vZGVJbnRlcnJ1cHQgc2hvdWxkIG9ubHkgYmUgdGhyb3duIGluc2lkZSBhIG5vZGUsIG5vdCBpbiBlZGdlIGNvbmRpdGlvbnMuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBfcm91dGUoaW5wdXQsIGNvbmZpZywgd3JpdGVyLCByZWFkZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25kaXRpb24uaW52b2tlKHJlYWRlciA/IHJlYWRlcihjb25maWcpIDogaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzdGluYXRpb25zO1xuICAgICAgICBpZiAodGhpcy5lbmRzKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbnMgPSByZXN1bHQubWFwKChyKSA9PiAoX2lzU2VuZChyKSA/IHIgOiB0aGlzLmVuZHNbcl0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucyA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzdGluYXRpb25zLnNvbWUoKGRlc3QpID0+ICFkZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJhbmNoIGNvbmRpdGlvbiByZXR1cm5lZCB1bmtub3duIG9yIG51bGwgZGVzdGluYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9ucy5maWx0ZXIoX2lzU2VuZCkuc29tZSgocGFja2V0KSA9PiBwYWNrZXQubm9kZSA9PT0gRU5EKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihcIkNhbm5vdCBzZW5kIGEgcGFja2V0IHRvIHRoZSBFTkQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cml0ZVJlc3VsdCA9IGF3YWl0IHdyaXRlcihkZXN0aW5hdGlvbnMsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB3cml0ZVJlc3VsdCA/PyBpbnB1dDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJicmFuY2hlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbnRyeVBvaW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbXBpbGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmVkZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgfVxuICAgIHdhcm5JZkNvbXBpbGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWxsRWRnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICAgIH1cbiAgICBhZGROb2RlKGtleSwgYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzZXJ2ZWRDaGFyIG9mIFtcbiAgICAgICAgICAgIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUixcbiAgICAgICAgICAgIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCxcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhyZXNlcnZlZENoYXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7cmVzZXJ2ZWRDaGFyfVwiIGlzIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIGFuZCBpcyBub3QgYWxsb3dlZCBpbiBub2RlIG5hbWVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoYEFkZGluZyBhIG5vZGUgdG8gYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5gKTtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgXFxgJHtrZXl9XFxgIGFscmVhZHkgcHJlc2VudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBFTkQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBcXGAke2tleX1cXGAgaXMgcmVzZXJ2ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGUgPSBfY29lcmNlVG9SdW5uYWJsZShcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgYXJiaXRyYXJ5IHN0YXRlIGR1ZSB0byBTZW5kIEFQSVxuICAgICAgICBhY3Rpb24pO1xuICAgICAgICB0aGlzLm5vZGVzW2tleV0gPSB7XG4gICAgICAgICAgICBydW5uYWJsZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIHN1YmdyYXBoczogaXNQcmVnZWxMaWtlKHJ1bm5hYmxlKSA/IFtydW5uYWJsZV0gOiBvcHRpb25zPy5zdWJncmFwaHMsXG4gICAgICAgICAgICBlbmRzOiBvcHRpb25zPy5lbmRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkRWRnZShzdGFydEtleSwgZW5kS2V5KSB7XG4gICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoYEFkZGluZyBhbiBlZGdlIHRvIGEgZ3JhcGggdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBpbGVkLiBUaGlzIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgY29tcGlsZWQgZ3JhcGguYCk7XG4gICAgICAgIGlmIChzdGFydEtleSA9PT0gRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGEgc3RhcnQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kS2V5ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RBUlQgY2Fubm90IGJlIGFuIGVuZCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5mcm9tKHRoaXMuZWRnZXMpLnNvbWUoKFtzdGFydF0pID0+IHN0YXJ0ID09PSBzdGFydEtleSkgJiZcbiAgICAgICAgICAgICEoXCJjaGFubmVsc1wiIGluIHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgZm91bmQgcGF0aCBmb3IgJHtzdGFydEtleX0uIEZvciBtdWx0aXBsZSBlZGdlcywgdXNlIFN0YXRlR3JhcGguYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGdlcy5hZGQoW3N0YXJ0S2V5LCBlbmRLZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZENvbmRpdGlvbmFsRWRnZXMoc291cmNlLCBwYXRoLCBwYXRoTWFwKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygc291cmNlID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICA/IHNvdXJjZVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMud2FybklmQ29tcGlsZWQoXCJBZGRpbmcgYW4gZWRnZSB0byBhIGdyYXBoIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb21waWxlZC4gVGhpcyB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGNvbXBpbGVkIGdyYXBoLlwiKTtcbiAgICAgICAgaWYgKCFSdW5uYWJsZS5pc1J1bm5hYmxlKG9wdGlvbnMucGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhEaXNwbGF5VmFsdWVzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhNYXApXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhdGhNYXAuam9pbihcIixcIilcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKG9wdGlvbnMucGF0aE1hcCA/PyB7fSkuam9pbihcIixcIik7XG4gICAgICAgICAgICBvcHRpb25zLnBhdGggPSBfY29lcmNlVG9SdW5uYWJsZShvcHRpb25zLnBhdGgpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IGBCcmFuY2g8JHtvcHRpb25zLnNvdXJjZX0ke3BhdGhEaXNwbGF5VmFsdWVzICE9PSBcIlwiID8gYCwke3BhdGhEaXNwbGF5VmFsdWVzfWAgOiBcIlwifT5gLnNsaWNlKDAsIDYzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgYSBuYW1lIGZvciBjb25kaXRpb25cbiAgICAgICAgY29uc3QgbmFtZSA9IG9wdGlvbnMucGF0aC5nZXROYW1lKCkgPT09IFwiUnVubmFibGVMYW1iZGFcIlxuICAgICAgICAgICAgPyBcImNvbmRpdGlvblwiXG4gICAgICAgICAgICA6IG9wdGlvbnMucGF0aC5nZXROYW1lKCk7XG4gICAgICAgIC8vIHZhbGlkYXRlIGNvbmRpdGlvblxuICAgICAgICBpZiAodGhpcy5icmFuY2hlc1tvcHRpb25zLnNvdXJjZV0gJiYgdGhpcy5icmFuY2hlc1tvcHRpb25zLnNvdXJjZV1bbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZGl0aW9uIFxcYCR7bmFtZX1cXGAgYWxyZWFkeSBwcmVzZW50IGZvciBub2RlIFxcYCR7c291cmNlfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNhdmUgaXRcbiAgICAgICAgaWYgKCF0aGlzLmJyYW5jaGVzW29wdGlvbnMuc291cmNlXSkge1xuICAgICAgICAgICAgdGhpcy5icmFuY2hlc1tvcHRpb25zLnNvdXJjZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyYW5jaGVzW29wdGlvbnMuc291cmNlXVtuYW1lXSA9IG5ldyBCcmFuY2gob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYGFkZEVkZ2UoU1RBUlQsIGtleSlgIGluc3RlYWRcbiAgICAgKi9cbiAgICBzZXRFbnRyeVBvaW50KGtleSkge1xuICAgICAgICB0aGlzLndhcm5JZkNvbXBpbGVkKFwiU2V0dGluZyB0aGUgZW50cnkgcG9pbnQgb2YgYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEVkZ2UoU1RBUlQsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBgYWRkRWRnZShrZXksIEVORClgIGluc3RlYWRcbiAgICAgKi9cbiAgICBzZXRGaW5pc2hQb2ludChrZXkpIHtcbiAgICAgICAgdGhpcy53YXJuSWZDb21waWxlZChcIlNldHRpbmcgYSBmaW5pc2ggcG9pbnQgb2YgYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEVkZ2Uoa2V5LCBFTkQpO1xuICAgIH1cbiAgICBjb21waWxlKHsgY2hlY2twb2ludGVyLCBpbnRlcnJ1cHRCZWZvcmUsIGludGVycnVwdEFmdGVyLCBuYW1lLCB9ID0ge30pIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgdGhlIGdyYXBoXG4gICAgICAgIHRoaXMudmFsaWRhdGUoW1xuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoaW50ZXJydXB0QmVmb3JlKSA/IGludGVycnVwdEJlZm9yZSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGludGVycnVwdEFmdGVyKSA/IGludGVycnVwdEFmdGVyIDogW10pLFxuICAgICAgICBdKTtcbiAgICAgICAgLy8gY3JlYXRlIGVtcHR5IGNvbXBpbGVkIGdyYXBoXG4gICAgICAgIGNvbnN0IGNvbXBpbGVkID0gbmV3IENvbXBpbGVkR3JhcGgoe1xuICAgICAgICAgICAgYnVpbGRlcjogdGhpcyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgIGludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgYXV0b1ZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgW1NUQVJUXTogbmV3IEVwaGVtZXJhbFZhbHVlKCksXG4gICAgICAgICAgICAgICAgW0VORF06IG5ldyBFcGhlbWVyYWxWYWx1ZSgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0Q2hhbm5lbHM6IFNUQVJULFxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbHM6IEVORCxcbiAgICAgICAgICAgIHN0cmVhbUNoYW5uZWxzOiBbXSxcbiAgICAgICAgICAgIHN0cmVhbU1vZGU6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYXR0YWNoIG5vZGVzLCBlZGdlcyBhbmQgYnJhbmNoZXNcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgY29tcGlsZWQuYXR0YWNoTm9kZShrZXksIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHRoaXMuZWRnZXMpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGJyYW5jaGVzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJyYW5jaGVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYnJhbmNoXSBvZiBPYmplY3QuZW50cmllcyhicmFuY2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlZC5hdHRhY2hCcmFuY2goc3RhcnQsIG5hbWUsIGJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkLnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKGludGVycnVwdCkge1xuICAgICAgICAvLyBhc3NlbWJsZSBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGFsbFNvdXJjZXMgPSBuZXcgU2V0KFsuLi50aGlzLmFsbEVkZ2VzXS5tYXAoKFtzcmMsIF9dKSA9PiBzcmMpKTtcbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICBhbGxTb3VyY2VzLmFkZChzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgYWxsU291cmNlcykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gU1RBUlQgJiYgIShzb3VyY2UgaW4gdGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGVkZ2Ugc3RhcnRpbmcgYXQgdW5rbm93biBub2RlIFxcYCR7c291cmNlfVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VtYmxlIHRhcmdldHNcbiAgICAgICAgY29uc3QgYWxsVGFyZ2V0cyA9IG5ldyBTZXQoWy4uLnRoaXMuYWxsRWRnZXNdLm1hcCgoW18sIHRhcmdldF0pID0+IHRhcmdldCkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgYnJhbmNoZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyYW5jaCBvZiBPYmplY3QudmFsdWVzKGJyYW5jaGVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChicmFuY2guZW5kcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZCBvZiBPYmplY3QudmFsdWVzKGJyYW5jaC5lbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQoZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQoRU5EKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxUYXJnZXRzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2Ygbm9kZS5lbmRzID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgYWxsVGFyZ2V0cy5hZGQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSB0YXJnZXRzXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgaWYgKCFhbGxUYXJnZXRzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnJlYWNoYWJsZU5vZGVFcnJvcihbXG4gICAgICAgICAgICAgICAgICAgIGBOb2RlIFxcYCR7bm9kZX1cXGAgaXMgbm90IHJlYWNoYWJsZS5gLFxuICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBcIklmIHlvdSBhcmUgcmV0dXJuaW5nIENvbW1hbmQgb2JqZWN0cyBmcm9tIHlvdXIgbm9kZSxcIixcbiAgICAgICAgICAgICAgICAgICAgJ21ha2Ugc3VyZSB5b3UgYXJlIHBhc3NpbmcgbmFtZXMgb2YgcG90ZW50aWFsIGRlc3RpbmF0aW9uIG5vZGVzIGFzIGFuIFwiZW5kc1wiIGFycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludG8gXCIuYWRkTm9kZSguLi4sIHsgZW5kczogW1wibm9kZTFcIiwgXCJub2RlMlwiXSB9KVwiLicsXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgIGxjX2Vycm9yX2NvZGU6IFwiVU5SRUFDSEFCTEVfTk9ERVwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGFsbFRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IEVORCAmJiAhKHRhcmdldCBpbiB0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgZWRnZSBlbmRpbmcgYXQgdW5rbm93biBub2RlIFxcYCR7dGFyZ2V0fVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIGludGVycnVwdHNcbiAgICAgICAgaWYgKGludGVycnVwdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGludGVycnVwdCkge1xuICAgICAgICAgICAgICAgIGlmICghKG5vZGUgaW4gdGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcnJ1cHQgbm9kZSBcXGAke25vZGV9XFxgIGlzIG5vdCBwcmVzZW50YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb21waWxlZEdyYXBoIGV4dGVuZHMgUHJlZ2VsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGJ1aWxkZXIsIC4uLnJlc3QgfSkge1xuICAgICAgICBzdXBlcihyZXN0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVpbGRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIH1cbiAgICBhdHRhY2hOb2RlKGtleSwgbm9kZSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2tleV0gPSBuZXcgRXBoZW1lcmFsVmFsdWUoKTtcbiAgICAgICAgdGhpcy5ub2Rlc1trZXldID0gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgY2hhbm5lbHM6IFtdLFxuICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5vZGUubWV0YWRhdGEsXG4gICAgICAgICAgICBzdWJncmFwaHM6IG5vZGUuc3ViZ3JhcGhzLFxuICAgICAgICAgICAgZW5kczogbm9kZS5lbmRzLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUobm9kZS5ydW5uYWJsZSlcbiAgICAgICAgICAgIC5waXBlKG5ldyBDaGFubmVsV3JpdGUoW3sgY2hhbm5lbDoga2V5LCB2YWx1ZTogUEFTU1RIUk9VR0ggfV0sIFtUQUdfSElEREVOXSkpO1xuICAgICAgICB0aGlzLnN0cmVhbUNoYW5uZWxzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgYXR0YWNoRWRnZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IEVORCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGFuIGVkZ2UgZnJvbSBTVEFSVCB0byBFTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vZGVzW3N0YXJ0XS53cml0ZXJzLnB1c2gobmV3IENoYW5uZWxXcml0ZShbeyBjaGFubmVsOiBFTkQsIHZhbHVlOiBQQVNTVEhST1VHSCB9XSwgW1RBR19ISURERU5dKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0udHJpZ2dlcnMucHVzaChzdGFydCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0uY2hhbm5lbHMucHVzaChzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQnJhbmNoKHN0YXJ0LCBuYW1lLCBicmFuY2gpIHtcbiAgICAgICAgLy8gYWRkIGhpZGRlbiBzdGFydCBub2RlXG4gICAgICAgIGlmIChzdGFydCA9PT0gU1RBUlQgJiYgIXRoaXMubm9kZXNbU1RBUlRdKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW1NUQVJUXSA9IENoYW5uZWwuc3Vic2NyaWJlVG8oU1RBUlQsIHsgdGFnczogW1RBR19ISURERU5dIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBicmFuY2ggd3JpdGVyXG4gICAgICAgIHRoaXMubm9kZXNbc3RhcnRdLnBpcGUoYnJhbmNoLnJ1bigoZGVzdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IGRlc3RzLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChfaXNTZW5kKGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBkZXN0ID09PSBFTkQgPyBFTkQgOiBgYnJhbmNoOiR7c3RhcnR9OiR7bmFtZX06JHtkZXN0fWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBQQVNTVEhST1VHSCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5uZWxXcml0ZSh3cml0ZXMsIFtUQUdfSElEREVOXSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gYXR0YWNoIGJyYW5jaCByZWFkZXJzXG4gICAgICAgIGNvbnN0IGVuZHMgPSBicmFuY2guZW5kc1xuICAgICAgICAgICAgPyBPYmplY3QudmFsdWVzKGJyYW5jaC5lbmRzKVxuICAgICAgICAgICAgOiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBlbmQgb2YgZW5kcykge1xuICAgICAgICAgICAgaWYgKGVuZCAhPT0gRU5EKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgYnJhbmNoOiR7c3RhcnR9OiR7bmFtZX06JHtlbmR9YDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcGhlbWVyYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbZW5kXS50cmlnZ2Vycy5wdXNoKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0uY2hhbm5lbHMucHVzaChjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRyYXdhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wdXRhdGlvbiBncmFwaC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRHcmFwaEFzeW5jKGNvbmZpZykge1xuICAgICAgICBjb25zdCB4cmF5ID0gY29uZmlnPy54cmF5O1xuICAgICAgICBjb25zdCBncmFwaCA9IG5ldyBEcmF3YWJsZUdyYXBoKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZXMgPSB7XG4gICAgICAgICAgICBbU1RBUlRdOiBncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHouYW55KCksXG4gICAgICAgICAgICB9LCBTVEFSVCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZE5vZGVzID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBzdWJncmFwaHMgPSB7fTtcbiAgICAgICAgaWYgKHhyYXkpIHtcbiAgICAgICAgICAgIHN1YmdyYXBocyA9IE9iamVjdC5mcm9tRW50cmllcygoYXdhaXQgZ2F0aGVySXRlcmF0b3IodGhpcy5nZXRTdWJncmFwaHNBc3luYygpKSkuZmlsdGVyKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICh4KSA9PiBpc0NvbXBpbGVkR3JhcGgoeFsxXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRFZGdlKHN0YXJ0LCBlbmQsIGxhYmVsLCBjb25kaXRpb25hbCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kID09PSBFTkQgJiYgZW5kTm9kZXNbRU5EXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZXNbRU5EXSA9IGdyYXBoLmFkZE5vZGUoeyBzY2hlbWE6IHouYW55KCkgfSwgRU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE5vZGVzW3N0YXJ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZE5vZGVzW2VuZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5kIG5vZGUgJHtlbmR9IG5vdCBmb3VuZCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmFwaC5hZGRFZGdlKHN0YXJ0Tm9kZXNbc3RhcnRdLCBlbmROb2Rlc1tlbmRdLCBsYWJlbCAhPT0gZW5kID8gbGFiZWwgOiB1bmRlZmluZWQsIGNvbmRpdGlvbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVTcGVjXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1aWxkZXIubm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5S2V5ID0gX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrZXkpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVTcGVjLnJ1bm5hYmxlO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBub2RlU3BlYy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVycnVwdEJlZm9yZT8uaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0QWZ0ZXI/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYmVmb3JlLGFmdGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmludGVycnVwdEJlZm9yZT8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLl9faW50ZXJydXB0ID0gXCJiZWZvcmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW50ZXJydXB0QWZ0ZXI/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYWZ0ZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4cmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WHJheVZhbHVlID0gdHlwZW9mIHhyYXkgPT09IFwibnVtYmVyXCIgPyB4cmF5IC0gMSA6IHhyYXk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2FibGVTdWJncmFwaCA9IHN1YmdyYXBoc1trZXldICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBzdWJncmFwaHNba2V5XS5nZXRHcmFwaEFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyYXk6IG5ld1hyYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgZHJhd2FibGVTdWJncmFwaC50cmltRmlyc3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgZHJhd2FibGVTdWJncmFwaC50cmltTGFzdE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZHJhd2FibGVTdWJncmFwaC5ub2RlcykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZSwgc10gPSBncmFwaC5leHRlbmQoZHJhd2FibGVTdWJncmFwaCwgZGlzcGxheUtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dGVuZCBzdWJncmFwaCBcIiR7a2V5fVwiIGR1ZSB0byBtaXNzaW5nIGVudHJ5cG9pbnQuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGRlZmF1bHQgbmFtZSBvbmNlIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2lzUnVubmFibGVJbnRlcmZhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpbmcgPyB0aGluZy5sY19ydW5uYWJsZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX25vZGVEYXRhU3RyKGlkLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiAhaXNVdWlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1J1bm5hYmxlSW50ZXJmYWNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTdHIgPSBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVN0ciA9IGRhdGFTdHIuc3RhcnRzV2l0aChcIlJ1bm5hYmxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFTdHIuc2xpY2UoXCJSdW5uYWJsZVwiLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YVN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5nZXROYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubmFtZSA/PyBcIlVua25vd25TY2hlbWFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdHMgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVzW2Rpc3BsYXlLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF9ub2RlRGF0YVN0cihzLmlkLCBzLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX25vZGVEYXRhU3RyKGUuaWQsIGUuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gd2Ugc3RvcCBzdXBwb3J0aW5nIGNvcmUgMC4yLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBncmFwaC5hZGROb2RlKG5vZGUsIGRpc3BsYXlLZXksIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2Rlc1tkaXNwbGF5S2V5XSA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGdyYXBoLmFkZE5vZGUobm9kZSwgZGlzcGxheUtleSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIGVuZE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRFZGdlcyA9IFsuLi50aGlzLmJ1aWxkZXIuYWxsRWRnZXNdLnNvcnQoKFthXSwgW2JdKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID4gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBzb3J0ZWRFZGdlcykge1xuICAgICAgICAgICAgYWRkRWRnZShfZXNjYXBlTWVybWFpZEtleXdvcmRzKHN0YXJ0KSwgX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgYnJhbmNoZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnVpbGRlci5icmFuY2hlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFbmRzID0ge1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyh0aGlzLmJ1aWxkZXIubm9kZXMpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGsgIT09IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChrKSA9PiBbX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrKSwgX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrKV0pKSxcbiAgICAgICAgICAgICAgICBbRU5EXTogRU5ELFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnJhbmNoIG9mIE9iamVjdC52YWx1ZXMoYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZHM7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaC5lbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcyA9IGJyYW5jaC5lbmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcyA9IGRlZmF1bHRFbmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtsYWJlbCwgZW5kXSBvZiBPYmplY3QuZW50cmllcyhlbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRFZGdlKF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoc3RhcnQpLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGVuZCksIGxhYmVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1aWxkZXIubm9kZXMpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5lbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuZCBvZiBub2RlLmVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRWRnZShfZXNjYXBlTWVybWFpZEtleXdvcmRzKGtleSksIF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoZW5kKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZHJhd2FibGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXB1dGF0aW9uIGdyYXBoLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGdldEdyYXBoQXN5bmMgaW5zdGVhZC4gVGhlIGFzeW5jIG1ldGhvZCB3aWxsIGJlIHRoZSBkZWZhdWx0IGluIHRoZSBuZXh0IG1pbm9yIGNvcmUgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBnZXRHcmFwaChjb25maWcpIHtcbiAgICAgICAgY29uc3QgeHJheSA9IGNvbmZpZz8ueHJheTtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgRHJhd2FibGVHcmFwaCgpO1xuICAgICAgICBjb25zdCBzdGFydE5vZGVzID0ge1xuICAgICAgICAgICAgW1NUQVJUXTogZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB6LmFueSgpLFxuICAgICAgICAgICAgfSwgU1RBUlQpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmROb2RlcyA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgc3ViZ3JhcGhzID0ge307XG4gICAgICAgIGlmICh4cmF5KSB7XG4gICAgICAgICAgICBzdWJncmFwaHMgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2F0aGVySXRlcmF0b3JTeW5jKHRoaXMuZ2V0U3ViZ3JhcGhzKCkpLmZpbHRlcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAoeCkgPT4gaXNDb21waWxlZEdyYXBoKHhbMV0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkRWRnZShzdGFydCwgZW5kLCBsYWJlbCwgY29uZGl0aW9uYWwgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gRU5EICYmIGVuZE5vZGVzW0VORF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVuZE5vZGVzW0VORF0gPSBncmFwaC5hZGROb2RlKHsgc2NoZW1hOiB6LmFueSgpIH0sIEVORCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGguYWRkRWRnZShzdGFydE5vZGVzW3N0YXJ0XSwgZW5kTm9kZXNbZW5kXSwgbGFiZWwgIT09IGVuZCA/IGxhYmVsIDogdW5kZWZpbmVkLCBjb25kaXRpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlU3BlY10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5idWlsZGVyLm5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheUtleSA9IF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlU3BlYy5ydW5uYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbm9kZVNwZWMubWV0YWRhdGEgPz8ge307XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnJ1cHRCZWZvcmU/LmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycnVwdEFmdGVyPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuX19pbnRlcnJ1cHQgPSBcImJlZm9yZSxhZnRlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbnRlcnJ1cHRCZWZvcmU/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5fX2ludGVycnVwdCA9IFwiYmVmb3JlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmludGVycnVwdEFmdGVyPy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuX19pbnRlcnJ1cHQgPSBcImFmdGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeHJheSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hyYXlWYWx1ZSA9IHR5cGVvZiB4cmF5ID09PSBcIm51bWJlclwiID8geHJheSAtIDEgOiB4cmF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdhYmxlU3ViZ3JhcGggPSBzdWJncmFwaHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gc3ViZ3JhcGhzW2tleV0uZ2V0R3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHJheTogbmV3WHJheVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGUuZ2V0R3JhcGgoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZVN1YmdyYXBoLnRyaW1GaXJzdE5vZGUoKTtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZVN1YmdyYXBoLnRyaW1MYXN0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhkcmF3YWJsZVN1YmdyYXBoLm5vZGVzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlLCBzXSA9IGdyYXBoLmV4dGVuZChkcmF3YWJsZVN1YmdyYXBoLCBkaXNwbGF5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0ZW5kIHN1YmdyYXBoIFwiJHtrZXl9XCIgZHVlIHRvIG1pc3NpbmcgZW50cnlwb2ludC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgZGVmYXVsdCBuYW1lIG9uY2Ugd2Ugc3RvcCBzdXBwb3J0aW5nIGNvcmUgMC4yLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaXNSdW5uYWJsZUludGVyZmFjZShcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgdGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZyA/IHRoaW5nLmxjX3J1bm5hYmxlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfbm9kZURhdGFTdHIoaWQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmICFpc1V1aWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzUnVubmFibGVJbnRlcmZhY2UoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVN0ciA9IGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU3RyID0gZGF0YVN0ci5zdGFydHNXaXRoKFwiUnVubmFibGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YVN0ci5zbGljZShcIlJ1bm5hYmxlXCIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lID8/IFwiVW5rbm93blNjaGVtYVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0cyB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXNbZGlzcGxheUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX25vZGVEYXRhU3RyKHMuaWQsIHMuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfbm9kZURhdGFTdHIoZS5pZCwgZS5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgY29yZSAwLjIuMFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGdyYXBoLmFkZE5vZGUobm9kZSwgZGlzcGxheUtleSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVzW2Rpc3BsYXlLZXldID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBjb3JlIDAuMi4wXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gZ3JhcGguYWRkTm9kZShub2RlLCBkaXNwbGF5S2V5LCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhcnROb2Rlc1tkaXNwbGF5S2V5XSA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgZW5kTm9kZXNbZGlzcGxheUtleV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZEVkZ2VzID0gWy4uLnRoaXMuYnVpbGRlci5hbGxFZGdlc10uc29ydCgoW2FdLCBbYl0pID0+IHtcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPiBhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHNvcnRlZEVkZ2VzKSB7XG4gICAgICAgICAgICBhZGRFZGdlKF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoc3RhcnQpLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBicmFuY2hlc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5idWlsZGVyLmJyYW5jaGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVuZHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHRoaXMuYnVpbGRlci5ub2RlcylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaykgPT4gayAhPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGspID0+IFtfZXNjYXBlTWVybWFpZEtleXdvcmRzKGspLCBfZXNjYXBlTWVybWFpZEtleXdvcmRzKGspXSkpLFxuICAgICAgICAgICAgICAgIFtFTkRdOiBFTkQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBicmFuY2ggb2YgT2JqZWN0LnZhbHVlcyhicmFuY2hlcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kcztcbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoLmVuZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRzID0gYnJhbmNoLmVuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmRzID0gZGVmYXVsdEVuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBlbmRdIG9mIE9iamVjdC5lbnRyaWVzKGVuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UoX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhzdGFydCksIF9lc2NhcGVNZXJtYWlkS2V5d29yZHMoZW5kKSwgbGFiZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzQ29tcGlsZWRHcmFwaCh4KSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHR5cGVvZiB4LmF0dGFjaE5vZGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0eXBlb2YgeC5hdHRhY2hFZGdlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2VzY2FwZU1lcm1haWRLZXl3b3JkcyhrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBcInN1YmdyYXBoXCIpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/graph.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/index.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/index.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* reexport safe */ _annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),\n/* harmony export */   AnnotationRoot: () => (/* reexport safe */ _annotation_js__WEBPACK_IMPORTED_MODULE_0__.AnnotationRoot),\n/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _state_js__WEBPACK_IMPORTED_MODULE_2__.CompiledStateGraph),\n/* harmony export */   Graph: () => (/* reexport safe */ _graph_js__WEBPACK_IMPORTED_MODULE_1__.Graph),\n/* harmony export */   MessageGraph: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.MessageGraph),\n/* harmony export */   StateGraph: () => (/* reexport safe */ _state_js__WEBPACK_IMPORTED_MODULE_2__.StateGraph),\n/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.messagesStateReducer)\n/* harmony export */ });\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/graph.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/state.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/message.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQzNCO0FBQzBCO0FBQ007QUFDbkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uUm9vdCwgfSBmcm9tIFwiLi9hbm5vdGF0aW9uLmpzXCI7XG5leHBvcnQgeyBHcmFwaCB9IGZyb20gXCIuL2dyYXBoLmpzXCI7XG5leHBvcnQgeyBTdGF0ZUdyYXBoLCBDb21waWxlZFN0YXRlR3JhcGgsIH0gZnJvbSBcIi4vc3RhdGUuanNcIjtcbmV4cG9ydCB7IE1lc3NhZ2VHcmFwaCwgbWVzc2FnZXNTdGF0ZVJlZHVjZXIsIH0gZnJvbSBcIi4vbWVzc2FnZS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/message.js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/message.js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageGraph: () => (/* binding */ MessageGraph),\n/* harmony export */   messagesStateReducer: () => (/* binding */ messagesStateReducer)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/messages */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/messages.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/state.js\");\n\n\n\n/**\n * Prebuilt reducer that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n */\nfunction messagesStateReducer(left, right) {\n    const leftArray = Array.isArray(left) ? left : [left];\n    const rightArray = Array.isArray(right) ? right : [right];\n    // coerce to message\n    const leftMessages = leftArray.map(_langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage);\n    const rightMessages = rightArray.map(_langchain_core_messages__WEBPACK_IMPORTED_MODULE_0__.coerceMessageLikeToMessage);\n    // assign missing ids\n    for (const m of leftMessages) {\n        if (m.id === null || m.id === undefined) {\n            m.id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            m.lc_kwargs.id = m.id;\n        }\n    }\n    for (const m of rightMessages) {\n        if (m.id === null || m.id === undefined) {\n            m.id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            m.lc_kwargs.id = m.id;\n        }\n    }\n    // merge\n    const merged = [...leftMessages];\n    const mergedById = new Map(merged.map((m, i) => [m.id, i]));\n    const idsToRemove = new Set();\n    for (const m of rightMessages) {\n        const existingIdx = mergedById.get(m.id);\n        if (existingIdx !== undefined) {\n            if (m._getType() === \"remove\") {\n                idsToRemove.add(m.id);\n            }\n            else {\n                idsToRemove.delete(m.id);\n                merged[existingIdx] = m;\n            }\n        }\n        else {\n            if (m._getType() === \"remove\") {\n                throw new Error(`Attempting to delete a message with an ID that doesn't exist ('${m.id}')`);\n            }\n            mergedById.set(m.id, merged.length);\n            merged.push(m);\n        }\n    }\n    return merged.filter((m) => !idsToRemove.has(m.id));\n}\n/** @ignore */\nclass MessageGraph extends _state_js__WEBPACK_IMPORTED_MODULE_1__.StateGraph {\n    constructor() {\n        super({\n            channels: {\n                __root__: {\n                    reducer: messagesStateReducer,\n                    default: () => [],\n                },\n            },\n        });\n    }\n}\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUU7QUFDN0M7QUFDYztBQUN4QztBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnRkFBMEI7QUFDakUseUNBQXlDLGdGQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLEtBQUs7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixpREFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9ncmFwaC9tZXNzYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbmltcG9ydCB7IHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IFN0YXRlR3JhcGggfSBmcm9tIFwiLi9zdGF0ZS5qc1wiO1xuLyoqXG4gKiBQcmVidWlsdCByZWR1Y2VyIHRoYXQgY29tYmluZXMgcmV0dXJuZWQgbWVzc2FnZXMuXG4gKiBDYW4gaGFuZGxlIHN0YW5kYXJkIG1lc3NhZ2VzIGFuZCBzcGVjaWFsIG1vZGlmaWVycyBsaWtlIHtAbGluayBSZW1vdmVNZXNzYWdlfVxuICogaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVzc2FnZXNTdGF0ZVJlZHVjZXIobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0QXJyYXkgPSBBcnJheS5pc0FycmF5KGxlZnQpID8gbGVmdCA6IFtsZWZ0XTtcbiAgICBjb25zdCByaWdodEFycmF5ID0gQXJyYXkuaXNBcnJheShyaWdodCkgPyByaWdodCA6IFtyaWdodF07XG4gICAgLy8gY29lcmNlIHRvIG1lc3NhZ2VcbiAgICBjb25zdCBsZWZ0TWVzc2FnZXMgPSBsZWZ0QXJyYXkubWFwKGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKTtcbiAgICBjb25zdCByaWdodE1lc3NhZ2VzID0gcmlnaHRBcnJheS5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpO1xuICAgIC8vIGFzc2lnbiBtaXNzaW5nIGlkc1xuICAgIGZvciAoY29uc3QgbSBvZiBsZWZ0TWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKG0uaWQgPT09IG51bGwgfHwgbS5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtLmlkID0gdjQoKTtcbiAgICAgICAgICAgIG0ubGNfa3dhcmdzLmlkID0gbS5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG0gb2YgcmlnaHRNZXNzYWdlcykge1xuICAgICAgICBpZiAobS5pZCA9PT0gbnVsbCB8fCBtLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG0uaWQgPSB2NCgpO1xuICAgICAgICAgICAgbS5sY19rd2FyZ3MuaWQgPSBtLmlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1lcmdlXG4gICAgY29uc3QgbWVyZ2VkID0gWy4uLmxlZnRNZXNzYWdlc107XG4gICAgY29uc3QgbWVyZ2VkQnlJZCA9IG5ldyBNYXAobWVyZ2VkLm1hcCgobSwgaSkgPT4gW20uaWQsIGldKSk7XG4gICAgY29uc3QgaWRzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtIG9mIHJpZ2h0TWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJZHggPSBtZXJnZWRCeUlkLmdldChtLmlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtLl9nZXRUeXBlKCkgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICBpZHNUb1JlbW92ZS5hZGQobS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZHNUb1JlbW92ZS5kZWxldGUobS5pZCk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2V4aXN0aW5nSWR4XSA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobS5fZ2V0VHlwZSgpID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIGRlbGV0ZSBhIG1lc3NhZ2Ugd2l0aCBhbiBJRCB0aGF0IGRvZXNuJ3QgZXhpc3QgKCcke20uaWR9JylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZEJ5SWQuc2V0KG0uaWQsIG1lcmdlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZC5maWx0ZXIoKG0pID0+ICFpZHNUb1JlbW92ZS5oYXMobS5pZCkpO1xufVxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlR3JhcGggZXh0ZW5kcyBTdGF0ZUdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgICAgICBfX3Jvb3RfXzoge1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2VyOiBtZXNzYWdlc1N0YXRlUmVkdWNlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4gW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/messages_annotation.js":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/messages_annotation.js ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessagesAnnotation: () => (/* binding */ MessagesAnnotation)\n/* harmony export */ });\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/message.js\");\n/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n\n/**\n * Prebuilt state annotation that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n *\n * Specifically, importing and using the prebuilt MessagesAnnotation like this:\n *\n * @example\n * ```ts\n * import { MessagesAnnotation, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Is equivalent to initializing your state manually like this:\n *\n * @example\n * ```ts\n * import { BaseMessage } from \"@langchain/core/messages\";\n * import { Annotation, StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n *\n * export const StateAnnotation = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: messagesStateReducer,\n *     default: () => [],\n *   }),\n * });\n *\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n */\nconst MessagesAnnotation = _annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation.Root({\n    messages: (0,_annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation)({\n        reducer: _message_js__WEBPACK_IMPORTED_MODULE_1__.messagesStateReducer,\n        default: () => [],\n    }),\n});\n//# sourceMappingURL=messages_annotation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL21lc3NhZ2VzX2Fubm90YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDNkM7QUFDTztBQUNwRDtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixzREFBVTtBQUM1QyxjQUFjLDBEQUFVO0FBQ3hCLGlCQUFpQiw2REFBb0I7QUFDckM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvZ3JhcGgvbWVzc2FnZXNfYW5ub3RhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBfX0xDX0FMTE9XX0VOVFJZUE9JTlRfU0lERV9FRkZFQ1RTX18gKi9cbmltcG9ydCB7IEFubm90YXRpb24gfSBmcm9tIFwiLi9hbm5vdGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBtZXNzYWdlc1N0YXRlUmVkdWNlciB9IGZyb20gXCIuL21lc3NhZ2UuanNcIjtcbi8qKlxuICogUHJlYnVpbHQgc3RhdGUgYW5ub3RhdGlvbiB0aGF0IGNvbWJpbmVzIHJldHVybmVkIG1lc3NhZ2VzLlxuICogQ2FuIGhhbmRsZSBzdGFuZGFyZCBtZXNzYWdlcyBhbmQgc3BlY2lhbCBtb2RpZmllcnMgbGlrZSB7QGxpbmsgUmVtb3ZlTWVzc2FnZX1cbiAqIGluc3RhbmNlcy5cbiAqXG4gKiBTcGVjaWZpY2FsbHksIGltcG9ydGluZyBhbmQgdXNpbmcgdGhlIHByZWJ1aWx0IE1lc3NhZ2VzQW5ub3RhdGlvbiBsaWtlIHRoaXM6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBNZXNzYWdlc0Fubm90YXRpb24sIFN0YXRlR3JhcGggfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqXG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKE1lc3NhZ2VzQW5ub3RhdGlvbilcbiAqICAgLmFkZE5vZGUoLi4uKVxuICogICAuLi5cbiAqIGBgYFxuICpcbiAqIElzIGVxdWl2YWxlbnQgdG8gaW5pdGlhbGl6aW5nIHlvdXIgc3RhdGUgbWFudWFsbHkgbGlrZSB0aGlzOlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQmFzZU1lc3NhZ2UgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCI7XG4gKiBpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUdyYXBoLCBtZXNzYWdlc1N0YXRlUmVkdWNlciB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICpcbiAqIGV4cG9ydCBjb25zdCBTdGF0ZUFubm90YXRpb24gPSBBbm5vdGF0aW9uLlJvb3Qoe1xuICogICBtZXNzYWdlczogQW5ub3RhdGlvbjxCYXNlTWVzc2FnZVtdPih7XG4gKiAgICAgcmVkdWNlcjogbWVzc2FnZXNTdGF0ZVJlZHVjZXIsXG4gKiAgICAgZGVmYXVsdDogKCkgPT4gW10sXG4gKiAgIH0pLFxuICogfSk7XG4gKlxuICogY29uc3QgZ3JhcGggPSBuZXcgU3RhdGVHcmFwaChTdGF0ZUFubm90YXRpb24pXG4gKiAgIC5hZGROb2RlKC4uLilcbiAqICAgLi4uXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IE1lc3NhZ2VzQW5ub3RhdGlvbiA9IEFubm90YXRpb24uUm9vdCh7XG4gICAgbWVzc2FnZXM6IEFubm90YXRpb24oe1xuICAgICAgICByZWR1Y2VyOiBtZXNzYWdlc1N0YXRlUmVkdWNlcixcbiAgICAgICAgZGVmYXVsdDogKCkgPT4gW10sXG4gICAgfSksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VzX2Fubm90YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/messages_annotation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/state.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/state.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompiledStateGraph: () => (/* binding */ CompiledStateGraph),\n/* harmony export */   StateGraph: () => (/* binding */ StateGraph)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/graph.js\");\n/* harmony import */ var _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pregel/write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pregel/read.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _channels_named_barrier_value_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../channels/named_barrier_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.js\");\n/* harmony import */ var _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../channels/ephemeral_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _annotation_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./annotation.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/annotation.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../managed/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../pregel/utils/subgraph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* harmony import */ var _zod_state_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zod/state.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/zod/state.js\");\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ROOT = \"__root__\";\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nclass StateGraph extends _graph_js__WEBPACK_IMPORTED_MODULE_2__.Graph {\n    constructor(fields, configSchema) {\n        super();\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n        Object.defineProperty(this, \"waitingEdges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_schemaDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_schemaRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_inputDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_inputRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_outputDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_outputRuntimeDefinition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Map schemas to managed values\n         * @internal\n         */\n        Object.defineProperty(this, \"_schemaDefinitions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        /** @internal Used only for typing. */\n        Object.defineProperty(this, \"_configSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @internal */\n        Object.defineProperty(this, \"_configRuntimeSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (isZodStateGraphArgsWithStateSchema(fields)) {\n            const stateDef = (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.state);\n            const inputDef = fields.input != null ? (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.input) : stateDef;\n            const outputDef = fields.output != null ? (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields.output) : stateDef;\n            this._schemaDefinition = stateDef;\n            this._schemaRuntimeDefinition = fields.state;\n            this._inputDefinition = inputDef;\n            this._inputRuntimeDefinition = fields.input ?? fields.state.partial();\n            this._outputDefinition = outputDef;\n            this._outputRuntimeDefinition = fields.output ?? fields.state;\n        }\n        else if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(fields)) {\n            const stateDef = (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.getChannelsFromZod)(fields);\n            this._schemaDefinition = stateDef;\n            this._schemaRuntimeDefinition = fields;\n            this._inputDefinition = stateDef;\n            this._inputRuntimeDefinition = fields.partial();\n            this._outputDefinition = stateDef;\n            this._outputRuntimeDefinition = fields;\n        }\n        else if (isStateGraphArgsWithInputOutputSchemas(fields)) {\n            this._schemaDefinition = fields.input.spec;\n            this._inputDefinition = fields.input.spec;\n            this._outputDefinition = fields.output.spec;\n        }\n        else if (isStateGraphArgsWithStateSchema(fields)) {\n            this._schemaDefinition = fields.stateSchema.spec;\n            this._inputDefinition = (fields.input?.spec ??\n                this._schemaDefinition);\n            this._outputDefinition = (fields.output?.spec ??\n                this._schemaDefinition);\n        }\n        else if (isStateDefinition(fields) || isAnnotationRoot(fields)) {\n            const spec = isAnnotationRoot(fields) ? fields.spec : fields;\n            this._schemaDefinition = spec;\n        }\n        else if (isStateGraphArgs(fields)) {\n            const spec = _getChannels(fields.channels);\n            this._schemaDefinition = spec;\n        }\n        else {\n            throw new Error(\"Invalid StateGraph input.\");\n        }\n        this._inputDefinition ??= this._schemaDefinition;\n        this._outputDefinition ??= this._schemaDefinition;\n        this._addSchema(this._schemaDefinition);\n        this._addSchema(this._inputDefinition);\n        this._addSchema(this._outputDefinition);\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(configSchema)) {\n            this._configRuntimeSchema = configSchema.passthrough();\n        }\n    }\n    get allEdges() {\n        return new Set([\n            ...this.edges,\n            ...Array.from(this.waitingEdges).flatMap(([starts, end]) => starts.map((start) => [start, end])),\n        ]);\n    }\n    _addSchema(stateDefinition) {\n        if (this._schemaDefinitions.has(stateDefinition)) {\n            return;\n        }\n        // TODO: Support managed values\n        this._schemaDefinitions.set(stateDefinition, stateDefinition);\n        for (const [key, val] of Object.entries(stateDefinition)) {\n            let channel;\n            if (typeof val === \"function\") {\n                channel = val();\n            }\n            else {\n                channel = val;\n            }\n            if (this.channels[key] !== undefined) {\n                if (this.channels[key] !== channel) {\n                    if (!(0,_managed_base_js__WEBPACK_IMPORTED_MODULE_11__.isConfiguredManagedValue)(channel) &&\n                        channel.lc_graph_name !== \"LastValue\") {\n                        throw new Error(`Channel \"${key}\" already exists with a different type.`);\n                    }\n                }\n            }\n            else {\n                this.channels[key] = channel;\n            }\n        }\n    }\n    addNode(key, action, options) {\n        if (key in this.channels) {\n            throw new Error(`${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);\n        }\n        for (const reservedChar of [\n            _constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR,\n            _constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_END,\n        ]) {\n            if (key.includes(reservedChar)) {\n                throw new Error(`\"${reservedChar}\" is a reserved character and is not allowed in node names.`);\n            }\n        }\n        this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);\n        if (key in this.nodes) {\n            throw new Error(`Node \\`${key}\\` already present.`);\n        }\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END || key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            throw new Error(`Node \\`${key}\\` is reserved.`);\n        }\n        if (options?.input !== undefined) {\n            this._addSchema(options.input.spec);\n        }\n        let runnable;\n        if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(action)) {\n            runnable = action;\n        }\n        else if (typeof action === \"function\") {\n            runnable = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n                func: action,\n                name: key,\n                trace: false,\n            });\n        }\n        else {\n            runnable = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(action);\n        }\n        const nodeSpec = {\n            runnable: runnable,\n            retryPolicy: options?.retryPolicy,\n            metadata: options?.metadata,\n            input: options?.input?.spec ?? this._schemaDefinition,\n            subgraphs: (0,_pregel_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__.isPregelLike)(runnable)\n                ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    [runnable]\n                : options?.subgraphs,\n            ends: options?.ends,\n        };\n        this.nodes[key] = nodeSpec;\n        return this;\n    }\n    addEdge(startKey, endKey) {\n        if (typeof startKey === \"string\") {\n            return super.addEdge(startKey, endKey);\n        }\n        if (this.compiled) {\n            console.warn(\"Adding an edge to a graph that has already been compiled. This will \" +\n                \"not be reflected in the compiled graph.\");\n        }\n        for (const start of startKey) {\n            if (start === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n                throw new Error(\"END cannot be a start node\");\n            }\n            if (!Object.keys(this.nodes).some((node) => node === start)) {\n                throw new Error(`Need to add a node named \"${start}\" first`);\n            }\n        }\n        if (endKey === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n            throw new Error(\"END cannot be an end node\");\n        }\n        if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n            throw new Error(`Need to add a node named \"${endKey}\" first`);\n        }\n        this.waitingEdges.add([startKey, endKey]);\n        return this;\n    }\n    compile({ checkpointer, store, interruptBefore, interruptAfter, name, } = {}) {\n        // validate the graph\n        this.validate([\n            ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n            ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n        ]);\n        // prepare output channels\n        const outputKeys = Object.keys(this._schemaDefinitions.get(this._outputDefinition));\n        const outputChannels = outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n        const streamKeys = Object.keys(this.channels);\n        const streamChannels = streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n        // create empty compiled graph\n        const compiled = new CompiledStateGraph({\n            builder: this,\n            checkpointer,\n            interruptAfter,\n            interruptBefore,\n            autoValidate: false,\n            nodes: {},\n            channels: {\n                ...this.channels,\n                [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START]: new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue(),\n            },\n            inputChannels: _constants_js__WEBPACK_IMPORTED_MODULE_8__.START,\n            outputChannels,\n            streamChannels,\n            streamMode: \"updates\",\n            store,\n            name,\n        });\n        // attach nodes, edges and branches\n        compiled.attachNode(_constants_js__WEBPACK_IMPORTED_MODULE_8__.START);\n        for (const [key, node] of Object.entries(this.nodes)) {\n            compiled.attachNode(key, node);\n        }\n        compiled.attachBranch(_constants_js__WEBPACK_IMPORTED_MODULE_8__.START, _constants_js__WEBPACK_IMPORTED_MODULE_8__.SELF, _getControlBranch(), {\n            withReader: false,\n        });\n        for (const [key] of Object.entries(this.nodes)) {\n            compiled.attachBranch(key, _constants_js__WEBPACK_IMPORTED_MODULE_8__.SELF, _getControlBranch(), {\n                withReader: false,\n            });\n        }\n        for (const [start, end] of this.edges) {\n            compiled.attachEdge(start, end);\n        }\n        for (const [starts, end] of this.waitingEdges) {\n            compiled.attachEdge(starts, end);\n        }\n        for (const [start, branches] of Object.entries(this.branches)) {\n            for (const [name, branch] of Object.entries(branches)) {\n                compiled.attachBranch(start, name, branch);\n            }\n        }\n        return compiled.validate();\n    }\n}\nfunction _getChannels(schema) {\n    const channels = {};\n    for (const [name, val] of Object.entries(schema)) {\n        if (name === ROOT) {\n            channels[name] = (0,_annotation_js__WEBPACK_IMPORTED_MODULE_10__.getChannel)(val);\n        }\n        else {\n            const key = name;\n            channels[name] = (0,_annotation_js__WEBPACK_IMPORTED_MODULE_10__.getChannel)(val);\n        }\n    }\n    return channels;\n}\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nclass CompiledStateGraph extends _graph_js__WEBPACK_IMPORTED_MODULE_2__.CompiledGraph {\n    attachNode(key, node) {\n        let outputKeys;\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            // Get input schema keys excluding managed values\n            outputKeys = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition))\n                .filter(([_, v]) => !(0,_managed_base_js__WEBPACK_IMPORTED_MODULE_11__.isConfiguredManagedValue)(v))\n                .map(([k]) => k);\n        }\n        else {\n            outputKeys = Object.keys(this.builder.channels);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function _getRoot(input) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n                if (input.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                    return null;\n                }\n                return input._updateAsTuples();\n            }\n            else if (Array.isArray(input) &&\n                input.length > 0 &&\n                input.some((i) => (0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(i))) {\n                const updates = [];\n                for (const i of input) {\n                    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(i)) {\n                        if (i.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                            continue;\n                        }\n                        updates.push(...i._updateAsTuples());\n                    }\n                    else {\n                        updates.push([ROOT, i]);\n                    }\n                }\n                return updates;\n            }\n            else if (input != null) {\n                return [[ROOT, input]];\n            }\n            return null;\n        }\n        // to avoid name collision below\n        const nodeKey = key;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function _getUpdates(input) {\n            if (!input) {\n                return null;\n            }\n            else if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n                if (input.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                    return null;\n                }\n                return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n            }\n            else if (Array.isArray(input) &&\n                input.length > 0 &&\n                input.some(_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)) {\n                const updates = [];\n                for (const item of input) {\n                    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(item)) {\n                        if (item.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n                            continue;\n                        }\n                        updates.push(...item._updateAsTuples().filter(([k]) => outputKeys.includes(k)));\n                    }\n                    else {\n                        const itemUpdates = _getUpdates(item);\n                        if (itemUpdates) {\n                            updates.push(...(itemUpdates ?? []));\n                        }\n                    }\n                }\n                return updates;\n            }\n            else if (typeof input === \"object\" && !Array.isArray(input)) {\n                return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n            }\n            else {\n                const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`, {\n                    lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n                });\n            }\n        }\n        const stateWriteEntries = [\n            {\n                value: _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.PASSTHROUGH,\n                mapper: new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n                    func: outputKeys.length && outputKeys[0] === ROOT\n                        ? _getRoot\n                        : _getUpdates,\n                    trace: false,\n                    recurse: false,\n                }),\n            },\n        ];\n        // add node and output channel\n        if (key === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.PregelNode({\n                tags: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN],\n                triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START],\n                channels: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.START],\n                writers: [new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite(stateWriteEntries, [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN])],\n            });\n        }\n        else {\n            const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n            const inputValues = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map((k) => [k, k]));\n            const isSingleInput = Object.keys(inputValues).length === 1 && ROOT in inputValues;\n            this.channels[key] = new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue(false);\n            this.nodes[key] = new _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.PregelNode({\n                triggers: [],\n                // read state keys\n                channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n                // publish to this channel and state keys\n                writers: [\n                    new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite(stateWriteEntries.concat({ channel: key, value: key }), [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]),\n                ],\n                mapper: isSingleInput\n                    ? undefined\n                    : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (input) => {\n                            return Object.fromEntries(Object.entries(input).filter(([k]) => k in inputValues));\n                        },\n                bound: node?.runnable,\n                metadata: node?.metadata,\n                retryPolicy: node?.retryPolicy,\n                subgraphs: node?.subgraphs,\n                ends: node?.ends,\n            });\n        }\n    }\n    attachEdge(start, end) {\n        if (end === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n            return;\n        }\n        if (Array.isArray(start)) {\n            const channelName = `join:${start.join(\"+\")}:${end}`;\n            // register channel\n            this.channels[channelName] =\n                new _channels_named_barrier_value_js__WEBPACK_IMPORTED_MODULE_5__.NamedBarrierValue(new Set(start));\n            // subscribe to channel\n            this.nodes[end].triggers.push(channelName);\n            // publish to channel\n            for (const s of start) {\n                this.nodes[s].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: channelName, value: s }], [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]));\n            }\n        }\n        else if (start === _constants_js__WEBPACK_IMPORTED_MODULE_8__.START) {\n            const channelName = `${_constants_js__WEBPACK_IMPORTED_MODULE_8__.START}:${end}`;\n            // register channel\n            this.channels[channelName] =\n                new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue();\n            // subscribe to channel\n            this.nodes[end].triggers.push(channelName);\n            // publish to channel\n            this.nodes[_constants_js__WEBPACK_IMPORTED_MODULE_8__.START].writers.push(new _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: channelName, value: _constants_js__WEBPACK_IMPORTED_MODULE_8__.START }], [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]));\n        }\n        else {\n            this.nodes[end].triggers.push(start);\n        }\n    }\n    attachBranch(start, name, branch, options = { withReader: true }) {\n        const branchWriter = async (packets, config) => {\n            const filteredPackets = packets.filter((p) => p !== _constants_js__WEBPACK_IMPORTED_MODULE_8__.END);\n            if (!filteredPackets.length) {\n                return;\n            }\n            const writes = filteredPackets.map((p) => {\n                if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(p)) {\n                    return p;\n                }\n                return {\n                    channel: `branch:${start}:${name}:${p}`,\n                    value: start,\n                };\n            });\n            await _pregel_write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite.doWrite({ ...config, tags: (config.tags ?? []).concat([_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN]) }, writes);\n        };\n        // attach branch publisher\n        this.nodes[start].writers.push(branch.run(branchWriter, \n        // reader\n        options.withReader\n            ? (config) => _pregel_read_js__WEBPACK_IMPORTED_MODULE_4__.ChannelRead.doRead(config, this.streamChannels ?? this.outputChannels, true)\n            : undefined));\n        // attach branch subscribers\n        const ends = branch.ends\n            ? Object.values(branch.ends)\n            : Object.keys(this.builder.nodes);\n        for (const end of ends) {\n            if (end === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n                continue;\n            }\n            const channelName = `branch:${start}:${name}:${end}`;\n            this.channels[channelName] =\n                new _channels_ephemeral_value_js__WEBPACK_IMPORTED_MODULE_6__.EphemeralValue(false);\n            this.nodes[end].triggers.push(channelName);\n        }\n    }\n    async _validateInput(input) {\n        const inputSchema = this.builder._inputRuntimeDefinition;\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(input)) {\n            const parsedInput = input;\n            if (input.update && (0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(inputSchema))\n                parsedInput.update = inputSchema.parse(input.update);\n            return parsedInput;\n        }\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(inputSchema))\n            return inputSchema.parse(input);\n        return input;\n    }\n    async _validateConfigurable(config) {\n        const configSchema = this.builder._configRuntimeSchema;\n        if ((0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(configSchema))\n            configSchema.parse(config);\n        return config;\n    }\n}\nfunction isStateDefinition(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        !Array.isArray(obj) &&\n        Object.keys(obj).length > 0 &&\n        Object.values(obj).every((v) => typeof v === \"function\" || (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseChannel)(v)));\n}\nfunction isAnnotationRoot(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        \"lc_graph_name\" in obj &&\n        obj.lc_graph_name === \"AnnotationRoot\");\n}\nfunction isStateGraphArgs(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        obj.channels !== undefined);\n}\nfunction isStateGraphArgsWithStateSchema(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        obj.stateSchema !== undefined);\n}\nfunction isStateGraphArgsWithInputOutputSchemas(obj) {\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj.stateSchema === undefined &&\n        obj.input !== undefined &&\n        obj.output !== undefined);\n}\nfunction isZodStateGraphArgsWithStateSchema(value) {\n    if (typeof value !== \"object\" || value == null) {\n        return false;\n    }\n    if (!(\"state\" in value) || !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.state)) {\n        return false;\n    }\n    if (\"input\" in value && !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.input)) {\n        return false;\n    }\n    if (\"output\" in value && !(0,_zod_state_js__WEBPACK_IMPORTED_MODULE_13__.isAnyZodObject)(value.output)) {\n        return false;\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value) {\n    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(value)) {\n        return [value];\n    }\n    const commands = [];\n    if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand)(value)) {\n        commands.push(value);\n    }\n    else if (Array.isArray(value)) {\n        commands.push(...value.filter(_constants_js__WEBPACK_IMPORTED_MODULE_8__.isCommand));\n    }\n    const destinations = [];\n    for (const command of commands) {\n        if (command.graph === _constants_js__WEBPACK_IMPORTED_MODULE_8__.Command.PARENT) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.ParentCommand(command);\n        }\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_8__._isSend)(command.goto)) {\n            destinations.push(command.goto);\n        }\n        else if (typeof command.goto === \"string\") {\n            destinations.push(command.goto);\n        }\n        else {\n            if (Array.isArray(command.goto)) {\n                destinations.push(...command.goto);\n            }\n        }\n    }\n    return destinations;\n}\nfunction _getControlBranch() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const CONTROL_BRANCH_PATH = new _utils_js__WEBPACK_IMPORTED_MODULE_7__.RunnableCallable({\n        func: _controlBranch,\n        tags: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.TAG_HIDDEN],\n        trace: false,\n        recurse: false,\n        name: \"<control_branch>\",\n    });\n    return new _graph_js__WEBPACK_IMPORTED_MODULE_2__.Branch({\n        path: CONTROL_BRANCH_PATH,\n    });\n}\n//# sourceMappingURL=state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL3N0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5RTtBQUNyQjtBQUNPO0FBQ0s7QUFDSjtBQUNXO0FBQ1A7QUFDakI7QUFDd0c7QUFDdEY7QUFDbkI7QUFDZ0I7QUFDSDtBQUNVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBOEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsNENBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLGtFQUFrQjtBQUMvQyxvREFBb0Qsa0VBQWtCO0FBQ3RFLHNEQUFzRCxrRUFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWM7QUFDL0IsNkJBQTZCLGtFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyRUFBd0I7QUFDakQ7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQSxZQUFZLHlFQUE4QjtBQUMxQyxZQUFZLG1FQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBLG9CQUFvQiw4Q0FBRyxZQUFZLGdEQUFLO0FBQ3hDLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsNEVBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3RUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxNQUFNO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUE4RCxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixnREFBSyxPQUFPLHdFQUFjO0FBQzNDLGFBQWE7QUFDYiwyQkFBMkIsZ0RBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QixnREFBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQUssRUFBRSwrQ0FBSTtBQUN6QztBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywrQ0FBSTtBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ08saUNBQWlDLG9EQUFhO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQUs7QUFDekI7QUFDQTtBQUNBLHFDQUFxQywyRUFBd0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVM7QUFDekIsb0NBQW9DLGtEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBUztBQUMzQztBQUNBO0FBQ0Esd0JBQXdCLHdEQUFTO0FBQ2pDLHdDQUF3QyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBUztBQUM5QixvQ0FBb0Msa0RBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFTO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakMsMkNBQTJDLGtEQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBa0IsbUJBQW1CLG1CQUFtQixxRkFBcUYsWUFBWTtBQUNuTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVztBQUNsQyw0QkFBNEIsdURBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQUs7QUFDekIsa0NBQWtDLHVEQUFVO0FBQzVDLHVCQUF1QixxREFBVTtBQUNqQywyQkFBMkIsZ0RBQUs7QUFDaEMsMkJBQTJCLGdEQUFLO0FBQ2hDLDhCQUE4QiwwREFBWSxxQkFBcUIscURBQVU7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQWM7QUFDbkQsa0NBQWtDLHVEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVksNEJBQTRCLDBCQUEwQixJQUFJLHFEQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCLEdBQUcsSUFBSTtBQUMvRDtBQUNBO0FBQ0Esb0JBQW9CLCtFQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwREFBWSxJQUFJLGdDQUFnQyxJQUFJLHFEQUFVO0FBQzdHO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQUs7QUFDaEMsbUNBQW1DLGdEQUFLLENBQUMsR0FBRyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQSxvQkFBb0Isd0VBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFLLG1CQUFtQiwwREFBWSxJQUFJLDZCQUE2QixnREFBSyxFQUFFLElBQUkscURBQVU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQSxnRUFBZ0UsOENBQUc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU0sR0FBRyxLQUFLLEdBQUcsRUFBRTtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCQUFrQiwwREFBWSxXQUFXLDZDQUE2QyxxREFBVSxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFHO0FBQzNCO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTSxHQUFHLEtBQUssR0FBRyxJQUFJO0FBQy9EO0FBQ0Esb0JBQW9CLHdFQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFTO0FBQ3JCO0FBQ0EsZ0NBQWdDLDhEQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdFQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQWM7QUFDOUM7QUFDQTtBQUNBLDZCQUE2Qiw4REFBYztBQUMzQztBQUNBO0FBQ0EsOEJBQThCLDhEQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvREFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQU87QUFDckMsc0JBQXNCLHFEQUFhO0FBQ25DO0FBQ0EsWUFBWSxzREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQWdCO0FBQ3BEO0FBQ0EsZUFBZSxxREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSw2Q0FBTTtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvZ3JhcGgvc3RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgeyBfY29lcmNlVG9SdW5uYWJsZSwgUnVubmFibGUsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IGlzQmFzZUNoYW5uZWwgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29tcGlsZWRHcmFwaCwgR3JhcGgsIEJyYW5jaCwgfSBmcm9tIFwiLi9ncmFwaC5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlLCBQQVNTVEhST1VHSCwgfSBmcm9tIFwiLi4vcHJlZ2VsL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBDaGFubmVsUmVhZCwgUHJlZ2VsTm9kZSB9IGZyb20gXCIuLi9wcmVnZWwvcmVhZC5qc1wiO1xuaW1wb3J0IHsgTmFtZWRCYXJyaWVyVmFsdWUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvbmFtZWRfYmFycmllcl92YWx1ZS5qc1wiO1xuaW1wb3J0IHsgRXBoZW1lcmFsVmFsdWUgfSBmcm9tIFwiLi4vY2hhbm5lbHMvZXBoZW1lcmFsX3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZUNhbGxhYmxlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBpc0NvbW1hbmQsIF9pc1NlbmQsIENIRUNLUE9JTlRfTkFNRVNQQUNFX0VORCwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLCBDb21tYW5kLCBFTkQsIFNFTEYsIFNUQVJULCBUQUdfSElEREVOLCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEludmFsaWRVcGRhdGVFcnJvciwgUGFyZW50Q29tbWFuZCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldENoYW5uZWwsIH0gZnJvbSBcIi4vYW5ub3RhdGlvbi5qc1wiO1xuaW1wb3J0IHsgaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlIH0gZnJvbSBcIi4uL21hbmFnZWQvYmFzZS5qc1wiO1xuaW1wb3J0IHsgaXNQcmVnZWxMaWtlIH0gZnJvbSBcIi4uL3ByZWdlbC91dGlscy9zdWJncmFwaC5qc1wiO1xuaW1wb3J0IHsgZ2V0Q2hhbm5lbHNGcm9tWm9kLCBpc0FueVpvZE9iamVjdCwgfSBmcm9tIFwiLi96b2Qvc3RhdGUuanNcIjtcbmNvbnN0IFJPT1QgPSBcIl9fcm9vdF9fXCI7XG4vKipcbiAqIEEgZ3JhcGggd2hvc2Ugbm9kZXMgY29tbXVuaWNhdGUgYnkgcmVhZGluZyBhbmQgd3JpdGluZyB0byBhIHNoYXJlZCBzdGF0ZS5cbiAqIEVhY2ggbm9kZSB0YWtlcyBhIGRlZmluZWQgYFN0YXRlYCBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIGBQYXJ0aWFsPFN0YXRlPmAuXG4gKlxuICogRWFjaCBzdGF0ZSBrZXkgY2FuIG9wdGlvbmFsbHkgYmUgYW5ub3RhdGVkIHdpdGggYSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXRcbiAqIHdpbGwgYmUgdXNlZCB0byBhZ2dyZWdhdGUgdGhlIHZhbHVlcyBvZiB0aGF0IGtleSByZWNlaXZlZCBmcm9tIG11bHRpcGxlIG5vZGVzLlxuICogVGhlIHNpZ25hdHVyZSBvZiBhIHJlZHVjZXIgZnVuY3Rpb24gaXMgKGxlZnQ6IFZhbHVlLCByaWdodDogVXBkYXRlVmFsdWUpID0+IFZhbHVlLlxuICpcbiAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbn0gZm9yIG1vcmUgb24gZGVmaW5pbmcgc3RhdGUuXG4gKlxuICogQWZ0ZXIgYWRkaW5nIG5vZGVzIGFuZCBlZGdlcyB0byB5b3VyIGdyYXBoLCB5b3UgbXVzdCBjYWxsIGAuY29tcGlsZSgpYCBvbiBpdCBiZWZvcmVcbiAqIHlvdSBjYW4gdXNlIGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgdHlwZSBCYXNlTWVzc2FnZSxcbiAqICAgQUlNZXNzYWdlLFxuICogICBIdW1hbk1lc3NhZ2UsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbiAqIGltcG9ydCB7IFN0YXRlR3JhcGgsIEFubm90YXRpb24gfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGhcIjtcbiAqXG4gKiAvLyBEZWZpbmUgYSBzdGF0ZSB3aXRoIGEgc2luZ2xlIGtleSBuYW1lZCBcIm1lc3NhZ2VzXCIgdGhhdCB3aWxsXG4gKiAvLyBjb21iaW5lIGEgcmV0dXJuZWQgQmFzZU1lc3NhZ2Ugb3IgYXJyYXlzIG9mIEJhc2VNZXNzYWdlc1xuICogY29uc3QgU3RhdGVBbm5vdGF0aW9uID0gQW5ub3RhdGlvbi5Sb290KHtcbiAqICAgc2VudGltZW50OiBBbm5vdGF0aW9uPHN0cmluZz4sXG4gKiAgIG1lc3NhZ2VzOiBBbm5vdGF0aW9uPEJhc2VNZXNzYWdlW10+KHtcbiAqICAgICByZWR1Y2VyOiAobGVmdDogQmFzZU1lc3NhZ2VbXSwgcmlnaHQ6IEJhc2VNZXNzYWdlIHwgQmFzZU1lc3NhZ2VbXSkgPT4ge1xuICogICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gKiAgICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gbGVmdC5jb25jYXQoW3JpZ2h0XSk7XG4gKiAgICAgfSxcbiAqICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAqICAgfSksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBncmFwaEJ1aWxkZXIgPSBuZXcgU3RhdGVHcmFwaChTdGF0ZUFubm90YXRpb24pO1xuICpcbiAqIC8vIEEgbm9kZSBpbiB0aGUgZ3JhcGggdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJtZXNzYWdlc1wiIGtleVxuICogLy8gd2lsbCB1cGRhdGUgdGhlIHN0YXRlIGJ5IGNvbWJpbmluZyB0aGUgZXhpc3RpbmcgdmFsdWUgd2l0aCB0aGUgcmV0dXJuZWQgb25lLlxuICogY29uc3QgbXlOb2RlID0gKHN0YXRlOiB0eXBlb2YgU3RhdGVBbm5vdGF0aW9uLlN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgbWVzc2FnZXM6IFtuZXcgQUlNZXNzYWdlKFwiU29tZSBuZXcgcmVzcG9uc2VcIildLFxuICogICAgIHNlbnRpbWVudDogXCJwb3NpdGl2ZVwiLFxuICogICB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBncmFwaCA9IGdyYXBoQnVpbGRlclxuICogICAuYWRkTm9kZShcIm15Tm9kZVwiLCBteU5vZGUpXG4gKiAgIC5hZGRFZGdlKFwiX19zdGFydF9fXCIsIFwibXlOb2RlXCIpXG4gKiAgIC5hZGRFZGdlKFwibXlOb2RlXCIsIFwiX19lbmRfX1wiKVxuICogICAuY29tcGlsZSgpO1xuICpcbiAqIGF3YWl0IGdyYXBoLmludm9rZSh7IG1lc3NhZ2VzOiBbbmV3IEh1bWFuTWVzc2FnZShcImhvdyBhcmUgeW91P1wiKV0gfSk7XG4gKlxuICogLy8ge1xuICogLy8gICBtZXNzYWdlczogW0h1bWFuTWVzc2FnZShcImhvdyBhcmUgeW91P1wiKSwgQUlNZXNzYWdlKFwiU29tZSBuZXcgcmVzcG9uc2VcIildLFxuICogLy8gICBzZW50aW1lbnQ6IFwicG9zaXRpdmVcIixcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNvbmZpZ1NjaGVtYSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCBkZWR1cGUgZWRnZXMgYXMgaW4gcHksIHNvIHdvcnRoIGZpeGluZyBhdCBzb21lIHBvaW50XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndhaXRpbmdFZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYVJ1bnRpbWVEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lucHV0RGVmaW5pdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnB1dFJ1bnRpbWVEZWZpbml0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX291dHB1dERlZmluaXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb3V0cHV0UnVudGltZURlZmluaXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBzY2hlbWFzIHRvIG1hbmFnZWQgdmFsdWVzXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYURlZmluaXRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgVXNlZCBvbmx5IGZvciB0eXBpbmcuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb25maWdTY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY29uZmlnUnVudGltZVNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNab2RTdGF0ZUdyYXBoQXJnc1dpdGhTdGF0ZVNjaGVtYShmaWVsZHMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZURlZiA9IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMuc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXREZWYgPSBmaWVsZHMuaW5wdXQgIT0gbnVsbCA/IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMuaW5wdXQpIDogc3RhdGVEZWY7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXREZWYgPSBmaWVsZHMub3V0cHV0ICE9IG51bGwgPyBnZXRDaGFubmVsc0Zyb21ab2QoZmllbGRzLm91dHB1dCkgOiBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24gPSBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJ1bnRpbWVEZWZpbml0aW9uID0gZmllbGRzLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gaW5wdXREZWY7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFJ1bnRpbWVEZWZpbml0aW9uID0gZmllbGRzLmlucHV0ID8/IGZpZWxkcy5zdGF0ZS5wYXJ0aWFsKCk7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZWZpbml0aW9uID0gb3V0cHV0RGVmO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHMub3V0cHV0ID8/IGZpZWxkcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FueVpvZE9iamVjdChmaWVsZHMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZURlZiA9IGdldENoYW5uZWxzRnJvbVpvZChmaWVsZHMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IHN0YXRlRGVmO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hUnVudGltZURlZmluaXRpb24gPSBmaWVsZHM7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dERlZmluaXRpb24gPSBzdGF0ZURlZjtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHMucGFydGlhbCgpO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA9IHN0YXRlRGVmO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0UnVudGltZURlZmluaXRpb24gPSBmaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdGF0ZUdyYXBoQXJnc1dpdGhJbnB1dE91dHB1dFNjaGVtYXMoZmllbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IGZpZWxkcy5pbnB1dC5zcGVjO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gZmllbGRzLmlucHV0LnNwZWM7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZWZpbml0aW9uID0gZmllbGRzLm91dHB1dC5zcGVjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RhdGVHcmFwaEFyZ3NXaXRoU3RhdGVTY2hlbWEoZmllbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IGZpZWxkcy5zdGF0ZVNjaGVtYS5zcGVjO1xuICAgICAgICAgICAgdGhpcy5faW5wdXREZWZpbml0aW9uID0gKGZpZWxkcy5pbnB1dD8uc3BlYyA/P1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA9IChmaWVsZHMub3V0cHV0Py5zcGVjID8/XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdGF0ZURlZmluaXRpb24oZmllbGRzKSB8fCBpc0Fubm90YXRpb25Sb290KGZpZWxkcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWMgPSBpc0Fubm90YXRpb25Sb290KGZpZWxkcykgPyBmaWVsZHMuc3BlYyA6IGZpZWxkcztcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYURlZmluaXRpb24gPSBzcGVjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RhdGVHcmFwaEFyZ3MoZmllbGRzKSkge1xuICAgICAgICAgICAgY29uc3Qgc3BlYyA9IF9nZXRDaGFubmVscyhmaWVsZHMuY2hhbm5lbHMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbiA9IHNwZWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFN0YXRlR3JhcGggaW5wdXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0RGVmaW5pdGlvbiA/Pz0gdGhpcy5fc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fb3V0cHV0RGVmaW5pdGlvbiA/Pz0gdGhpcy5fc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fYWRkU2NoZW1hKHRoaXMuX3NjaGVtYURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLl9hZGRTY2hlbWEodGhpcy5faW5wdXREZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5fYWRkU2NoZW1hKHRoaXMuX291dHB1dERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaXNBbnlab2RPYmplY3QoY29uZmlnU2NoZW1hKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnUnVudGltZVNjaGVtYSA9IGNvbmZpZ1NjaGVtYS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhbGxFZGdlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1xuICAgICAgICAgICAgLi4udGhpcy5lZGdlcyxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20odGhpcy53YWl0aW5nRWRnZXMpLmZsYXRNYXAoKFtzdGFydHMsIGVuZF0pID0+IHN0YXJ0cy5tYXAoKHN0YXJ0KSA9PiBbc3RhcnQsIGVuZF0pKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc3RhdGVEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2hlbWFEZWZpbml0aW9ucy5oYXMoc3RhdGVEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFN1cHBvcnQgbWFuYWdlZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fc2NoZW1hRGVmaW5pdGlvbnMuc2V0KHN0YXRlRGVmaW5pdGlvbiwgc3RhdGVEZWZpbml0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHN0YXRlRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBjaGFubmVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB2YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1trZXldICE9PSBjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlKGNoYW5uZWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxjX2dyYXBoX25hbWUgIT09IFwiTGFzdFZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhbm5lbCBcIiR7a2V5fVwiIGFscmVhZHkgZXhpc3RzIHdpdGggYSBkaWZmZXJlbnQgdHlwZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNba2V5XSA9IGNoYW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTm9kZShrZXksIGFjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGlzIGFscmVhZHkgYmVpbmcgdXNlZCBhcyBhIHN0YXRlIGF0dHJpYnV0ZSAoYS5rLmEuIGEgY2hhbm5lbCksIGNhbm5vdCBhbHNvIGJlIHVzZWQgYXMgYSBub2RlIG5hbWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByZXNlcnZlZENoYXIgb2YgW1xuICAgICAgICAgICAgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SLFxuICAgICAgICAgICAgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5ELFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKHJlc2VydmVkQ2hhcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtyZXNlcnZlZENoYXJ9XCIgaXMgYSByZXNlcnZlZCBjaGFyYWN0ZXIgYW5kIGlzIG5vdCBhbGxvd2VkIGluIG5vZGUgbmFtZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuSWZDb21waWxlZChgQWRkaW5nIGEgbm9kZSB0byBhIGdyYXBoIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb21waWxlZC4gVGhpcyB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGNvbXBpbGVkIGdyYXBoLmApO1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBcXGAke2tleX1cXGAgYWxyZWFkeSBwcmVzZW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IEVORCB8fCBrZXkgPT09IFNUQVJUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgXFxgJHtrZXl9XFxgIGlzIHJlc2VydmVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zPy5pbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTY2hlbWEob3B0aW9ucy5pbnB1dC5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVubmFibGU7XG4gICAgICAgIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlID0gYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcnVubmFibGUgPSBuZXcgUnVubmFibGVDYWxsYWJsZSh7XG4gICAgICAgICAgICAgICAgZnVuYzogYWN0aW9uLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICB0cmFjZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlID0gX2NvZXJjZVRvUnVubmFibGUoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlU3BlYyA9IHtcbiAgICAgICAgICAgIHJ1bm5hYmxlOiBydW5uYWJsZSxcbiAgICAgICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zPy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiBvcHRpb25zPy5pbnB1dD8uc3BlYyA/PyB0aGlzLl9zY2hlbWFEZWZpbml0aW9uLFxuICAgICAgICAgICAgc3ViZ3JhcGhzOiBpc1ByZWdlbExpa2UocnVubmFibGUpXG4gICAgICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBbcnVubmFibGVdXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zPy5zdWJncmFwaHMsXG4gICAgICAgICAgICBlbmRzOiBvcHRpb25zPy5lbmRzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGVzW2tleV0gPSBub2RlU3BlYztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc3RhcnRLZXksIGVuZEtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0S2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWRkRWRnZShzdGFydEtleSwgZW5kS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQWRkaW5nIGFuIGVkZ2UgdG8gYSBncmFwaCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuIFRoaXMgd2lsbCBcIiArXG4gICAgICAgICAgICAgICAgXCJub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBjb21waWxlZCBncmFwaC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzdGFydCBvZiBzdGFydEtleSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBFTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGEgc3RhcnQgbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5ub2Rlcykuc29tZSgobm9kZSkgPT4gbm9kZSA9PT0gc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkIHRvIGFkZCBhIG5vZGUgbmFtZWQgXCIke3N0YXJ0fVwiIGZpcnN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZEtleSA9PT0gRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFTkQgY2Fubm90IGJlIGFuIGVuZCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5ub2Rlcykuc29tZSgobm9kZSkgPT4gbm9kZSA9PT0gZW5kS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkIHRvIGFkZCBhIG5vZGUgbmFtZWQgXCIke2VuZEtleX1cIiBmaXJzdGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ0VkZ2VzLmFkZChbc3RhcnRLZXksIGVuZEtleV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29tcGlsZSh7IGNoZWNrcG9pbnRlciwgc3RvcmUsIGludGVycnVwdEJlZm9yZSwgaW50ZXJydXB0QWZ0ZXIsIG5hbWUsIH0gPSB7fSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy52YWxpZGF0ZShbXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShpbnRlcnJ1cHRCZWZvcmUpID8gaW50ZXJydXB0QmVmb3JlIDogW10pLFxuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoaW50ZXJydXB0QWZ0ZXIpID8gaW50ZXJydXB0QWZ0ZXIgOiBbXSksXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBwcmVwYXJlIG91dHB1dCBjaGFubmVsc1xuICAgICAgICBjb25zdCBvdXRwdXRLZXlzID0gT2JqZWN0LmtleXModGhpcy5fc2NoZW1hRGVmaW5pdGlvbnMuZ2V0KHRoaXMuX291dHB1dERlZmluaXRpb24pKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbHMgPSBvdXRwdXRLZXlzLmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRLZXlzWzBdID09PSBST09UID8gUk9PVCA6IG91dHB1dEtleXM7XG4gICAgICAgIGNvbnN0IHN0cmVhbUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ2hhbm5lbHMgPSBzdHJlYW1LZXlzLmxlbmd0aCA9PT0gMSAmJiBzdHJlYW1LZXlzWzBdID09PSBST09UID8gUk9PVCA6IHN0cmVhbUtleXM7XG4gICAgICAgIC8vIGNyZWF0ZSBlbXB0eSBjb21waWxlZCBncmFwaFxuICAgICAgICBjb25zdCBjb21waWxlZCA9IG5ldyBDb21waWxlZFN0YXRlR3JhcGgoe1xuICAgICAgICAgICAgYnVpbGRlcjogdGhpcyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgIGludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgYXV0b1ZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5jaGFubmVscyxcbiAgICAgICAgICAgICAgICBbU1RBUlRdOiBuZXcgRXBoZW1lcmFsVmFsdWUoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dENoYW5uZWxzOiBTVEFSVCxcbiAgICAgICAgICAgIG91dHB1dENoYW5uZWxzLFxuICAgICAgICAgICAgc3RyZWFtQ2hhbm5lbHMsXG4gICAgICAgICAgICBzdHJlYW1Nb2RlOiBcInVwZGF0ZXNcIixcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGF0dGFjaCBub2RlcywgZWRnZXMgYW5kIGJyYW5jaGVzXG4gICAgICAgIGNvbXBpbGVkLmF0dGFjaE5vZGUoU1RBUlQpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubm9kZXMpKSB7XG4gICAgICAgICAgICBjb21waWxlZC5hdHRhY2hOb2RlKGtleSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZWQuYXR0YWNoQnJhbmNoKFNUQVJULCBTRUxGLCBfZ2V0Q29udHJvbEJyYW5jaCgpLCB7XG4gICAgICAgICAgICB3aXRoUmVhZGVyOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEJyYW5jaChrZXksIFNFTEYsIF9nZXRDb250cm9sQnJhbmNoKCksIHtcbiAgICAgICAgICAgICAgICB3aXRoUmVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHRoaXMuZWRnZXMpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnRzLCBlbmRdIG9mIHRoaXMud2FpdGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICBjb21waWxlZC5hdHRhY2hFZGdlKHN0YXJ0cywgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgYnJhbmNoZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYnJhbmNoZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBicmFuY2hdIG9mIE9iamVjdC5lbnRyaWVzKGJyYW5jaGVzKSkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGVkLmF0dGFjaEJyYW5jaChzdGFydCwgbmFtZSwgYnJhbmNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWQudmFsaWRhdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZ2V0Q2hhbm5lbHMoc2NoZW1hKSB7XG4gICAgY29uc3QgY2hhbm5lbHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYSkpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFJPT1QpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzW25hbWVdID0gZ2V0Q2hhbm5lbCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmFtZTtcbiAgICAgICAgICAgIGNoYW5uZWxzW25hbWVdID0gZ2V0Q2hhbm5lbCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVscztcbn1cbi8qKlxuICogRmluYWwgcmVzdWx0IGZyb20gYnVpbGRpbmcgYW5kIGNvbXBpbGluZyBhIHtAbGluayBTdGF0ZUdyYXBofS5cbiAqIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LCBvbmx5IHVzaW5nIHRoZSBTdGF0ZUdyYXBoIGAuY29tcGlsZSgpYFxuICogaW5zdGFuY2UgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgQ29tcGlsZWRTdGF0ZUdyYXBoIGV4dGVuZHMgQ29tcGlsZWRHcmFwaCB7XG4gICAgYXR0YWNoTm9kZShrZXksIG5vZGUpIHtcbiAgICAgICAgbGV0IG91dHB1dEtleXM7XG4gICAgICAgIGlmIChrZXkgPT09IFNUQVJUKSB7XG4gICAgICAgICAgICAvLyBHZXQgaW5wdXQgc2NoZW1hIGtleXMgZXhjbHVkaW5nIG1hbmFnZWQgdmFsdWVzXG4gICAgICAgICAgICBvdXRwdXRLZXlzID0gT2JqZWN0LmVudHJpZXModGhpcy5idWlsZGVyLl9zY2hlbWFEZWZpbml0aW9ucy5nZXQodGhpcy5idWlsZGVyLl9pbnB1dERlZmluaXRpb24pKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCB2XSkgPT4gIWlzQ29uZmlndXJlZE1hbmFnZWRWYWx1ZSh2KSlcbiAgICAgICAgICAgICAgICAubWFwKChba10pID0+IGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0S2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYnVpbGRlci5jaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZnVuY3Rpb24gX2dldFJvb3QoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbW1hbmQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmdyYXBoID09PSBDb21tYW5kLlBBUkVOVCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Ll91cGRhdGVBc1R1cGxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiZcbiAgICAgICAgICAgICAgICBpbnB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgaW5wdXQuc29tZSgoaSkgPT4gaXNDb21tYW5kKGkpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tbWFuZChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZ3JhcGggPT09IENvbW1hbmQuUEFSRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goLi4uaS5fdXBkYXRlQXNUdXBsZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goW1JPT1QsIGldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tST09ULCBpbnB1dF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG8gYXZvaWQgbmFtZSBjb2xsaXNpb24gYmVsb3dcbiAgICAgICAgY29uc3Qgbm9kZUtleSA9IGtleTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZnVuY3Rpb24gX2dldFVwZGF0ZXMoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ29tbWFuZChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ3JhcGggPT09IENvbW1hbmQuUEFSRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuX3VwZGF0ZUFzVHVwbGVzKCkuZmlsdGVyKChba10pID0+IG91dHB1dEtleXMuaW5jbHVkZXMoaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiZcbiAgICAgICAgICAgICAgICBpbnB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgaW5wdXQuc29tZShpc0NvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21tYW5kKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5ncmFwaCA9PT0gQ29tbWFuZC5QQVJFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCguLi5pdGVtLl91cGRhdGVBc1R1cGxlcygpLmZpbHRlcigoW2tdKSA9PiBvdXRwdXRLZXlzLmluY2x1ZGVzKGspKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVXBkYXRlcyA9IF9nZXRVcGRhdGVzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1VcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKC4uLihpdGVtVXBkYXRlcyA/PyBbXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKChba10pID0+IG91dHB1dEtleXMuaW5jbHVkZXMoaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZW9mSW5wdXQgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBpbnB1dDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBFeHBlY3RlZCBub2RlIFwiJHtub2RlS2V5LnRvU3RyaW5nKCl9XCIgdG8gcmV0dXJuIGFuIG9iamVjdCBvciBhbiBhcnJheSBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBDb21tYW5kIG9iamVjdCwgcmVjZWl2ZWQgJHt0eXBlb2ZJbnB1dH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGxjX2Vycm9yX2NvZGU6IFwiSU5WQUxJRF9HUkFQSF9OT0RFX1JFVFVSTl9WQUxVRVwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlV3JpdGVFbnRyaWVzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBQQVNTVEhST1VHSCxcbiAgICAgICAgICAgICAgICBtYXBwZXI6IG5ldyBSdW5uYWJsZUNhbGxhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYzogb3V0cHV0S2V5cy5sZW5ndGggJiYgb3V0cHV0S2V5c1swXSA9PT0gUk9PVFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfZ2V0Um9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfZ2V0VXBkYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vIGFkZCBub2RlIGFuZCBvdXRwdXQgY2hhbm5lbFxuICAgICAgICBpZiAoa2V5ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1trZXldID0gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgICAgIHRhZ3M6IFtUQUdfSElEREVOXSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogW1NUQVJUXSxcbiAgICAgICAgICAgICAgICBjaGFubmVsczogW1NUQVJUXSxcbiAgICAgICAgICAgICAgICB3cml0ZXJzOiBbbmV3IENoYW5uZWxXcml0ZShzdGF0ZVdyaXRlRW50cmllcywgW1RBR19ISURERU5dKV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RGVmaW5pdGlvbiA9IG5vZGU/LmlucHV0ID8/IHRoaXMuYnVpbGRlci5fc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHRoaXMuYnVpbGRlci5fc2NoZW1hRGVmaW5pdGlvbnMuZ2V0KGlucHV0RGVmaW5pdGlvbikpLm1hcCgoaykgPT4gW2ssIGtdKSk7XG4gICAgICAgICAgICBjb25zdCBpc1NpbmdsZUlucHV0ID0gT2JqZWN0LmtleXMoaW5wdXRWYWx1ZXMpLmxlbmd0aCA9PT0gMSAmJiBST09UIGluIGlucHV0VmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1trZXldID0gbmV3IEVwaGVtZXJhbFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNba2V5XSA9IG5ldyBQcmVnZWxOb2RlKHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogW10sXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBzdGF0ZSBrZXlzXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IGlzU2luZ2xlSW5wdXQgPyBPYmplY3Qua2V5cyhpbnB1dFZhbHVlcykgOiBpbnB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAvLyBwdWJsaXNoIHRvIHRoaXMgY2hhbm5lbCBhbmQgc3RhdGUga2V5c1xuICAgICAgICAgICAgICAgIHdyaXRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5uZWxXcml0ZShzdGF0ZVdyaXRlRW50cmllcy5jb25jYXQoeyBjaGFubmVsOiBrZXksIHZhbHVlOiBrZXkgfSksIFtUQUdfSElEREVOXSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBtYXBwZXI6IGlzU2luZ2xlSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKChba10pID0+IGsgaW4gaW5wdXRWYWx1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmQ6IG5vZGU/LnJ1bm5hYmxlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBub2RlPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXRyeVBvbGljeTogbm9kZT8ucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICAgICAgc3ViZ3JhcGhzOiBub2RlPy5zdWJncmFwaHMsXG4gICAgICAgICAgICAgICAgZW5kczogbm9kZT8uZW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSBFTkQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYGpvaW46JHtzdGFydC5qb2luKFwiK1wiKX06JHtlbmR9YDtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbE5hbWVdID1cbiAgICAgICAgICAgICAgICBuZXcgTmFtZWRCYXJyaWVyVmFsdWUobmV3IFNldChzdGFydCkpO1xuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMubm9kZXNbZW5kXS50cmlnZ2Vycy5wdXNoKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdG8gY2hhbm5lbFxuICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tzXS53cml0ZXJzLnB1c2gobmV3IENoYW5uZWxXcml0ZShbeyBjaGFubmVsOiBjaGFubmVsTmFtZSwgdmFsdWU6IHMgfV0sIFtUQUdfSElEREVOXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID09PSBTVEFSVCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgJHtTVEFSVH06JHtlbmR9YDtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbE5hbWVdID1cbiAgICAgICAgICAgICAgICBuZXcgRXBoZW1lcmFsVmFsdWUoKTtcbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGFubmVsXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0udHJpZ2dlcnMucHVzaChjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRvIGNoYW5uZWxcbiAgICAgICAgICAgIHRoaXMubm9kZXNbU1RBUlRdLndyaXRlcnMucHVzaChuZXcgQ2hhbm5lbFdyaXRlKFt7IGNoYW5uZWw6IGNoYW5uZWxOYW1lLCB2YWx1ZTogU1RBUlQgfV0sIFtUQUdfSElEREVOXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tlbmRdLnRyaWdnZXJzLnB1c2goc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaEJyYW5jaChzdGFydCwgbmFtZSwgYnJhbmNoLCBvcHRpb25zID0geyB3aXRoUmVhZGVyOiB0cnVlIH0pIHtcbiAgICAgICAgY29uc3QgYnJhbmNoV3JpdGVyID0gYXN5bmMgKHBhY2tldHMsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQYWNrZXRzID0gcGFja2V0cy5maWx0ZXIoKHApID0+IHAgIT09IEVORCk7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcmVkUGFja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cml0ZXMgPSBmaWx0ZXJlZFBhY2tldHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKF9pc1NlbmQocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGBicmFuY2g6JHtzdGFydH06JHtuYW1lfToke3B9YCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IENoYW5uZWxXcml0ZS5kb1dyaXRlKHsgLi4uY29uZmlnLCB0YWdzOiAoY29uZmlnLnRhZ3MgPz8gW10pLmNvbmNhdChbVEFHX0hJRERFTl0pIH0sIHdyaXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGF0dGFjaCBicmFuY2ggcHVibGlzaGVyXG4gICAgICAgIHRoaXMubm9kZXNbc3RhcnRdLndyaXRlcnMucHVzaChicmFuY2gucnVuKGJyYW5jaFdyaXRlciwgXG4gICAgICAgIC8vIHJlYWRlclxuICAgICAgICBvcHRpb25zLndpdGhSZWFkZXJcbiAgICAgICAgICAgID8gKGNvbmZpZykgPT4gQ2hhbm5lbFJlYWQuZG9SZWFkKGNvbmZpZywgdGhpcy5zdHJlYW1DaGFubmVscyA/PyB0aGlzLm91dHB1dENoYW5uZWxzLCB0cnVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgLy8gYXR0YWNoIGJyYW5jaCBzdWJzY3JpYmVyc1xuICAgICAgICBjb25zdCBlbmRzID0gYnJhbmNoLmVuZHNcbiAgICAgICAgICAgID8gT2JqZWN0LnZhbHVlcyhicmFuY2guZW5kcylcbiAgICAgICAgICAgIDogT2JqZWN0LmtleXModGhpcy5idWlsZGVyLm5vZGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBlbmQgb2YgZW5kcykge1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gRU5EKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGBicmFuY2g6JHtzdGFydH06JHtuYW1lfToke2VuZH1gO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV0gPVxuICAgICAgICAgICAgICAgIG5ldyBFcGhlbWVyYWxWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2VuZF0udHJpZ2dlcnMucHVzaChjaGFubmVsTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaW5wdXRTY2hlbWEgPSB0aGlzLmJ1aWxkZXIuX2lucHV0UnVudGltZURlZmluaXRpb247XG4gICAgICAgIGlmIChpc0NvbW1hbmQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKGlucHV0LnVwZGF0ZSAmJiBpc0FueVpvZE9iamVjdChpbnB1dFNjaGVtYSkpXG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXQudXBkYXRlID0gaW5wdXRTY2hlbWEucGFyc2UoaW5wdXQudXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbnlab2RPYmplY3QoaW5wdXRTY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0U2NoZW1hLnBhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRhdGVDb25maWd1cmFibGUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1NjaGVtYSA9IHRoaXMuYnVpbGRlci5fY29uZmlnUnVudGltZVNjaGVtYTtcbiAgICAgICAgaWYgKGlzQW55Wm9kT2JqZWN0KGNvbmZpZ1NjaGVtYSkpXG4gICAgICAgICAgICBjb25maWdTY2hlbWEucGFyc2UoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlRGVmaW5pdGlvbihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwICYmXG4gICAgICAgIE9iamVjdC52YWx1ZXMob2JqKS5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiB8fCBpc0Jhc2VDaGFubmVsKHYpKSk7XG59XG5mdW5jdGlvbiBpc0Fubm90YXRpb25Sb290KG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJsY19ncmFwaF9uYW1lXCIgaW4gb2JqICYmXG4gICAgICAgIG9iai5sY19ncmFwaF9uYW1lID09PSBcIkFubm90YXRpb25Sb290XCIpO1xufVxuZnVuY3Rpb24gaXNTdGF0ZUdyYXBoQXJncyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIG9iai5jaGFubmVscyAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVHcmFwaEFyZ3NXaXRoU3RhdGVTY2hlbWEob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICBvYmouc3RhdGVTY2hlbWEgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc1N0YXRlR3JhcGhBcmdzV2l0aElucHV0T3V0cHV0U2NoZW1hcyhvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIG9iai5zdGF0ZVNjaGVtYSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9iai5pbnB1dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9iai5vdXRwdXQgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc1pvZFN0YXRlR3JhcGhBcmdzV2l0aFN0YXRlU2NoZW1hKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGF0ZVwiIGluIHZhbHVlKSB8fCAhaXNBbnlab2RPYmplY3QodmFsdWUuc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiAhaXNBbnlab2RPYmplY3QodmFsdWUuaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgIWlzQW55Wm9kT2JqZWN0KHZhbHVlLm91dHB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29udHJvbEJyYW5jaCh2YWx1ZSkge1xuICAgIGlmIChfaXNTZW5kKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBpZiAoaXNDb21tYW5kKHZhbHVlKSkge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCguLi52YWx1ZS5maWx0ZXIoaXNDb21tYW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgICBpZiAoY29tbWFuZC5ncmFwaCA9PT0gQ29tbWFuZC5QQVJFTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJlbnRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaXNTZW5kKGNvbW1hbmQuZ290bykpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucy5wdXNoKGNvbW1hbmQuZ290byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbW1hbmQuZ290byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVzdGluYXRpb25zLnB1c2goY29tbWFuZC5nb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmQuZ290bykpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbnMucHVzaCguLi5jb21tYW5kLmdvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbnM7XG59XG5mdW5jdGlvbiBfZ2V0Q29udHJvbEJyYW5jaCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IENPTlRST0xfQlJBTkNIX1BBVEggPSBuZXcgUnVubmFibGVDYWxsYWJsZSh7XG4gICAgICAgIGZ1bmM6IF9jb250cm9sQnJhbmNoLFxuICAgICAgICB0YWdzOiBbVEFHX0hJRERFTl0sXG4gICAgICAgIHRyYWNlOiBmYWxzZSxcbiAgICAgICAgcmVjdXJzZTogZmFsc2UsXG4gICAgICAgIG5hbWU6IFwiPGNvbnRyb2xfYnJhbmNoPlwiLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnJhbmNoKHtcbiAgICAgICAgcGF0aDogQ09OVFJPTF9CUkFOQ0hfUEFUSCxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/zod/state.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/zod/state.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendMeta: () => (/* binding */ extendMeta),\n/* harmony export */   getChannelsFromZod: () => (/* binding */ getChannelsFromZod),\n/* harmony export */   getMeta: () => (/* binding */ getMeta),\n/* harmony export */   isAnyZodObject: () => (/* binding */ isAnyZodObject),\n/* harmony export */   isZodDefault: () => (/* binding */ isZodDefault),\n/* harmony export */   withLangGraph: () => (/* binding */ withLangGraph)\n/* harmony export */ });\n/* harmony import */ var _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../channels/binop.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/binop.js\");\n/* harmony import */ var _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../channels/last_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/last_value.js\");\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst META_MAP = new WeakMap();\nfunction isZodType(value) {\n    return (typeof value === \"object\" &&\n        value != null &&\n        \"_parse\" in value &&\n        typeof value._parse === \"function\");\n}\n/**\n * @internal\n */\nfunction isZodDefault(value) {\n    return (isZodType(value) &&\n        \"removeDefault\" in value &&\n        typeof value.removeDefault === \"function\");\n}\n/**\n * @internal\n */\nfunction isAnyZodObject(value) {\n    return (isZodType(value) &&\n        \"partial\" in value &&\n        typeof value.partial === \"function\");\n}\nfunction withLangGraph(schema, meta) {\n    if (meta.reducer && !meta.default) {\n        const defaultValue = isZodDefault(schema)\n            ? schema._def.defaultValue\n            : undefined;\n        if (defaultValue != null) {\n            // eslint-disable-next-line no-param-reassign\n            meta.default = defaultValue;\n        }\n    }\n    META_MAP.set(schema, meta);\n    return schema;\n}\nfunction getMeta(schema) {\n    return META_MAP.get(schema);\n}\nfunction extendMeta(schema, update) {\n    const existingMeta = getMeta(schema);\n    const newMeta = update(existingMeta);\n    META_MAP.set(schema, newMeta);\n}\nfunction getChannelsFromZod(schema) {\n    const channels = {};\n    for (const key in schema.shape) {\n        if (Object.prototype.hasOwnProperty.call(schema.shape, key)) {\n            const keySchema = schema.shape[key];\n            const meta = getMeta(keySchema);\n            if (meta?.reducer) {\n                channels[key] = new _channels_binop_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate(meta.reducer.fn, meta.default);\n            }\n            else {\n                channels[key] = new _channels_last_value_js__WEBPACK_IMPORTED_MODULE_1__.LastValue();\n            }\n        }\n    }\n    return channels;\n}\n//# sourceMappingURL=state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL3pvZC9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrRTtBQUNUO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVFQUF1QjtBQUMzRDtBQUNBO0FBQ0Esb0NBQW9DLDhEQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L2dyYXBoL3pvZC9zdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5hcnlPcGVyYXRvckFnZ3JlZ2F0ZSB9IGZyb20gXCIuLi8uLi9jaGFubmVscy9iaW5vcC5qc1wiO1xuaW1wb3J0IHsgTGFzdFZhbHVlIH0gZnJvbSBcIi4uLy4uL2NoYW5uZWxzL2xhc3RfdmFsdWUuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBNRVRBX01BUCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpc1pvZFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIFwiX3BhcnNlXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9wYXJzZSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1pvZERlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzWm9kVHlwZSh2YWx1ZSkgJiZcbiAgICAgICAgXCJyZW1vdmVEZWZhdWx0XCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnJlbW92ZURlZmF1bHQgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbnlab2RPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzWm9kVHlwZSh2YWx1ZSkgJiZcbiAgICAgICAgXCJwYXJ0aWFsXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhbmdHcmFwaChzY2hlbWEsIG1ldGEpIHtcbiAgICBpZiAobWV0YS5yZWR1Y2VyICYmICFtZXRhLmRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaXNab2REZWZhdWx0KHNjaGVtYSlcbiAgICAgICAgICAgID8gc2NoZW1hLl9kZWYuZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1ldGEuZGVmYXVsdCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNRVRBX01BUC5zZXQoc2NoZW1hLCBtZXRhKTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIE1FVEFfTUFQLmdldChzY2hlbWEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZE1ldGEoc2NoZW1hLCB1cGRhdGUpIHtcbiAgICBjb25zdCBleGlzdGluZ01ldGEgPSBnZXRNZXRhKHNjaGVtYSk7XG4gICAgY29uc3QgbmV3TWV0YSA9IHVwZGF0ZShleGlzdGluZ01ldGEpO1xuICAgIE1FVEFfTUFQLnNldChzY2hlbWEsIG5ld01ldGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWxzRnJvbVpvZChzY2hlbWEpIHtcbiAgICBjb25zdCBjaGFubmVscyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYS5zaGFwZSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5U2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gZ2V0TWV0YShrZXlTY2hlbWEpO1xuICAgICAgICAgICAgaWYgKG1ldGE/LnJlZHVjZXIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsc1trZXldID0gbmV3IEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlKG1ldGEucmVkdWNlci5mbiwgbWV0YS5kZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzW2tleV0gPSBuZXcgTGFzdFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/zod/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelKeyPlaceholder: () => (/* binding */ ChannelKeyPlaceholder),\n/* harmony export */   ManagedValue: () => (/* binding */ ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* binding */ ManagedValueMapping),\n/* harmony export */   NoopManagedValue: () => (/* binding */ NoopManagedValue),\n/* harmony export */   WritableManagedValue: () => (/* binding */ WritableManagedValue),\n/* harmony export */   isConfiguredManagedValue: () => (/* binding */ isConfiguredManagedValue),\n/* harmony export */   isManagedValue: () => (/* binding */ isManagedValue)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass ManagedValue {\n    constructor(config, _params) {\n        Object.defineProperty(this, \"runtime\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_promises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"lg_is_managed_value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.config = config;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static async initialize(_config, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _args) {\n        throw new Error(\"Not implemented\");\n    }\n    async promises() {\n        return Promise.all(this._promises);\n    }\n    addPromise(promise) {\n        this._promises.push(promise);\n    }\n}\nclass WritableManagedValue extends ManagedValue {\n}\nconst ChannelKeyPlaceholder = \"__channel_key_placeholder__\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass ManagedValueMapping extends Map {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(entries) {\n        super(entries ? Array.from(entries) : undefined);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    replaceRuntimeValues(step, values) {\n        if (this.size === 0 || !values) {\n            return;\n        }\n        if (Array.from(this.values()).every((mv) => !mv.runtime)) {\n            return;\n        }\n        if (typeof values === \"object\" && !Array.isArray(values)) {\n            for (const [key, value] of Object.entries(values)) {\n                for (const [chan, mv] of this.entries()) {\n                    if (mv.runtime && mv.call(step) === value) {\n                        // eslint-disable-next-line no-param-reassign\n                        values[key] = { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]: chan };\n                    }\n                }\n            }\n        }\n        else if (typeof values === \"object\" && \"constructor\" in values) {\n            for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(values))) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const value = values[key];\n                    for (const [chan, mv] of this.entries()) {\n                        if (mv.runtime && mv.call(step) === value) {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-param-reassign\n                            values[key] = { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]: chan };\n                        }\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (error) {\n                    // Ignore if TypeError\n                    if (error.name !== TypeError.name) {\n                        throw error;\n                    }\n                }\n            }\n        }\n    }\n    replaceRuntimePlaceholders(step, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    values) {\n        if (this.size === 0 || !values) {\n            return;\n        }\n        if (Array.from(this.values()).every((mv) => !mv.runtime)) {\n            return;\n        }\n        if (typeof values === \"object\" && !Array.isArray(values)) {\n            for (const [key, value] of Object.entries(values)) {\n                if (typeof value === \"object\" &&\n                    value !== null &&\n                    _constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER in value) {\n                    const placeholder = value[_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER];\n                    if (typeof placeholder === \"string\") {\n                        // eslint-disable-next-line no-param-reassign\n                        values[key] = this.get(placeholder)?.call(step);\n                    }\n                }\n            }\n        }\n        else if (typeof values === \"object\" && \"constructor\" in values) {\n            for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(values))) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const value = values[key];\n                    if (typeof value === \"object\" &&\n                        value !== null &&\n                        _constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER in value) {\n                        const managedValue = this.get(value[_constants_js__WEBPACK_IMPORTED_MODULE_0__.RUNTIME_PLACEHOLDER]);\n                        if (managedValue) {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-param-reassign\n                            values[key] = managedValue.call(step);\n                        }\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (error) {\n                    // Ignore if TypeError\n                    if (error.name !== TypeError.name) {\n                        throw error;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction isManagedValue(value) {\n    if (typeof value === \"object\" && value && \"lg_is_managed_value\" in value) {\n        return true;\n    }\n    return false;\n}\nfunction isConfiguredManagedValue(value) {\n    if (typeof value === \"object\" &&\n        value &&\n        \"cls\" in value &&\n        \"params\" in value) {\n        return true;\n    }\n    return false;\n}\n/**\n * No-op class used when getting state values, as managed values should never be returned\n * in get state calls.\n */\nclass NoopManagedValue extends ManagedValue {\n    call() { }\n    static async initialize(config, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _args) {\n        return Promise.resolve(new NoopManagedValue(config));\n    }\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRDtBQUN0RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLENBQUMsOERBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxDQUFDLDhEQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFtQjtBQUN2Qyw4Q0FBOEMsOERBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQW1CO0FBQzNDLDREQUE0RCw4REFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvbWFuYWdlZC9iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJVTlRJTUVfUExBQ0VIT0xERVIgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNsYXNzIE1hbmFnZWRWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBfcGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bnRpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Byb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGdfaXNfbWFuYWdlZF92YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoX2NvbmZpZywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGFzeW5jIHByb21pc2VzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5fcHJvbWlzZXMpO1xuICAgIH1cbiAgICBhZGRQcm9taXNlKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGFibGVNYW5hZ2VkVmFsdWUgZXh0ZW5kcyBNYW5hZ2VkVmFsdWUge1xufVxuZXhwb3J0IGNvbnN0IENoYW5uZWxLZXlQbGFjZWhvbGRlciA9IFwiX19jaGFubmVsX2tleV9wbGFjZWhvbGRlcl9fXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNsYXNzIE1hbmFnZWRWYWx1ZU1hcHBpbmcgZXh0ZW5kcyBNYXAge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBzdXBlcihlbnRyaWVzID8gQXJyYXkuZnJvbShlbnRyaWVzKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmVwbGFjZVJ1bnRpbWVWYWx1ZXMoc3RlcCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgfHwgIXZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpLmV2ZXJ5KChtdikgPT4gIW12LnJ1bnRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2NoYW4sIG12XSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobXYucnVudGltZSAmJiBtdi5jYWxsKHN0ZXApID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHsgW1JVTlRJTUVfUExBQ0VIT0xERVJdOiBjaGFuIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiBcImNvbnN0cnVjdG9yXCIgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVzKSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGFuLCBtdl0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdi5ydW50aW1lICYmIG12LmNhbGwoc3RlcCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB7IFtSVU5USU1FX1BMQUNFSE9MREVSXTogY2hhbiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaWYgVHlwZUVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lICE9PSBUeXBlRXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZVJ1bnRpbWVQbGFjZWhvbGRlcnMoc3RlcCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCB8fCAhdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSkuZXZlcnkoKG12KSA9PiAhbXYucnVudGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBSVU5USU1FX1BMQUNFSE9MREVSIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdmFsdWVbUlVOVElNRV9QTEFDRUhPTERFUl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGxhY2Vob2xkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0aGlzLmdldChwbGFjZWhvbGRlcik/LmNhbGwoc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiBcImNvbnN0cnVjdG9yXCIgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVzKSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgUlVOVElNRV9QTEFDRUhPTERFUiBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlZFZhbHVlID0gdGhpcy5nZXQodmFsdWVbUlVOVElNRV9QTEFDRUhPTERFUl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmFnZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gbWFuYWdlZFZhbHVlLmNhbGwoc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpZiBUeXBlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IFR5cGVFcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc01hbmFnZWRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgJiYgXCJsZ19pc19tYW5hZ2VkX3ZhbHVlXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbmZpZ3VyZWRNYW5hZ2VkVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHZhbHVlICYmXG4gICAgICAgIFwiY2xzXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgXCJwYXJhbXNcIiBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBOby1vcCBjbGFzcyB1c2VkIHdoZW4gZ2V0dGluZyBzdGF0ZSB2YWx1ZXMsIGFzIG1hbmFnZWQgdmFsdWVzIHNob3VsZCBuZXZlciBiZSByZXR1cm5lZFxuICogaW4gZ2V0IHN0YXRlIGNhbGxzLlxuICovXG5leHBvcnQgY2xhc3MgTm9vcE1hbmFnZWRWYWx1ZSBleHRlbmRzIE1hbmFnZWRWYWx1ZSB7XG4gICAgY2FsbCgpIHsgfVxuICAgIHN0YXRpYyBhc3luYyBpbml0aWFsaXplKGNvbmZpZywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBOb29wTWFuYWdlZFZhbHVlKGNvbmZpZykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/index.js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/index.js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder),\n/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _is_last_step_js__WEBPACK_IMPORTED_MODULE_1__.IsLastStepManager),\n/* harmony export */   ManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValueMapping),\n/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.NoopManagedValue),\n/* harmony export */   SharedValue: () => (/* reexport safe */ _shared_value_js__WEBPACK_IMPORTED_MODULE_2__.SharedValue),\n/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue),\n/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.isConfiguredManagedValue),\n/* harmony export */   isManagedValue: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_0__.isManagedValue)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _is_last_step_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is_last_step.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/is_last_step.js\");\n/* harmony import */ var _shared_value_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared_value.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/shared_value.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ1E7QUFDQTtBQUNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaXNfbGFzdF9zdGVwLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zaGFyZWRfdmFsdWUuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/is_last_step.js":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/is_last_step.js ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsLastStepManager: () => (/* binding */ IsLastStepManager)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n\n\nclass IsLastStepManager extends _base_js__WEBPACK_IMPORTED_MODULE_1__.ManagedValue {\n    call(step) {\n        return step === (this.config.recursionLimit ?? _constants_js__WEBPACK_IMPORTED_MODULE_0__.RECURSION_LIMIT_DEFAULT) - 1;\n    }\n}\n//# sourceMappingURL=is_last_step.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvaXNfbGFzdF9zdGVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwRDtBQUNqQjtBQUNsQyxnQ0FBZ0Msa0RBQVk7QUFDbkQ7QUFDQSx1REFBdUQsa0VBQXVCO0FBQzlFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvaXNfbGFzdF9zdGVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFQ1VSU0lPTl9MSU1JVF9ERUZBVUxUIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgTWFuYWdlZFZhbHVlIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGNsYXNzIElzTGFzdFN0ZXBNYW5hZ2VyIGV4dGVuZHMgTWFuYWdlZFZhbHVlIHtcbiAgICBjYWxsKHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIHN0ZXAgPT09ICh0aGlzLmNvbmZpZy5yZWN1cnNpb25MaW1pdCA/PyBSRUNVUlNJT05fTElNSVRfREVGQVVMVCkgLSAxO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzX2xhc3Rfc3RlcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/is_last_step.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/shared_value.js":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/shared_value.js ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SharedValue: () => (/* binding */ SharedValue)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\nclass SharedValue extends _base_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue {\n    constructor(config, params) {\n        super(config, params);\n        Object.defineProperty(this, \"scope\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        this.scope = params.scope;\n        this.store = config.store || null;\n        if (!this.store) {\n            this.ns = null;\n        }\n        else if (config.configurable?.[this.scope]) {\n            const scopeValue = config.configurable[this.scope];\n            const scopedValueString = typeof scopeValue === \"string\"\n                ? scopeValue\n                : JSON.stringify(scopeValue);\n            this.ns = [\"scoped\", this.scope, params.key, scopedValueString];\n        }\n        else {\n            throw new Error(`Required scope \"${this.scope}\" for shared state key was not passed in \"config.configurable\".`);\n        }\n    }\n    static async initialize(config, args) {\n        const instance = new this(config, args);\n        await instance.loadStore();\n        return instance;\n    }\n    static on(scope) {\n        return {\n            cls: SharedValue,\n            params: {\n                scope,\n                key: _base_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder,\n            },\n        };\n    }\n    call(_step) {\n        return { ...this.value };\n    }\n    processUpdate(values) {\n        const writes = [];\n        for (const vv of values) {\n            for (const [k, v] of Object.entries(vv)) {\n                if (v === null) {\n                    if (k in this.value) {\n                        delete this.value[k];\n                        if (this.ns) {\n                            writes.push({ namespace: this.ns, key: k, value: null });\n                        }\n                    }\n                }\n                else if (typeof v !== \"object\" || v === null) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError(\"Received a non-object value\");\n                }\n                else {\n                    this.value[k] = v;\n                    if (this.ns) {\n                        writes.push({ namespace: this.ns, key: k, value: v });\n                    }\n                }\n            }\n        }\n        return writes;\n    }\n    async update(values) {\n        if (!this.store) {\n            this.processUpdate(values);\n        }\n        else {\n            await this.store.batch(this.processUpdate(values));\n        }\n    }\n    async loadStore() {\n        if (this.store && this.ns) {\n            const saved = await this.store.search(this.ns);\n            this.value = saved.reduce((acc, item) => {\n                acc[item.key] = item.value;\n                return acc;\n            }, {});\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=shared_value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvc2hhcmVkX3ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3lFO0FBQ3ZCO0FBQzNDLDBCQUEwQiwwREFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQXFCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0NBQXNDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L21hbmFnZWQvc2hhcmVkX3ZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IENoYW5uZWxLZXlQbGFjZWhvbGRlciwgV3JpdGFibGVNYW5hZ2VkVmFsdWUsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZFVwZGF0ZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGNsYXNzIFNoYXJlZFZhbHVlIGV4dGVuZHMgV3JpdGFibGVNYW5hZ2VkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgcGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgcGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2NvcGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjb3BlID0gcGFyYW1zLnNjb3BlO1xuICAgICAgICB0aGlzLnN0b3JlID0gY29uZmlnLnN0b3JlIHx8IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLmNvbmZpZ3VyYWJsZT8uW3RoaXMuc2NvcGVdKSB7XG4gICAgICAgICAgICBjb25zdCBzY29wZVZhbHVlID0gY29uZmlnLmNvbmZpZ3VyYWJsZVt0aGlzLnNjb3BlXTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlZFZhbHVlU3RyaW5nID0gdHlwZW9mIHNjb3BlVmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IHNjb3BlVmFsdWVcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHNjb3BlVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ucyA9IFtcInNjb3BlZFwiLCB0aGlzLnNjb3BlLCBwYXJhbXMua2V5LCBzY29wZWRWYWx1ZVN0cmluZ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIHNjb3BlIFwiJHt0aGlzLnNjb3BlfVwiIGZvciBzaGFyZWQgc3RhdGUga2V5IHdhcyBub3QgcGFzc2VkIGluIFwiY29uZmlnLmNvbmZpZ3VyYWJsZVwiLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBpbml0aWFsaXplKGNvbmZpZywgYXJncykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyB0aGlzKGNvbmZpZywgYXJncyk7XG4gICAgICAgIGF3YWl0IGluc3RhbmNlLmxvYWRTdG9yZSgpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIHN0YXRpYyBvbihzY29wZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xzOiBTaGFyZWRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgIGtleTogQ2hhbm5lbEtleVBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2FsbChfc3RlcCkge1xuICAgICAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHByb2Nlc3NVcGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZ2IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModnYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgaW4gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlcy5wdXNoKHsgbmFtZXNwYWNlOiB0aGlzLm5zLCBrZXk6IGssIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ICE9PSBcIm9iamVjdFwiIHx8IHYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihcIlJlY2VpdmVkIGEgbm9uLW9iamVjdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVzLnB1c2goeyBuYW1lc3BhY2U6IHRoaXMubnMsIGtleTogaywgdmFsdWU6IHYgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcmUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1VwZGF0ZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9yZS5iYXRjaCh0aGlzLnByb2Nlc3NVcGRhdGUodmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbG9hZFN0b3JlKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9yZSAmJiB0aGlzLm5zKSB7XG4gICAgICAgICAgICBjb25zdCBzYXZlZCA9IGF3YWl0IHRoaXMuc3RvcmUuc2VhcmNoKHRoaXMubnMpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNhdmVkLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2l0ZW0ua2V5XSA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkX3ZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/shared_value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/algo.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/algo.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _applyWrites: () => (/* binding */ _applyWrites),\n/* harmony export */   _localRead: () => (/* binding */ _localRead),\n/* harmony export */   _localWrite: () => (/* binding */ _localWrite),\n/* harmony export */   _prepareNextTasks: () => (/* binding */ _prepareNextTasks),\n/* harmony export */   _prepareSingleTask: () => (/* binding */ _prepareSingleTask),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   shouldInterrupt: () => (/* binding */ shouldInterrupt)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph-checkpoint@0.0.17_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4__/node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channels/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./io.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/types.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./call.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/call.js\");\n/* eslint-disable no-param-reassign */\n\n\n\n\n\n\n\n\n\nconst increment = (current) => {\n    return current !== undefined ? current + 1 : 1;\n};\nfunction shouldInterrupt(checkpoint, interruptNodes, tasks) {\n    const versionValues = Object.values(checkpoint.channel_versions);\n    const versionType = versionValues.length > 0 ? typeof versionValues[0] : undefined;\n    let nullVersion;\n    if (versionType === \"number\") {\n        nullVersion = 0;\n    }\n    else if (versionType === \"string\") {\n        nullVersion = \"\";\n    }\n    const seen = checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_4__.INTERRUPT] ?? {};\n    const anyChannelUpdated = Object.entries(checkpoint.channel_versions).some(([chan, version]) => {\n        return version > (seen[chan] ?? nullVersion);\n    });\n    const anyTriggeredNodeInInterruptNodes = tasks.some((task) => interruptNodes === \"*\"\n        ? !task.config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_4__.TAG_HIDDEN)\n        : interruptNodes.includes(task.name));\n    return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\nfunction _localRead(step, checkpoint, channels, managed, task, select, fresh = false) {\n    let managedKeys = [];\n    let updated = new Set();\n    if (!Array.isArray(select)) {\n        for (const [c] of task.writes) {\n            if (c === select) {\n                updated = new Set([c]);\n                break;\n            }\n        }\n        updated = updated || new Set();\n    }\n    else {\n        managedKeys = select.filter((k) => managed.get(k));\n        select = select.filter((k) => !managed.get(k));\n        updated = new Set(select.filter((c) => task.writes.some(([key, _]) => key === c)));\n    }\n    let values;\n    if (fresh && updated.size > 0) {\n        const localChannels = Object.fromEntries(Object.entries(channels).filter(([k, _]) => updated.has(k)));\n        const newCheckpoint = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, localChannels, -1);\n        const newChannels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(localChannels, newCheckpoint);\n        _applyWrites((0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint)(newCheckpoint), newChannels, [task]);\n        values = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannels)({ ...channels, ...newChannels }, select);\n    }\n    else {\n        values = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannels)(channels, select);\n    }\n    if (managedKeys.length > 0) {\n        for (const k of managedKeys) {\n            const managedValue = managed.get(k);\n            if (managedValue) {\n                const resultOfManagedCall = managedValue.call(step);\n                values[k] = resultOfManagedCall;\n            }\n        }\n    }\n    return values;\n}\nfunction _localWrite(step, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ncommit, processes, managed, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nwrites) {\n    for (const [chan, value] of writes) {\n        if ([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH, _constants_js__WEBPACK_IMPORTED_MODULE_4__.TASKS].includes(chan) && value != null) {\n            if (!(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSend)(value)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(value)}`);\n            }\n            if (!(value.node in processes)) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid node name \"${value.node}\" in Send packet`);\n            }\n            // replace any runtime values with placeholders\n            managed.replaceRuntimeValues(step, value.args);\n        }\n    }\n    commit(writes);\n}\nconst IGNORE = new Set([\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.NO_WRITES,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.INTERRUPT,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.RETURN,\n    _constants_js__WEBPACK_IMPORTED_MODULE_4__.ERROR,\n]);\nfunction _applyWrites(checkpoint, channels, tasks, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ngetNextVersion) {\n    // Sort tasks by first 3 path elements for deterministic order\n    // Later path parts (like task IDs) are ignored for sorting\n    tasks.sort((a, b) => {\n        const aPath = a.path?.slice(0, 3) || [];\n        const bPath = b.path?.slice(0, 3) || [];\n        // Compare each path element\n        for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n            if (aPath[i] < bPath[i])\n                return -1;\n            if (aPath[i] > bPath[i])\n                return 1;\n        }\n        // If one path is shorter, it comes first\n        return aPath.length - bPath.length;\n    });\n    // if no task has triggers this is applying writes from the null task only\n    // so we don't do anything other than update the channels written to\n    const bumpStep = tasks.some((task) => task.triggers.length > 0);\n    // Filter out non instances of BaseChannel\n    const onlyChannels = Object.fromEntries(Object.entries(channels).filter(([_, value]) => (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseChannel)(value)));\n    // Update seen versions\n    for (const task of tasks) {\n        if (checkpoint.versions_seen[task.name] === undefined) {\n            checkpoint.versions_seen[task.name] = {};\n        }\n        for (const chan of task.triggers) {\n            if (chan in checkpoint.channel_versions) {\n                checkpoint.versions_seen[task.name][chan] =\n                    checkpoint.channel_versions[chan];\n            }\n        }\n    }\n    // Find the highest version of all channels\n    let maxVersion;\n    if (Object.keys(checkpoint.channel_versions).length > 0) {\n        maxVersion = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.maxChannelVersion)(...Object.values(checkpoint.channel_versions));\n    }\n    // Consume all channels that were read\n    const channelsToConsume = new Set(tasks\n        .flatMap((task) => task.triggers)\n        .filter((chan) => !_constants_js__WEBPACK_IMPORTED_MODULE_4__.RESERVED.includes(chan)));\n    for (const chan of channelsToConsume) {\n        if (chan in onlyChannels && onlyChannels[chan].consume()) {\n            if (getNextVersion !== undefined) {\n                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n            }\n        }\n    }\n    // Clear pending sends\n    if (checkpoint.pending_sends?.length && bumpStep) {\n        checkpoint.pending_sends = [];\n    }\n    // Group writes by channel\n    const pendingWriteValuesByChannel = {};\n    const pendingWritesByManaged = {};\n    for (const task of tasks) {\n        for (const [chan, val] of task.writes) {\n            if (IGNORE.has(chan)) {\n                // do nothing\n            }\n            else if (chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.TASKS) {\n                // TODO: remove branch in 1.0\n                checkpoint.pending_sends.push({\n                    node: val.node,\n                    args: val.args,\n                });\n            }\n            else if (chan in onlyChannels) {\n                if (chan in pendingWriteValuesByChannel) {\n                    pendingWriteValuesByChannel[chan].push(val);\n                }\n                else {\n                    pendingWriteValuesByChannel[chan] = [val];\n                }\n            }\n            else {\n                if (chan in pendingWritesByManaged) {\n                    pendingWritesByManaged[chan].push(val);\n                }\n                else {\n                    pendingWritesByManaged[chan] = [val];\n                }\n            }\n        }\n    }\n    // find the highest version of all channels\n    maxVersion = undefined;\n    if (Object.keys(checkpoint.channel_versions).length > 0) {\n        maxVersion = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.maxChannelVersion)(...Object.values(checkpoint.channel_versions));\n    }\n    const updatedChannels = new Set();\n    // Apply writes to channels\n    for (const [chan, vals] of Object.entries(pendingWriteValuesByChannel)) {\n        if (chan in onlyChannels) {\n            let updated;\n            try {\n                updated = onlyChannels[chan].update(vals);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError.unminifiable_name) {\n                    const wrappedError = new _errors_js__WEBPACK_IMPORTED_MODULE_6__.InvalidUpdateError(`Invalid update for channel \"${chan}\" with values ${JSON.stringify(vals)}: ${e.message}`);\n                    wrappedError.lc_error_code = e.lc_error_code;\n                    throw wrappedError;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (updated && getNextVersion !== undefined) {\n                checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n            }\n            updatedChannels.add(chan);\n        }\n    }\n    // Channels that weren't updated in this step are notified of a new step\n    if (bumpStep) {\n        for (const chan of Object.keys(onlyChannels)) {\n            if (!updatedChannels.has(chan)) {\n                const updated = onlyChannels[chan].update([]);\n                if (updated && getNextVersion !== undefined) {\n                    checkpoint.channel_versions[chan] = getNextVersion(maxVersion, onlyChannels[chan]);\n                }\n            }\n        }\n    }\n    // Return managed values writes to be applied externally\n    return pendingWritesByManaged;\n}\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nfunction _prepareNextTasks(checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra) {\n    const tasks = {};\n    // Consume pending packets\n    for (let i = 0; i < checkpoint.pending_sends.length; i += 1) {\n        const task = _prepareSingleTask([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH, i], checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra);\n        if (task !== undefined) {\n            tasks[task.id] = task;\n        }\n    }\n    // Check if any processes should be run in next step\n    // If so, prepare the values to be passed to them\n    for (const name of Object.keys(processes)) {\n        const task = _prepareSingleTask([_constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL, name], checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra);\n        if (task !== undefined) {\n            tasks[task.id] = task;\n        }\n    }\n    return tasks;\n}\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nfunction _prepareSingleTask(taskPath, checkpoint, pendingWrites, processes, channels, managed, config, forExecution, extra) {\n    const { step, checkpointer, manager } = extra;\n    const configurable = config.configurable ?? {};\n    const parentNamespace = configurable.checkpoint_ns ?? \"\";\n    if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH && (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.isCall)(taskPath[taskPath.length - 1])) {\n        const call = taskPath[taskPath.length - 1];\n        const proc = (0,_call_js__WEBPACK_IMPORTED_MODULE_8__.getRunnableForFunc)(call.name, call.func);\n        const triggers = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH];\n        const checkpointNamespace = parentNamespace === \"\"\n            ? call.name\n            : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;\n        const id = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n            checkpointNamespace,\n            step.toString(),\n            call.name,\n            _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n            taskPath[1],\n            taskPath[2],\n        ]), checkpoint.id);\n        const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${id}`;\n        const metadata = {\n            langgraph_step: step,\n            langgraph_node: call.name,\n            langgraph_triggers: triggers,\n            langgraph_path: taskPath.slice(0, 3),\n            langgraph_checkpoint_ns: taskCheckpointNamespace,\n        };\n        if (forExecution) {\n            const writes = [];\n            const task = {\n                name: call.name,\n                input: call.input,\n                proc,\n                writes,\n                config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                    metadata,\n                    store: extra.store ?? config.store,\n                }), {\n                    runName: call.name,\n                    callbacks: manager?.getChild(`graph:step:${step}`),\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: id,\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => writes.push(...items), processes, managed, writes_),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                            name: call.name,\n                            writes: writes,\n                            triggers,\n                            path: taskPath.slice(0, 3),\n                        }, select_, fresh_),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                            ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                            [parentNamespace]: checkpoint.id,\n                        },\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                            pendingWrites: pendingWrites ?? [],\n                            taskId: id,\n                            currentTaskInput: call.input,\n                        }),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                        checkpoint_id: undefined,\n                        checkpoint_ns: taskCheckpointNamespace,\n                    },\n                }),\n                triggers,\n                retry_policy: call.retry,\n                id,\n                path: taskPath.slice(0, 3),\n                writers: [],\n            };\n            return task;\n        }\n        else {\n            return {\n                id,\n                name: call.name,\n                interrupts: [],\n                path: taskPath.slice(0, 3),\n            };\n        }\n    }\n    else if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH) {\n        const index = typeof taskPath[1] === \"number\"\n            ? taskPath[1]\n            : parseInt(taskPath[1], 10);\n        if (index >= checkpoint.pending_sends.length) {\n            return undefined;\n        }\n        const packet = (0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSendInterface)(checkpoint.pending_sends[index]) &&\n            !(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSend)(checkpoint.pending_sends[index])\n            ? new _constants_js__WEBPACK_IMPORTED_MODULE_4__.Send(checkpoint.pending_sends[index].node, checkpoint.pending_sends[index].args)\n            : checkpoint.pending_sends[index];\n        if (!(0,_constants_js__WEBPACK_IMPORTED_MODULE_4__._isSendInterface)(packet)) {\n            console.warn(`Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`);\n            return undefined;\n        }\n        if (!(packet.node in processes)) {\n            console.warn(`Ignoring unknown node name ${packet.node} in pending sends.`);\n            return undefined;\n        }\n        const triggers = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH];\n        const checkpointNamespace = parentNamespace === \"\"\n            ? packet.node\n            : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n        const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n            checkpointNamespace,\n            step.toString(),\n            packet.node,\n            _constants_js__WEBPACK_IMPORTED_MODULE_4__.PUSH,\n            index.toString(),\n        ]), checkpoint.id);\n        const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${taskId}`;\n        let metadata = {\n            langgraph_step: step,\n            langgraph_node: packet.node,\n            langgraph_triggers: triggers,\n            langgraph_path: taskPath.slice(0, 3),\n            langgraph_checkpoint_ns: taskCheckpointNamespace,\n        };\n        if (forExecution) {\n            const proc = processes[packet.node];\n            const node = proc.getNode();\n            if (node !== undefined) {\n                managed.replaceRuntimePlaceholders(step, packet.args);\n                if (proc.metadata !== undefined) {\n                    metadata = { ...metadata, ...proc.metadata };\n                }\n                const writes = [];\n                return {\n                    name: packet.node,\n                    input: packet.args,\n                    proc: node,\n                    subgraphs: proc.subgraphs,\n                    writes,\n                    config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                        metadata,\n                        tags: proc.tags,\n                        store: extra.store ?? config.store,\n                    }), {\n                        runName: packet.node,\n                        callbacks: manager?.getChild(`graph:step:${step}`),\n                        configurable: {\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: taskId,\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => writes.push(...items), processes, managed, writes_),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                                name: packet.node,\n                                writes: writes,\n                                triggers,\n                                path: taskPath,\n                            }, select_, fresh_),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                                ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                                [parentNamespace]: checkpoint.id,\n                            },\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                                pendingWrites: pendingWrites ?? [],\n                                taskId,\n                                currentTaskInput: packet.args,\n                            }),\n                            [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                            checkpoint_id: undefined,\n                            checkpoint_ns: taskCheckpointNamespace,\n                        },\n                    }),\n                    triggers,\n                    retry_policy: proc.retryPolicy,\n                    id: taskId,\n                    path: taskPath,\n                    writers: proc.getWriters(),\n                };\n            }\n        }\n        else {\n            return {\n                id: taskId,\n                name: packet.node,\n                interrupts: [],\n                path: taskPath,\n            };\n        }\n    }\n    else if (taskPath[0] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL) {\n        const name = taskPath[1].toString();\n        const proc = processes[name];\n        if (proc === undefined) {\n            return undefined;\n        }\n        // Check if this task already has successful writes in the pending writes\n        if (pendingWrites?.length) {\n            // Find the task ID for this node/path\n            const checkpointNamespace = parentNamespace === \"\"\n                ? name\n                : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n            const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n                checkpointNamespace,\n                step.toString(),\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL,\n                name,\n            ]), checkpoint.id);\n            // Check if there are successful writes (not ERROR) for this task ID\n            const hasSuccessfulWrites = pendingWrites.some((w) => w[0] === taskId && w[1] !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.ERROR);\n            // If task completed successfully, don't include it in next tasks\n            if (hasSuccessfulWrites) {\n                return undefined;\n            }\n        }\n        const nullVersion = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.getNullChannelVersion)(checkpoint.channel_versions);\n        if (nullVersion === undefined) {\n            return undefined;\n        }\n        const seen = checkpoint.versions_seen[name] ?? {};\n        const triggers = proc.triggers\n            .filter((chan) => {\n            const result = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false, true);\n            const isEmptyChannelError = \n            // eslint-disable-next-line no-instanceof/no-instanceof\n            result instanceof Error &&\n                result.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name;\n            return (!isEmptyChannelError &&\n                (checkpoint.channel_versions[chan] ?? nullVersion) >\n                    (seen[chan] ?? nullVersion));\n        })\n            .sort();\n        // If any of the channels read by this process were updated\n        if (triggers.length > 0) {\n            const val = _procInput(step, proc, managed, channels, forExecution);\n            if (val === undefined) {\n                return undefined;\n            }\n            const checkpointNamespace = parentNamespace === \"\"\n                ? name\n                : `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n            const taskId = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(JSON.stringify([\n                checkpointNamespace,\n                step.toString(),\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_4__.PULL,\n                triggers,\n            ]), checkpoint.id);\n            const taskCheckpointNamespace = `${checkpointNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_4__.CHECKPOINT_NAMESPACE_END}${taskId}`;\n            let metadata = {\n                langgraph_step: step,\n                langgraph_node: name,\n                langgraph_triggers: triggers,\n                langgraph_path: taskPath,\n                langgraph_checkpoint_ns: taskCheckpointNamespace,\n            };\n            if (forExecution) {\n                const node = proc.getNode();\n                if (node !== undefined) {\n                    if (proc.metadata !== undefined) {\n                        metadata = { ...metadata, ...proc.metadata };\n                    }\n                    const writes = [];\n                    return {\n                        name,\n                        input: val,\n                        proc: node,\n                        subgraphs: proc.subgraphs,\n                        writes,\n                        config: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)((0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(config, {\n                            metadata,\n                            tags: proc.tags,\n                            store: extra.store ?? config.store,\n                        }), {\n                            runName: name,\n                            callbacks: manager?.getChild(`graph:step:${step}`),\n                            configurable: {\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_TASK_ID]: taskId,\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SEND]: (writes_) => _localWrite(step, (items) => {\n                                    writes.push(...items);\n                                }, processes, managed, writes_),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(step, checkpoint, channels, managed, {\n                                    name,\n                                    writes: writes,\n                                    triggers,\n                                    path: taskPath,\n                                }, select_, fresh_),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINTER],\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                                    ...configurable[_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_CHECKPOINT_MAP],\n                                    [parentNamespace]: checkpoint.id,\n                                },\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                                    pendingWrites: pendingWrites ?? [],\n                                    taskId,\n                                    currentTaskInput: val,\n                                }),\n                                [_constants_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[_constants_js__WEBPACK_IMPORTED_MODULE_4__.PREVIOUS],\n                                checkpoint_id: undefined,\n                                checkpoint_ns: taskCheckpointNamespace,\n                            },\n                        }),\n                        triggers,\n                        retry_policy: proc.retryPolicy,\n                        id: taskId,\n                        path: taskPath,\n                        writers: proc.getWriters(),\n                    };\n                }\n            }\n            else {\n                return { id: taskId, name, interrupts: [], path: taskPath };\n            }\n        }\n    }\n    return undefined;\n}\n/**\n *  Function injected under CONFIG_KEY_READ in task config, to read current state.\n *  Used by conditional edges to read a copy of the state with reflecting the writes\n *  from that node only.\n *\n * @internal\n */\nfunction _procInput(step, proc, managed, channels, forExecution) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let val;\n    if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n        val = {};\n        for (const [k, chan] of Object.entries(proc.channels)) {\n            if (proc.triggers.includes(chan)) {\n                try {\n                    val[k] = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                        return undefined;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            else if (chan in channels) {\n                try {\n                    val[k] = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                        continue;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            else {\n                val[k] = managed.get(k)?.call(step);\n            }\n        }\n    }\n    else if (Array.isArray(proc.channels)) {\n        let successfulRead = false;\n        for (const chan of proc.channels) {\n            try {\n                val = (0,_io_js__WEBPACK_IMPORTED_MODULE_3__.readChannel)(channels, chan, false);\n                successfulRead = true;\n                break;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyChannelError.unminifiable_name) {\n                    continue;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        if (!successfulRead) {\n            return undefined;\n        }\n    }\n    else {\n        throw new Error(`Invalid channels type, expected list or dict, got ${proc.channels}`);\n    }\n    // If the process has a mapper, apply it to the value\n    if (forExecution && proc.mapper !== undefined) {\n        val = proc.mapper(val);\n    }\n    return val;\n}\nfunction _scratchpad({ pendingWrites, taskId, currentTaskInput, }) {\n    const nullResume = pendingWrites.find(([writeTaskId, chan]) => writeTaskId === _constants_js__WEBPACK_IMPORTED_MODULE_4__.NULL_TASK_ID && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME)?.[2];\n    const scratchpad = {\n        callCounter: 0,\n        interruptCounter: -1,\n        resume: pendingWrites\n            .filter(([writeTaskId, chan]) => writeTaskId === taskId && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME)\n            .flatMap(([_writeTaskId, _chan, resume]) => resume),\n        nullResume,\n        subgraphCounter: 0,\n        currentTaskInput,\n        consumeNullResume: () => {\n            if (scratchpad.nullResume) {\n                delete scratchpad.nullResume;\n                pendingWrites.splice(pendingWrites.findIndex(([writeTaskId, chan]) => writeTaskId === _constants_js__WEBPACK_IMPORTED_MODULE_4__.NULL_TASK_ID && chan === _constants_js__WEBPACK_IMPORTED_MODULE_4__.RESUME), 1);\n                return nullResume;\n            }\n        },\n    };\n    return scratchpad;\n}\n//# sourceMappingURL=algo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9hbGdvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN1RTtBQUNxQjtBQUNOO0FBQ2xDO0FBQ21WO0FBQ2xXO0FBQ2dDO0FBQ1o7QUFDVjtBQUN4QztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBUztBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLHFEQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQWdCO0FBQzlDLDRCQUE0QixnRUFBYTtBQUN6QyxxQkFBcUIsK0VBQWM7QUFDbkMsaUJBQWlCLG9EQUFZLEdBQUcsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBSSxFQUFFLGdEQUFLO0FBQ3hCLGlCQUFpQixzREFBTztBQUN4QiwwQkFBMEIsMERBQWtCLG9EQUFvRCxzQkFBc0I7QUFDdEg7QUFDQTtBQUNBLDBCQUEwQiwwREFBa0IsdUJBQXVCLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQVM7QUFDYixJQUFJLCtDQUFJO0FBQ1IsSUFBSSxpREFBTTtBQUNWLElBQUksb0RBQVM7QUFDYixJQUFJLGlEQUFNO0FBQ1YsSUFBSSxnREFBSztBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixnRUFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0ZBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdEQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtGQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUFrQjtBQUNqRCw2Q0FBNkMsMERBQWtCLGdDQUFnQyxLQUFLLGdCQUFnQixxQkFBcUIsSUFBSSxVQUFVO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pELHlDQUF5QywrQ0FBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQ0FBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBSSxJQUFJLGlEQUFNO0FBQ3RDO0FBQ0EscUJBQXFCLDREQUFrQjtBQUN2QywwQkFBMEIsK0NBQUk7QUFDOUI7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0IsRUFBRSx5RUFBOEIsQ0FBQyxFQUFFLFVBQVU7QUFDOUUsbUJBQW1CLHNFQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQixFQUFFLG1FQUF3QixDQUFDLEVBQUUsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFXLENBQUMsdUVBQVk7QUFDaEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0EseUJBQXlCLDZEQUFrQjtBQUMzQztBQUNBLHlCQUF5QiwwREFBZTtBQUN4Qyx5QkFBeUIsMERBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCLGtFQUF1QixnQ0FBZ0Msa0VBQXVCO0FBQ3ZHLHlCQUF5QixvRUFBeUI7QUFDbEQsNENBQTRDLG9FQUF5QjtBQUNyRTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUIsZ0VBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUIsb0VBQXlCLDZCQUE2QixtREFBUTtBQUN2RjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrREFBZ0I7QUFDdkMsYUFBYSxzREFBTztBQUNwQixrQkFBa0IsK0NBQUk7QUFDdEI7QUFDQSxhQUFhLCtEQUFnQjtBQUM3QixvREFBb0Qsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUk7QUFDOUI7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0IsRUFBRSx5RUFBOEIsQ0FBQyxFQUFFLFlBQVk7QUFDaEYsdUJBQXVCLHNFQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQUk7QUFDaEI7QUFDQTtBQUNBLDJDQUEyQyxvQkFBb0IsRUFBRSxtRUFBd0IsQ0FBQyxFQUFFLE9BQU87QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBVyxDQUFDLHVFQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0EsNkJBQTZCLDZEQUFrQjtBQUMvQztBQUNBLDZCQUE2QiwwREFBZTtBQUM1Qyw2QkFBNkIsMERBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLGtFQUF1QixnQ0FBZ0Msa0VBQXVCO0FBQzNHLDZCQUE2QixvRUFBeUI7QUFDdEQsZ0RBQWdELG9FQUF5QjtBQUN6RTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsZ0VBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsb0VBQXlCLDZCQUE2QixtREFBUTtBQUMzRjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQixFQUFFLHlFQUE4QixDQUFDLEVBQUUsS0FBSztBQUM3RSwyQkFBMkIsc0VBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixnREFBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNFQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlEQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQixFQUFFLHlFQUE4QixDQUFDLEVBQUUsS0FBSztBQUM3RSwyQkFBMkIsc0VBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CLEVBQUUsbUVBQXdCLENBQUMsRUFBRSxPQUFPO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzRUFBVyxDQUFDLHVFQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHVFQUF1RSxLQUFLO0FBQzVFO0FBQ0EsaUNBQWlDLDZEQUFrQjtBQUNuRDtBQUNBLGlDQUFpQywwREFBZTtBQUNoRDtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUMsMERBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLGtFQUF1QixnQ0FBZ0Msa0VBQXVCO0FBQy9HLGlDQUFpQyxvRUFBeUI7QUFDMUQsb0RBQW9ELG9FQUF5QjtBQUM3RTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUMsZ0VBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUMsb0VBQXlCLDZCQUE2QixtREFBUTtBQUMvRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxjQUFjO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUEwQztBQUNqRSxtRkFBbUYsdURBQVksYUFBYSxpREFBTTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixpREFBTTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyx1REFBWSxhQUFhLGlEQUFNO0FBQ3JJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvYWxnby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHsgbWVyZ2VDb25maWdzLCBwYXRjaENvbmZpZywgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuaW1wb3J0IHsgY29weUNoZWNrcG9pbnQsIHV1aWQ1LCBtYXhDaGFubmVsVmVyc2lvbiwgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2hlY2twb2ludCwgZW1wdHlDaGFubmVscywgaXNCYXNlQ2hhbm5lbCwgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgcmVhZENoYW5uZWwsIHJlYWRDaGFubmVscyB9IGZyb20gXCIuL2lvLmpzXCI7XG5pbXBvcnQgeyBfaXNTZW5kLCBfaXNTZW5kSW50ZXJmYWNlLCBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQLCBDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IsIENPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSLCBDT05GSUdfS0VZX1JFQUQsIENPTkZJR19LRVlfVEFTS19JRCwgQ09ORklHX0tFWV9TRU5ELCBJTlRFUlJVUFQsIFJFU0VSVkVELCBTZW5kLCBUQUdfSElEREVOLCBUQVNLUywgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5ELCBQVVNILCBQVUxMLCBSRVNVTUUsIE5VTExfVEFTS19JRCwgQ09ORklHX0tFWV9TQ1JBVENIUEFELCBSRVRVUk4sIEVSUk9SLCBOT19XUklURVMsIENPTkZJR19LRVlfUFJFVklPVVNfU1RBVEUsIFBSRVZJT1VTLCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGlzQ2FsbCwgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldE51bGxDaGFubmVsVmVyc2lvbiB9IGZyb20gXCIuL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRSdW5uYWJsZUZvckZ1bmMgfSBmcm9tIFwiLi9jYWxsLmpzXCI7XG5leHBvcnQgY29uc3QgaW5jcmVtZW50ID0gKGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gY3VycmVudCAhPT0gdW5kZWZpbmVkID8gY3VycmVudCArIDEgOiAxO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRJbnRlcnJ1cHQoY2hlY2twb2ludCwgaW50ZXJydXB0Tm9kZXMsIHRhc2tzKSB7XG4gICAgY29uc3QgdmVyc2lvblZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKTtcbiAgICBjb25zdCB2ZXJzaW9uVHlwZSA9IHZlcnNpb25WYWx1ZXMubGVuZ3RoID4gMCA/IHR5cGVvZiB2ZXJzaW9uVmFsdWVzWzBdIDogdW5kZWZpbmVkO1xuICAgIGxldCBudWxsVmVyc2lvbjtcbiAgICBpZiAodmVyc2lvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbnVsbFZlcnNpb24gPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ZXJzaW9uVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBudWxsVmVyc2lvbiA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHNlZW4gPSBjaGVja3BvaW50LnZlcnNpb25zX3NlZW5bSU5URVJSVVBUXSA/PyB7fTtcbiAgICBjb25zdCBhbnlDaGFubmVsVXBkYXRlZCA9IE9iamVjdC5lbnRyaWVzKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykuc29tZSgoW2NoYW4sIHZlcnNpb25dKSA9PiB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uID4gKHNlZW5bY2hhbl0gPz8gbnVsbFZlcnNpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IGFueVRyaWdnZXJlZE5vZGVJbkludGVycnVwdE5vZGVzID0gdGFza3Muc29tZSgodGFzaykgPT4gaW50ZXJydXB0Tm9kZXMgPT09IFwiKlwiXG4gICAgICAgID8gIXRhc2suY29uZmlnPy50YWdzPy5pbmNsdWRlcyhUQUdfSElEREVOKVxuICAgICAgICA6IGludGVycnVwdE5vZGVzLmluY2x1ZGVzKHRhc2submFtZSkpO1xuICAgIHJldHVybiBhbnlDaGFubmVsVXBkYXRlZCAmJiBhbnlUcmlnZ2VyZWROb2RlSW5JbnRlcnJ1cHROb2Rlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbG9jYWxSZWFkKHN0ZXAsIGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBtYW5hZ2VkLCB0YXNrLCBzZWxlY3QsIGZyZXNoID0gZmFsc2UpIHtcbiAgICBsZXQgbWFuYWdlZEtleXMgPSBbXTtcbiAgICBsZXQgdXBkYXRlZCA9IG5ldyBTZXQoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0KSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtjXSBvZiB0YXNrLndyaXRlcykge1xuICAgICAgICAgICAgaWYgKGMgPT09IHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBuZXcgU2V0KFtjXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZWQgfHwgbmV3IFNldCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFuYWdlZEtleXMgPSBzZWxlY3QuZmlsdGVyKChrKSA9PiBtYW5hZ2VkLmdldChrKSk7XG4gICAgICAgIHNlbGVjdCA9IHNlbGVjdC5maWx0ZXIoKGspID0+ICFtYW5hZ2VkLmdldChrKSk7XG4gICAgICAgIHVwZGF0ZWQgPSBuZXcgU2V0KHNlbGVjdC5maWx0ZXIoKGMpID0+IHRhc2sud3JpdGVzLnNvbWUoKFtrZXksIF9dKSA9PiBrZXkgPT09IGMpKSk7XG4gICAgfVxuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKGZyZXNoICYmIHVwZGF0ZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgbG9jYWxDaGFubmVscyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaGFubmVscykuZmlsdGVyKChbaywgX10pID0+IHVwZGF0ZWQuaGFzKGspKSk7XG4gICAgICAgIGNvbnN0IG5ld0NoZWNrcG9pbnQgPSBjcmVhdGVDaGVja3BvaW50KGNoZWNrcG9pbnQsIGxvY2FsQ2hhbm5lbHMsIC0xKTtcbiAgICAgICAgY29uc3QgbmV3Q2hhbm5lbHMgPSBlbXB0eUNoYW5uZWxzKGxvY2FsQ2hhbm5lbHMsIG5ld0NoZWNrcG9pbnQpO1xuICAgICAgICBfYXBwbHlXcml0ZXMoY29weUNoZWNrcG9pbnQobmV3Q2hlY2twb2ludCksIG5ld0NoYW5uZWxzLCBbdGFza10pO1xuICAgICAgICB2YWx1ZXMgPSByZWFkQ2hhbm5lbHMoeyAuLi5jaGFubmVscywgLi4ubmV3Q2hhbm5lbHMgfSwgc2VsZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IHJlYWRDaGFubmVscyhjaGFubmVscywgc2VsZWN0KTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIG1hbmFnZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBtYW5hZ2VkVmFsdWUgPSBtYW5hZ2VkLmdldChrKTtcbiAgICAgICAgICAgIGlmIChtYW5hZ2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRPZk1hbmFnZWRDYWxsID0gbWFuYWdlZFZhbHVlLmNhbGwoc3RlcCk7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gcmVzdWx0T2ZNYW5hZ2VkQ2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9sb2NhbFdyaXRlKHN0ZXAsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbW1pdCwgcHJvY2Vzc2VzLCBtYW5hZ2VkLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG53cml0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtjaGFuLCB2YWx1ZV0gb2Ygd3JpdGVzKSB7XG4gICAgICAgIGlmIChbUFVTSCwgVEFTS1NdLmluY2x1ZGVzKGNoYW4pICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghX2lzU2VuZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBJbnZhbGlkIHBhY2tldCB0eXBlLCBleHBlY3RlZCBTZW5kUHJvdG9jb2wsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHZhbHVlLm5vZGUgaW4gcHJvY2Vzc2VzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYEludmFsaWQgbm9kZSBuYW1lIFwiJHt2YWx1ZS5ub2RlfVwiIGluIFNlbmQgcGFja2V0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXBsYWNlIGFueSBydW50aW1lIHZhbHVlcyB3aXRoIHBsYWNlaG9sZGVyc1xuICAgICAgICAgICAgbWFuYWdlZC5yZXBsYWNlUnVudGltZVZhbHVlcyhzdGVwLCB2YWx1ZS5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21taXQod3JpdGVzKTtcbn1cbmNvbnN0IElHTk9SRSA9IG5ldyBTZXQoW1xuICAgIE5PX1dSSVRFUyxcbiAgICBQVVNILFxuICAgIFJFU1VNRSxcbiAgICBJTlRFUlJVUFQsXG4gICAgUkVUVVJOLFxuICAgIEVSUk9SLFxuXSk7XG5leHBvcnQgZnVuY3Rpb24gX2FwcGx5V3JpdGVzKGNoZWNrcG9pbnQsIGNoYW5uZWxzLCB0YXNrcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZ2V0TmV4dFZlcnNpb24pIHtcbiAgICAvLyBTb3J0IHRhc2tzIGJ5IGZpcnN0IDMgcGF0aCBlbGVtZW50cyBmb3IgZGV0ZXJtaW5pc3RpYyBvcmRlclxuICAgIC8vIExhdGVyIHBhdGggcGFydHMgKGxpa2UgdGFzayBJRHMpIGFyZSBpZ25vcmVkIGZvciBzb3J0aW5nXG4gICAgdGFza3Muc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBhUGF0aCA9IGEucGF0aD8uc2xpY2UoMCwgMykgfHwgW107XG4gICAgICAgIGNvbnN0IGJQYXRoID0gYi5wYXRoPy5zbGljZSgwLCAzKSB8fCBbXTtcbiAgICAgICAgLy8gQ29tcGFyZSBlYWNoIHBhdGggZWxlbWVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGFQYXRoLmxlbmd0aCwgYlBhdGgubGVuZ3RoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoYVBhdGhbaV0gPCBiUGF0aFtpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYVBhdGhbaV0gPiBiUGF0aFtpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBvbmUgcGF0aCBpcyBzaG9ydGVyLCBpdCBjb21lcyBmaXJzdFxuICAgICAgICByZXR1cm4gYVBhdGgubGVuZ3RoIC0gYlBhdGgubGVuZ3RoO1xuICAgIH0pO1xuICAgIC8vIGlmIG5vIHRhc2sgaGFzIHRyaWdnZXJzIHRoaXMgaXMgYXBwbHlpbmcgd3JpdGVzIGZyb20gdGhlIG51bGwgdGFzayBvbmx5XG4gICAgLy8gc28gd2UgZG9uJ3QgZG8gYW55dGhpbmcgb3RoZXIgdGhhbiB1cGRhdGUgdGhlIGNoYW5uZWxzIHdyaXR0ZW4gdG9cbiAgICBjb25zdCBidW1wU3RlcCA9IHRhc2tzLnNvbWUoKHRhc2spID0+IHRhc2sudHJpZ2dlcnMubGVuZ3RoID4gMCk7XG4gICAgLy8gRmlsdGVyIG91dCBub24gaW5zdGFuY2VzIG9mIEJhc2VDaGFubmVsXG4gICAgY29uc3Qgb25seUNoYW5uZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNoYW5uZWxzKS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IGlzQmFzZUNoYW5uZWwodmFsdWUpKSk7XG4gICAgLy8gVXBkYXRlIHNlZW4gdmVyc2lvbnNcbiAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQudmVyc2lvbnNfc2Vlblt0YXNrLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoZWNrcG9pbnQudmVyc2lvbnNfc2Vlblt0YXNrLm5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaGFuIG9mIHRhc2sudHJpZ2dlcnMpIHtcbiAgICAgICAgICAgIGlmIChjaGFuIGluIGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykge1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQudmVyc2lvbnNfc2Vlblt0YXNrLm5hbWVdW2NoYW5dID1cbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zW2NoYW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGhpZ2hlc3QgdmVyc2lvbiBvZiBhbGwgY2hhbm5lbHNcbiAgICBsZXQgbWF4VmVyc2lvbjtcbiAgICBpZiAoT2JqZWN0LmtleXMoY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1heFZlcnNpb24gPSBtYXhDaGFubmVsVmVyc2lvbiguLi5PYmplY3QudmFsdWVzKGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykpO1xuICAgIH1cbiAgICAvLyBDb25zdW1lIGFsbCBjaGFubmVscyB0aGF0IHdlcmUgcmVhZFxuICAgIGNvbnN0IGNoYW5uZWxzVG9Db25zdW1lID0gbmV3IFNldCh0YXNrc1xuICAgICAgICAuZmxhdE1hcCgodGFzaykgPT4gdGFzay50cmlnZ2VycylcbiAgICAgICAgLmZpbHRlcigoY2hhbikgPT4gIVJFU0VSVkVELmluY2x1ZGVzKGNoYW4pKSk7XG4gICAgZm9yIChjb25zdCBjaGFuIG9mIGNoYW5uZWxzVG9Db25zdW1lKSB7XG4gICAgICAgIGlmIChjaGFuIGluIG9ubHlDaGFubmVscyAmJiBvbmx5Q2hhbm5lbHNbY2hhbl0uY29uc3VtZSgpKSB7XG4gICAgICAgICAgICBpZiAoZ2V0TmV4dFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFuXSA9IGdldE5leHRWZXJzaW9uKG1heFZlcnNpb24sIG9ubHlDaGFubmVsc1tjaGFuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYXIgcGVuZGluZyBzZW5kc1xuICAgIGlmIChjaGVja3BvaW50LnBlbmRpbmdfc2VuZHM/Lmxlbmd0aCAmJiBidW1wU3RlcCkge1xuICAgICAgICBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHMgPSBbXTtcbiAgICB9XG4gICAgLy8gR3JvdXAgd3JpdGVzIGJ5IGNoYW5uZWxcbiAgICBjb25zdCBwZW5kaW5nV3JpdGVWYWx1ZXNCeUNoYW5uZWwgPSB7fTtcbiAgICBjb25zdCBwZW5kaW5nV3JpdGVzQnlNYW5hZ2VkID0ge307XG4gICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2NoYW4sIHZhbF0gb2YgdGFzay53cml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChJR05PUkUuaGFzKGNoYW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbiA9PT0gVEFTS1MpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgYnJhbmNoIGluIDEuMFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQucGVuZGluZ19zZW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdmFsLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHZhbC5hcmdzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbiBpbiBvbmx5Q2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbiBpbiBwZW5kaW5nV3JpdGVWYWx1ZXNCeUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dyaXRlVmFsdWVzQnlDaGFubmVsW2NoYW5dLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZVZhbHVlc0J5Q2hhbm5lbFtjaGFuXSA9IFt2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuIGluIHBlbmRpbmdXcml0ZXNCeU1hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dyaXRlc0J5TWFuYWdlZFtjaGFuXS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV3JpdGVzQnlNYW5hZ2VkW2NoYW5dID0gW3ZhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIGhpZ2hlc3QgdmVyc2lvbiBvZiBhbGwgY2hhbm5lbHNcbiAgICBtYXhWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgIGlmIChPYmplY3Qua2V5cyhjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWF4VmVyc2lvbiA9IG1heENoYW5uZWxWZXJzaW9uKC4uLk9iamVjdC52YWx1ZXMoY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKSk7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWRDaGFubmVscyA9IG5ldyBTZXQoKTtcbiAgICAvLyBBcHBseSB3cml0ZXMgdG8gY2hhbm5lbHNcbiAgICBmb3IgKGNvbnN0IFtjaGFuLCB2YWxzXSBvZiBPYmplY3QuZW50cmllcyhwZW5kaW5nV3JpdGVWYWx1ZXNCeUNoYW5uZWwpKSB7XG4gICAgICAgIGlmIChjaGFuIGluIG9ubHlDaGFubmVscykge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBvbmx5Q2hhbm5lbHNbY2hhbl0udXBkYXRlKHZhbHMpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IEludmFsaWRVcGRhdGVFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVkRXJyb3IgPSBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBJbnZhbGlkIHVwZGF0ZSBmb3IgY2hhbm5lbCBcIiR7Y2hhbn1cIiB3aXRoIHZhbHVlcyAke0pTT04uc3RyaW5naWZ5KHZhbHMpfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFcnJvci5sY19lcnJvcl9jb2RlID0gZS5sY19lcnJvcl9jb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cmFwcGVkRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVkICYmIGdldE5leHRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnNbY2hhbl0gPSBnZXROZXh0VmVyc2lvbihtYXhWZXJzaW9uLCBvbmx5Q2hhbm5lbHNbY2hhbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZENoYW5uZWxzLmFkZChjaGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGFubmVscyB0aGF0IHdlcmVuJ3QgdXBkYXRlZCBpbiB0aGlzIHN0ZXAgYXJlIG5vdGlmaWVkIG9mIGEgbmV3IHN0ZXBcbiAgICBpZiAoYnVtcFN0ZXApIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuIG9mIE9iamVjdC5rZXlzKG9ubHlDaGFubmVscykpIHtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZENoYW5uZWxzLmhhcyhjaGFuKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSBvbmx5Q2hhbm5lbHNbY2hhbl0udXBkYXRlKFtdKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCAmJiBnZXROZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFuXSA9IGdldE5leHRWZXJzaW9uKG1heFZlcnNpb24sIG9ubHlDaGFubmVsc1tjaGFuXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBtYW5hZ2VkIHZhbHVlcyB3cml0ZXMgdG8gYmUgYXBwbGllZCBleHRlcm5hbGx5XG4gICAgcmV0dXJuIHBlbmRpbmdXcml0ZXNCeU1hbmFnZWQ7XG59XG4vKipcbiAqIFByZXBhcmUgdGhlIHNldCBvZiB0YXNrcyB0aGF0IHdpbGwgbWFrZSB1cCB0aGUgbmV4dCBQcmVnZWwgc3RlcC5cbiAqIFRoaXMgaXMgdGhlIHVuaW9uIG9mIGFsbCBQVVNIIHRhc2tzIChTZW5kcykgYW5kIFBVTEwgdGFza3MgKG5vZGVzIHRyaWdnZXJlZFxuICogYnkgZWRnZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3ByZXBhcmVOZXh0VGFza3MoY2hlY2twb2ludCwgcGVuZGluZ1dyaXRlcywgcHJvY2Vzc2VzLCBjaGFubmVscywgbWFuYWdlZCwgY29uZmlnLCBmb3JFeGVjdXRpb24sIGV4dHJhKSB7XG4gICAgY29uc3QgdGFza3MgPSB7fTtcbiAgICAvLyBDb25zdW1lIHBlbmRpbmcgcGFja2V0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBfcHJlcGFyZVNpbmdsZVRhc2soW1BVU0gsIGldLCBjaGVja3BvaW50LCBwZW5kaW5nV3JpdGVzLCBwcm9jZXNzZXMsIGNoYW5uZWxzLCBtYW5hZ2VkLCBjb25maWcsIGZvckV4ZWN1dGlvbiwgZXh0cmEpO1xuICAgICAgICBpZiAodGFzayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXNrc1t0YXNrLmlkXSA9IHRhc2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IHByb2Nlc3NlcyBzaG91bGQgYmUgcnVuIGluIG5leHQgc3RlcFxuICAgIC8vIElmIHNvLCBwcmVwYXJlIHRoZSB2YWx1ZXMgdG8gYmUgcGFzc2VkIHRvIHRoZW1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMocHJvY2Vzc2VzKSkge1xuICAgICAgICBjb25zdCB0YXNrID0gX3ByZXBhcmVTaW5nbGVUYXNrKFtQVUxMLCBuYW1lXSwgY2hlY2twb2ludCwgcGVuZGluZ1dyaXRlcywgcHJvY2Vzc2VzLCBjaGFubmVscywgbWFuYWdlZCwgY29uZmlnLCBmb3JFeGVjdXRpb24sIGV4dHJhKTtcbiAgICAgICAgaWYgKHRhc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFza3NbdGFzay5pZF0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXNrcztcbn1cbi8qKlxuICogUHJlcGFyZXMgYSBzaW5nbGUgdGFzayBmb3IgdGhlIG5leHQgUHJlZ2VsIHN0ZXAsIGdpdmVuIGEgdGFzayBwYXRoLCB3aGljaFxuICogdW5pcXVlbHkgaWRlbnRpZmllcyBhIFBVU0ggb3IgUFVMTCB0YXNrIHdpdGhpbiB0aGUgZ3JhcGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcHJlcGFyZVNpbmdsZVRhc2sodGFza1BhdGgsIGNoZWNrcG9pbnQsIHBlbmRpbmdXcml0ZXMsIHByb2Nlc3NlcywgY2hhbm5lbHMsIG1hbmFnZWQsIGNvbmZpZywgZm9yRXhlY3V0aW9uLCBleHRyYSkge1xuICAgIGNvbnN0IHsgc3RlcCwgY2hlY2twb2ludGVyLCBtYW5hZ2VyIH0gPSBleHRyYTtcbiAgICBjb25zdCBjb25maWd1cmFibGUgPSBjb25maWcuY29uZmlndXJhYmxlID8/IHt9O1xuICAgIGNvbnN0IHBhcmVudE5hbWVzcGFjZSA9IGNvbmZpZ3VyYWJsZS5jaGVja3BvaW50X25zID8/IFwiXCI7XG4gICAgaWYgKHRhc2tQYXRoWzBdID09PSBQVVNIICYmIGlzQ2FsbCh0YXNrUGF0aFt0YXNrUGF0aC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgY29uc3QgY2FsbCA9IHRhc2tQYXRoW3Rhc2tQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBwcm9jID0gZ2V0UnVubmFibGVGb3JGdW5jKGNhbGwubmFtZSwgY2FsbC5mdW5jKTtcbiAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSBbUFVTSF07XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2UgPT09IFwiXCJcbiAgICAgICAgICAgID8gY2FsbC5uYW1lXG4gICAgICAgICAgICA6IGAke3BhcmVudE5hbWVzcGFjZX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUn0ke2NhbGwubmFtZX1gO1xuICAgICAgICBjb25zdCBpZCA9IHV1aWQ1KEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgIGNoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICBzdGVwLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjYWxsLm5hbWUsXG4gICAgICAgICAgICBQVVNILFxuICAgICAgICAgICAgdGFza1BhdGhbMV0sXG4gICAgICAgICAgICB0YXNrUGF0aFsyXSxcbiAgICAgICAgXSksIGNoZWNrcG9pbnQuaWQpO1xuICAgICAgICBjb25zdCB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSA9IGAke2NoZWNrcG9pbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkR9JHtpZH1gO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGxhbmdncmFwaF9zdGVwOiBzdGVwLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX25vZGU6IGNhbGwubmFtZSxcbiAgICAgICAgICAgIGxhbmdncmFwaF90cmlnZ2VyczogdHJpZ2dlcnMsXG4gICAgICAgICAgICBsYW5nZ3JhcGhfcGF0aDogdGFza1BhdGguc2xpY2UoMCwgMyksXG4gICAgICAgICAgICBsYW5nZ3JhcGhfY2hlY2twb2ludF9uczogdGFza0NoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmb3JFeGVjdXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBjYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGNhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgcHJvYyxcbiAgICAgICAgICAgICAgICB3cml0ZXMsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXRjaENvbmZpZyhtZXJnZUNvbmZpZ3MoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZTogZXh0cmEuc3RvcmUgPz8gY29uZmlnLnN0b3JlLFxuICAgICAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bk5hbWU6IGNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBtYW5hZ2VyPy5nZXRDaGlsZChgZ3JhcGg6c3RlcDoke3N0ZXB9YCksXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfVEFTS19JRF06IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NFTkRdOiAod3JpdGVzXykgPT4gX2xvY2FsV3JpdGUoc3RlcCwgKGl0ZW1zKSA9PiB3cml0ZXMucHVzaCguLi5pdGVtcyksIHByb2Nlc3NlcywgbWFuYWdlZCwgd3JpdGVzXyksXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9SRUFEXTogKHNlbGVjdF8sIGZyZXNoXyA9IGZhbHNlKSA9PiBfbG9jYWxSZWFkKHN0ZXAsIGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBtYW5hZ2VkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogd3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHRhc2tQYXRoLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VsZWN0XywgZnJlc2hfKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IGNoZWNrcG9pbnRlciA/PyBjb25maWd1cmFibGVbQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJlbnROYW1lc3BhY2VdOiBjaGVja3BvaW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NDUkFUQ0hQQURdOiBfc2NyYXRjaHBhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dyaXRlczogcGVuZGluZ1dyaXRlcyA/PyBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5wdXQ6IGNhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1BSRVZJT1VTX1NUQVRFXTogY2hlY2twb2ludC5jaGFubmVsX3ZhbHVlc1tQUkVWSU9VU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICByZXRyeV9wb2xpY3k6IGNhbGwucmV0cnksXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGguc2xpY2UoMCwgMyksXG4gICAgICAgICAgICAgICAgd3JpdGVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRzOiBbXSxcbiAgICAgICAgICAgICAgICBwYXRoOiB0YXNrUGF0aC5zbGljZSgwLCAzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGFza1BhdGhbMF0gPT09IFBVU0gpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0eXBlb2YgdGFza1BhdGhbMV0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8gdGFza1BhdGhbMV1cbiAgICAgICAgICAgIDogcGFyc2VJbnQodGFza1BhdGhbMV0sIDEwKTtcbiAgICAgICAgaWYgKGluZGV4ID49IGNoZWNrcG9pbnQucGVuZGluZ19zZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0gX2lzU2VuZEludGVyZmFjZShjaGVja3BvaW50LnBlbmRpbmdfc2VuZHNbaW5kZXhdKSAmJlxuICAgICAgICAgICAgIV9pc1NlbmQoY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzW2luZGV4XSlcbiAgICAgICAgICAgID8gbmV3IFNlbmQoY2hlY2twb2ludC5wZW5kaW5nX3NlbmRzW2luZGV4XS5ub2RlLCBjaGVja3BvaW50LnBlbmRpbmdfc2VuZHNbaW5kZXhdLmFyZ3MpXG4gICAgICAgICAgICA6IGNoZWNrcG9pbnQucGVuZGluZ19zZW5kc1tpbmRleF07XG4gICAgICAgIGlmICghX2lzU2VuZEludGVyZmFjZShwYWNrZXQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYElnbm9yaW5nIGludmFsaWQgcGFja2V0ICR7SlNPTi5zdHJpbmdpZnkocGFja2V0KX0gaW4gcGVuZGluZyBzZW5kcy5gKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocGFja2V0Lm5vZGUgaW4gcHJvY2Vzc2VzKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJZ25vcmluZyB1bmtub3duIG5vZGUgbmFtZSAke3BhY2tldC5ub2RlfSBpbiBwZW5kaW5nIHNlbmRzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmlnZ2VycyA9IFtQVVNIXTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZSA9PT0gXCJcIlxuICAgICAgICAgICAgPyBwYWNrZXQubm9kZVxuICAgICAgICAgICAgOiBgJHtwYXJlbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1J9JHtwYWNrZXQubm9kZX1gO1xuICAgICAgICBjb25zdCB0YXNrSWQgPSB1dWlkNShKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICBjaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgc3RlcC50b1N0cmluZygpLFxuICAgICAgICAgICAgcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICBQVVNILFxuICAgICAgICAgICAgaW5kZXgudG9TdHJpbmcoKSxcbiAgICAgICAgXSksIGNoZWNrcG9pbnQuaWQpO1xuICAgICAgICBjb25zdCB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSA9IGAke2NoZWNrcG9pbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkR9JHt0YXNrSWR9YDtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgbGFuZ2dyYXBoX3N0ZXA6IHN0ZXAsXG4gICAgICAgICAgICBsYW5nZ3JhcGhfbm9kZTogcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICBsYW5nZ3JhcGhfdHJpZ2dlcnM6IHRyaWdnZXJzLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX3BhdGg6IHRhc2tQYXRoLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgbGFuZ2dyYXBoX2NoZWNrcG9pbnRfbnM6IHRhc2tDaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZm9yRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jID0gcHJvY2Vzc2VzW3BhY2tldC5ub2RlXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwcm9jLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkLnJlcGxhY2VSdW50aW1lUGxhY2Vob2xkZXJzKHN0ZXAsIHBhY2tldC5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvYy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0geyAuLi5tZXRhZGF0YSwgLi4ucHJvYy5tZXRhZGF0YSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYWNrZXQubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhY2tldC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICBwcm9jOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICBzdWJncmFwaHM6IHByb2Muc3ViZ3JhcGhzLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogcGF0Y2hDb25maWcobWVyZ2VDb25maWdzKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBwcm9jLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZXh0cmEuc3RvcmUgPz8gY29uZmlnLnN0b3JlLFxuICAgICAgICAgICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuTmFtZTogcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG1hbmFnZXI/LmdldENoaWxkKGBncmFwaDpzdGVwOiR7c3RlcH1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1RBU0tfSURdOiB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TRU5EXTogKHdyaXRlc18pID0+IF9sb2NhbFdyaXRlKHN0ZXAsIChpdGVtcykgPT4gd3JpdGVzLnB1c2goLi4uaXRlbXMpLCBwcm9jZXNzZXMsIG1hbmFnZWQsIHdyaXRlc18pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1JFQURdOiAoc2VsZWN0XywgZnJlc2hfID0gZmFsc2UpID0+IF9sb2NhbFJlYWQoc3RlcCwgY2hlY2twb2ludCwgY2hhbm5lbHMsIG1hbmFnZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogd3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VsZWN0XywgZnJlc2hfKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdOiBjaGVja3BvaW50ZXIgPz8gY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyZW50TmFtZXNwYWNlXTogY2hlY2twb2ludC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NDUkFUQ0hQQURdOiBfc2NyYXRjaHBhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXM6IHBlbmRpbmdXcml0ZXMgPz8gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbnB1dDogcGFja2V0LmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUFJFVklPVVNfU1RBVEVdOiBjaGVja3BvaW50LmNoYW5uZWxfdmFsdWVzW1BSRVZJT1VTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGFza0NoZWNrcG9pbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5X3BvbGljeTogcHJvYy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRhc2tJZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlcnM6IHByb2MuZ2V0V3JpdGVycygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFja2V0Lm5vZGUsXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0czogW10sXG4gICAgICAgICAgICAgICAgcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhc2tQYXRoWzBdID09PSBQVUxMKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0YXNrUGF0aFsxXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBwcm9jID0gcHJvY2Vzc2VzW25hbWVdO1xuICAgICAgICBpZiAocHJvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdGFzayBhbHJlYWR5IGhhcyBzdWNjZXNzZnVsIHdyaXRlcyBpbiB0aGUgcGVuZGluZyB3cml0ZXNcbiAgICAgICAgaWYgKHBlbmRpbmdXcml0ZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGFzayBJRCBmb3IgdGhpcyBub2RlL3BhdGhcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnROYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2UgPT09IFwiXCJcbiAgICAgICAgICAgICAgICA/IG5hbWVcbiAgICAgICAgICAgICAgICA6IGAke3BhcmVudE5hbWVzcGFjZX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUn0ke25hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tJZCA9IHV1aWQ1KEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHN0ZXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIFBVTEwsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIF0pLCBjaGVja3BvaW50LmlkKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBzdWNjZXNzZnVsIHdyaXRlcyAobm90IEVSUk9SKSBmb3IgdGhpcyB0YXNrIElEXG4gICAgICAgICAgICBjb25zdCBoYXNTdWNjZXNzZnVsV3JpdGVzID0gcGVuZGluZ1dyaXRlcy5zb21lKCh3KSA9PiB3WzBdID09PSB0YXNrSWQgJiYgd1sxXSAhPT0gRVJST1IpO1xuICAgICAgICAgICAgLy8gSWYgdGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBkb24ndCBpbmNsdWRlIGl0IGluIG5leHQgdGFza3NcbiAgICAgICAgICAgIGlmIChoYXNTdWNjZXNzZnVsV3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudWxsVmVyc2lvbiA9IGdldE51bGxDaGFubmVsVmVyc2lvbihjaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMpO1xuICAgICAgICBpZiAobnVsbFZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVuID0gY2hlY2twb2ludC52ZXJzaW9uc19zZWVuW25hbWVdID8/IHt9O1xuICAgICAgICBjb25zdCB0cmlnZ2VycyA9IHByb2MudHJpZ2dlcnNcbiAgICAgICAgICAgIC5maWx0ZXIoKGNoYW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRDaGFubmVsKGNoYW5uZWxzLCBjaGFuLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5Q2hhbm5lbEVycm9yID0gXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICByZXN1bHQgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZTtcbiAgICAgICAgICAgIHJldHVybiAoIWlzRW1wdHlDaGFubmVsRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAoY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zW2NoYW5dID8/IG51bGxWZXJzaW9uKSA+XG4gICAgICAgICAgICAgICAgICAgIChzZWVuW2NoYW5dID8/IG51bGxWZXJzaW9uKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgpO1xuICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGNoYW5uZWxzIHJlYWQgYnkgdGhpcyBwcm9jZXNzIHdlcmUgdXBkYXRlZFxuICAgICAgICBpZiAodHJpZ2dlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gX3Byb2NJbnB1dChzdGVwLCBwcm9jLCBtYW5hZ2VkLCBjaGFubmVscywgZm9yRXhlY3V0aW9uKTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlID09PSBcIlwiXG4gICAgICAgICAgICAgICAgPyBuYW1lXG4gICAgICAgICAgICAgICAgOiBgJHtwYXJlbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1J9JHtuYW1lfWA7XG4gICAgICAgICAgICBjb25zdCB0YXNrSWQgPSB1dWlkNShKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBzdGVwLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBQVUxMLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzLFxuICAgICAgICAgICAgXSksIGNoZWNrcG9pbnQuaWQpO1xuICAgICAgICAgICAgY29uc3QgdGFza0NoZWNrcG9pbnROYW1lc3BhY2UgPSBgJHtjaGVja3BvaW50TmFtZXNwYWNlfSR7Q0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5EfSR7dGFza0lkfWA7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbGFuZ2dyYXBoX3N0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgICAgbGFuZ2dyYXBoX25vZGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbGFuZ2dyYXBoX3RyaWdnZXJzOiB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICBsYW5nZ3JhcGhfcGF0aDogdGFza1BhdGgsXG4gICAgICAgICAgICAgICAgbGFuZ2dyYXBoX2NoZWNrcG9pbnRfbnM6IHRhc2tDaGVja3BvaW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmb3JFeGVjdXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gcHJvYy5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvYy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEsIC4uLnByb2MubWV0YWRhdGEgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvYzogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoczogcHJvYy5zdWJncmFwaHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IHBhdGNoQ29uZmlnKG1lcmdlQ29uZmlncyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBwcm9jLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGV4dHJhLnN0b3JlID8/IGNvbmZpZy5zdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG1hbmFnZXI/LmdldENoaWxkKGBncmFwaDpzdGVwOiR7c3RlcH1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfVEFTS19JRF06IHRhc2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfU0VORF06ICh3cml0ZXNfKSA9PiBfbG9jYWxXcml0ZShzdGVwLCAoaXRlbXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlcy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcHJvY2Vzc2VzLCBtYW5hZ2VkLCB3cml0ZXNfKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUkVBRF06IChzZWxlY3RfLCBmcmVzaF8gPSBmYWxzZSkgPT4gX2xvY2FsUmVhZChzdGVwLCBjaGVja3BvaW50LCBjaGFubmVscywgbWFuYWdlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogd3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0YXNrUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VsZWN0XywgZnJlc2hfKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXTogY2hlY2twb2ludGVyID8/IGNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmVudE5hbWVzcGFjZV06IGNoZWNrcG9pbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NDUkFUQ0hQQURdOiBfc2NyYXRjaHBhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV3JpdGVzOiBwZW5kaW5nV3JpdGVzID8/IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbnB1dDogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUFJFVklPVVNfU1RBVEVdOiBjaGVja3BvaW50LmNoYW5uZWxfdmFsdWVzW1BSRVZJT1VTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiB0YXNrQ2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5X3BvbGljeTogcHJvYy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0YXNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0YXNrUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlcnM6IHByb2MuZ2V0V3JpdGVycygpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiB0YXNrSWQsIG5hbWUsIGludGVycnVwdHM6IFtdLCBwYXRoOiB0YXNrUGF0aCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqICBGdW5jdGlvbiBpbmplY3RlZCB1bmRlciBDT05GSUdfS0VZX1JFQUQgaW4gdGFzayBjb25maWcsIHRvIHJlYWQgY3VycmVudCBzdGF0ZS5cbiAqICBVc2VkIGJ5IGNvbmRpdGlvbmFsIGVkZ2VzIHRvIHJlYWQgYSBjb3B5IG9mIHRoZSBzdGF0ZSB3aXRoIHJlZmxlY3RpbmcgdGhlIHdyaXRlc1xuICogIGZyb20gdGhhdCBub2RlIG9ubHkuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9wcm9jSW5wdXQoc3RlcCwgcHJvYywgbWFuYWdlZCwgY2hhbm5lbHMsIGZvckV4ZWN1dGlvbikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IHZhbDtcbiAgICBpZiAodHlwZW9mIHByb2MuY2hhbm5lbHMgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocHJvYy5jaGFubmVscykpIHtcbiAgICAgICAgdmFsID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ssIGNoYW5dIG9mIE9iamVjdC5lbnRyaWVzKHByb2MuY2hhbm5lbHMpKSB7XG4gICAgICAgICAgICBpZiAocHJvYy50cmlnZ2Vycy5pbmNsdWRlcyhjaGFuKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFtrXSA9IHJlYWRDaGFubmVsKGNoYW5uZWxzLCBjaGFuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IEVtcHR5Q2hhbm5lbEVycm9yLnVubWluaWZpYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW4gaW4gY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWxba10gPSByZWFkQ2hhbm5lbChjaGFubmVscywgY2hhbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsW2tdID0gbWFuYWdlZC5nZXQoayk/LmNhbGwoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9jLmNoYW5uZWxzKSkge1xuICAgICAgICBsZXQgc3VjY2Vzc2Z1bFJlYWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuIG9mIHByb2MuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcmVhZENoYW5uZWwoY2hhbm5lbHMsIGNoYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzZnVsUmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWxSZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhbm5lbHMgdHlwZSwgZXhwZWN0ZWQgbGlzdCBvciBkaWN0LCBnb3QgJHtwcm9jLmNoYW5uZWxzfWApO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcHJvY2VzcyBoYXMgYSBtYXBwZXIsIGFwcGx5IGl0IHRvIHRoZSB2YWx1ZVxuICAgIGlmIChmb3JFeGVjdXRpb24gJiYgcHJvYy5tYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSBwcm9jLm1hcHBlcih2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gX3NjcmF0Y2hwYWQoeyBwZW5kaW5nV3JpdGVzLCB0YXNrSWQsIGN1cnJlbnRUYXNrSW5wdXQsIH0pIHtcbiAgICBjb25zdCBudWxsUmVzdW1lID0gcGVuZGluZ1dyaXRlcy5maW5kKChbd3JpdGVUYXNrSWQsIGNoYW5dKSA9PiB3cml0ZVRhc2tJZCA9PT0gTlVMTF9UQVNLX0lEICYmIGNoYW4gPT09IFJFU1VNRSk/LlsyXTtcbiAgICBjb25zdCBzY3JhdGNocGFkID0ge1xuICAgICAgICBjYWxsQ291bnRlcjogMCxcbiAgICAgICAgaW50ZXJydXB0Q291bnRlcjogLTEsXG4gICAgICAgIHJlc3VtZTogcGVuZGluZ1dyaXRlc1xuICAgICAgICAgICAgLmZpbHRlcigoW3dyaXRlVGFza0lkLCBjaGFuXSkgPT4gd3JpdGVUYXNrSWQgPT09IHRhc2tJZCAmJiBjaGFuID09PSBSRVNVTUUpXG4gICAgICAgICAgICAuZmxhdE1hcCgoW193cml0ZVRhc2tJZCwgX2NoYW4sIHJlc3VtZV0pID0+IHJlc3VtZSksXG4gICAgICAgIG51bGxSZXN1bWUsXG4gICAgICAgIHN1YmdyYXBoQ291bnRlcjogMCxcbiAgICAgICAgY3VycmVudFRhc2tJbnB1dCxcbiAgICAgICAgY29uc3VtZU51bGxSZXN1bWU6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JhdGNocGFkLm51bGxSZXN1bWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2NyYXRjaHBhZC5udWxsUmVzdW1lO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMuc3BsaWNlKHBlbmRpbmdXcml0ZXMuZmluZEluZGV4KChbd3JpdGVUYXNrSWQsIGNoYW5dKSA9PiB3cml0ZVRhc2tJZCA9PT0gTlVMTF9UQVNLX0lEICYmIGNoYW4gPT09IFJFU1VNRSksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsUmVzdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHNjcmF0Y2hwYWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGdvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/algo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/call.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/call.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   call: () => (/* binding */ call),\n/* harmony export */   getRunnableForEntrypoint: () => (/* binding */ getRunnableForEntrypoint),\n/* harmony export */   getRunnableForFunc: () => (/* binding */ getRunnableForFunc)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/singletons */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n\n\n\n\n\n/**\n * Wraps a user function in a Runnable that writes the returned value to the RETURN channel.\n */\nfunction getRunnableForFunc(name, func) {\n    const run = new _utils_js__WEBPACK_IMPORTED_MODULE_4__.RunnableCallable({\n        func: (input) => func(...input),\n        name,\n        trace: false,\n        recurse: false,\n    });\n    return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n        name,\n        first: run,\n        last: new _write_js__WEBPACK_IMPORTED_MODULE_3__.ChannelWrite([{ channel: _constants_js__WEBPACK_IMPORTED_MODULE_2__.RETURN, value: _write_js__WEBPACK_IMPORTED_MODULE_3__.PASSTHROUGH }], [_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN]),\n    });\n}\nfunction getRunnableForEntrypoint(name, func) {\n    const run = new _utils_js__WEBPACK_IMPORTED_MODULE_4__.RunnableCallable({\n        func: (input, config) => {\n            return func(input, config);\n        },\n        name,\n        trace: false,\n        recurse: false,\n    });\n    return run;\n}\nfunction call({ func, name, retry }, ...args) {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (typeof config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL] === \"function\") {\n        return config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL](func, name, args, {\n            retry,\n            callbacks: config.callbacks,\n        });\n    }\n    throw new Error(\"Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.\");\n}\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9jYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQThEO0FBQ2tCO0FBQ1Y7QUFDZjtBQUNSO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLHVEQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHVFQUFnQjtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFZLElBQUksU0FBUyxpREFBTSxTQUFTLGtEQUFXLEVBQUUsSUFBSSxxREFBVTtBQUNyRixLQUFLO0FBQ0w7QUFDTztBQUNQLG9CQUFvQix1REFBZ0I7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPLGdCQUFnQixtQkFBbUI7QUFDMUMsbUJBQW1CLDBGQUFrQztBQUNyRCxxQ0FBcUMsMERBQWU7QUFDcEQsbUNBQW1DLDBEQUFlO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvY2FsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZVNlcXVlbmNlLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9zaW5nbGV0b25zXCI7XG5pbXBvcnQgeyBDT05GSUdfS0VZX0NBTEwsIFJFVFVSTiwgVEFHX0hJRERFTiB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IENoYW5uZWxXcml0ZSwgUEFTU1RIUk9VR0ggfSBmcm9tIFwiLi93cml0ZS5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGVDYWxsYWJsZSB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuLyoqXG4gKiBXcmFwcyBhIHVzZXIgZnVuY3Rpb24gaW4gYSBSdW5uYWJsZSB0aGF0IHdyaXRlcyB0aGUgcmV0dXJuZWQgdmFsdWUgdG8gdGhlIFJFVFVSTiBjaGFubmVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVubmFibGVGb3JGdW5jKG5hbWUsIGZ1bmMpIHtcbiAgICBjb25zdCBydW4gPSBuZXcgUnVubmFibGVDYWxsYWJsZSh7XG4gICAgICAgIGZ1bmM6IChpbnB1dCkgPT4gZnVuYyguLi5pbnB1dCksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRyYWNlOiBmYWxzZSxcbiAgICAgICAgcmVjdXJzZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZmlyc3Q6IHJ1bixcbiAgICAgICAgbGFzdDogbmV3IENoYW5uZWxXcml0ZShbeyBjaGFubmVsOiBSRVRVUk4sIHZhbHVlOiBQQVNTVEhST1VHSCB9XSwgW1RBR19ISURERU5dKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW5uYWJsZUZvckVudHJ5cG9pbnQobmFtZSwgZnVuYykge1xuICAgIGNvbnN0IHJ1biA9IG5ldyBSdW5uYWJsZUNhbGxhYmxlKHtcbiAgICAgICAgZnVuYzogKGlucHV0LCBjb25maWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKGlucHV0LCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lLFxuICAgICAgICB0cmFjZTogZmFsc2UsXG4gICAgICAgIHJlY3Vyc2U6IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiBydW47XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsbCh7IGZ1bmMsIG5hbWUsIHJldHJ5IH0sIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25maWcgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldFJ1bm5hYmxlQ29uZmlnKCk7XG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DQUxMXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY29uZmlndXJhYmxlW0NPTkZJR19LRVlfQ0FMTF0oZnVuYywgbmFtZSwgYXJncywge1xuICAgICAgICAgICAgcmV0cnksXG4gICAgICAgICAgICBjYWxsYmFja3M6IGNvbmZpZy5jYWxsYmFja3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBsb2NhbCBzdG9yYWdlIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIGNhbGwgaW5pdGlhbGl6ZUFzeW5jTG9jYWxTdG9yYWdlU2luZ2xldG9uKCkgYmVmb3JlIHVzaW5nIHRoaXMgZnVuY3Rpb24uXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/debug.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/debug.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _readChannels: () => (/* binding */ _readChannels),\n/* harmony export */   mapDebugCheckpoint: () => (/* binding */ mapDebugCheckpoint),\n/* harmony export */   mapDebugTaskResults: () => (/* binding */ mapDebugTaskResults),\n/* harmony export */   mapDebugTasks: () => (/* binding */ mapDebugTasks),\n/* harmony export */   printCheckpoint: () => (/* binding */ printCheckpoint),\n/* harmony export */   printStepCheckpoint: () => (/* binding */ printStepCheckpoint),\n/* harmony export */   printStepTasks: () => (/* binding */ printStepTasks),\n/* harmony export */   printStepWrites: () => (/* binding */ printStepWrites),\n/* harmony export */   tasksWithWrites: () => (/* binding */ tasksWithWrites),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./io.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _utils_subgraph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/subgraph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n\n\n\n\nconst COLORS_MAP = {\n    blue: {\n        start: \"\\x1b[34m\",\n        end: \"\\x1b[0m\",\n    },\n    green: {\n        start: \"\\x1b[32m\",\n        end: \"\\x1b[0m\",\n    },\n    yellow: {\n        start: \"\\x1b[33;1m\",\n        end: \"\\x1b[0m\",\n    },\n};\n/**\n * Wrap some text in a color for printing to the console.\n */\nconst wrap = (color, text) => `${color.start}${text}${color.end}`;\nfunction printCheckpoint(step, channels) {\n    console.log([\n        `${wrap(COLORS_MAP.blue, \"[langgraph/checkpoint]\")}`,\n        `Finishing step ${step}. Channel values:\\n`,\n        `\\n${JSON.stringify(Object.fromEntries(_readChannels(channels)), null, 2)}`,\n    ].join(\"\"));\n}\nfunction* _readChannels(channels\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    for (const [name, channel] of Object.entries(channels)) {\n        try {\n            yield [name, channel.get()];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (error) {\n            if (error.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                // Skip the channel if it's empty\n                continue;\n            }\n            else {\n                throw error; // Re-throw the error if it's not an EmptyChannelError\n            }\n        }\n    }\n}\nfunction* mapDebugTasks(step, tasks) {\n    const ts = new Date().toISOString();\n    for (const { id, name, input, config, triggers, writes } of tasks) {\n        if (config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN))\n            continue;\n        const interrupts = writes\n            .filter(([writeId, n]) => {\n            return writeId === id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT;\n        })\n            .map(([, v]) => {\n            return v;\n        });\n        yield {\n            type: \"task\",\n            timestamp: ts,\n            step,\n            payload: {\n                id,\n                name,\n                input,\n                triggers,\n                interrupts,\n            },\n        };\n    }\n}\nfunction* mapDebugTaskResults(step, tasks, streamChannels) {\n    const ts = new Date().toISOString();\n    for (const [{ id, name, config }, writes] of tasks) {\n        if (config?.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN))\n            continue;\n        yield {\n            type: \"task_result\",\n            timestamp: ts,\n            step,\n            payload: {\n                id,\n                name,\n                result: writes.filter(([channel]) => {\n                    return Array.isArray(streamChannels)\n                        ? streamChannels.includes(channel)\n                        : channel === streamChannels;\n                }),\n                interrupts: writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT).map((w) => w[1]),\n            },\n        };\n    }\n}\nfunction* mapDebugCheckpoint(step, config, channels, streamChannels, metadata, tasks, pendingWrites, parentConfig) {\n    function formatConfig(config) {\n        // make sure the config is consistent with Python\n        const pyConfig = {};\n        if (config.callbacks != null)\n            pyConfig.callbacks = config.callbacks;\n        if (config.configurable != null)\n            pyConfig.configurable = config.configurable;\n        if (config.maxConcurrency != null)\n            pyConfig.max_concurrency = config.maxConcurrency;\n        if (config.metadata != null)\n            pyConfig.metadata = config.metadata;\n        if (config.recursionLimit != null)\n            pyConfig.recursion_limit = config.recursionLimit;\n        if (config.runId != null)\n            pyConfig.run_id = config.runId;\n        if (config.runName != null)\n            pyConfig.run_name = config.runName;\n        if (config.tags != null)\n            pyConfig.tags = config.tags;\n        return pyConfig;\n    }\n    const parentNs = config.configurable?.checkpoint_ns;\n    const taskStates = {};\n    for (const task of tasks) {\n        const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];\n        if (!candidates.find(_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_3__.findSubgraphPregel))\n            continue;\n        let taskNs = `${task.name}:${task.id}`;\n        if (parentNs)\n            taskNs = `${parentNs}|${taskNs}`;\n        taskStates[task.id] = {\n            configurable: {\n                thread_id: config.configurable?.thread_id,\n                checkpoint_ns: taskNs,\n            },\n        };\n    }\n    const ts = new Date().toISOString();\n    yield {\n        type: \"checkpoint\",\n        timestamp: ts,\n        step,\n        payload: {\n            config: formatConfig(config),\n            values: (0,_io_js__WEBPACK_IMPORTED_MODULE_2__.readChannels)(channels, streamChannels),\n            metadata,\n            next: tasks.map((task) => task.name),\n            tasks: tasksWithWrites(tasks, pendingWrites, taskStates),\n            parentConfig: parentConfig ? formatConfig(parentConfig) : undefined,\n        },\n    };\n}\nfunction tasksWithWrites(tasks, pendingWrites, states) {\n    return tasks.map((task) => {\n        const error = pendingWrites.find(([id, n]) => id === task.id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR)?.[2];\n        const interrupts = pendingWrites\n            .filter(([id, n]) => {\n            return id === task.id && n === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT;\n        })\n            .map(([, , v]) => {\n            return v;\n        });\n        if (error) {\n            return {\n                id: task.id,\n                name: task.name,\n                path: task.path,\n                error,\n                interrupts,\n            };\n        }\n        const taskState = states?.[task.id];\n        return {\n            id: task.id,\n            name: task.name,\n            path: task.path,\n            interrupts,\n            ...(taskState !== undefined ? { state: taskState } : {}),\n        };\n    });\n}\nfunction printStepCheckpoint(step, channels, whitelist) {\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,\n        `\\x1b[1m State at the end of step ${step}:\\x1b[0m\\n`,\n        JSON.stringify((0,_io_js__WEBPACK_IMPORTED_MODULE_2__.readChannels)(channels, whitelist), null, 2),\n    ].join(\"\"));\n}\nfunction printStepTasks(step, nextTasks) {\n    const nTasks = nextTasks.length;\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,\n        `\\x1b[1m Starting step ${step} with ${nTasks} task${nTasks === 1 ? \"\" : \"s\"}:\\x1b[0m\\n`,\n        nextTasks\n            .map((task) => `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(task.input, null, 2)}`)\n            .join(\"\\n\"),\n    ].join(\"\"));\n}\nfunction printStepWrites(step, writes, whitelist) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const byChannel = {};\n    for (const [channel, value] of writes) {\n        if (whitelist.includes(channel)) {\n            if (!byChannel[channel]) {\n                byChannel[channel] = [];\n            }\n            byChannel[channel].push(value);\n        }\n    }\n    console.log([\n        `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,\n        `\\x1b[1m Finished step ${step} with writes to ${Object.keys(byChannel).length} channel${Object.keys(byChannel).length !== 1 ? \"s\" : \"\"}:\\x1b[0m\\n`,\n        Object.entries(byChannel)\n            .map(([name, vals]) => `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals\n            .map((v) => JSON.stringify(v))\n            .join(\", \")}`)\n            .join(\"\\n\"),\n    ].join(\"\"));\n}\n//# sourceMappingURL=debug.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUErRDtBQUNkO0FBQ1Y7QUFDa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDLFlBQVksRUFBRSxLQUFLLEVBQUUsVUFBVTtBQUNoRTtBQUNQO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0QsMEJBQTBCLEtBQUs7QUFDL0IsYUFBYSxxRUFBcUU7QUFDbEY7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLDRDQUE0QztBQUM3RCxtQ0FBbUMscURBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9EQUFTO0FBQ3BELFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLG1DQUFtQyxxREFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMERBQTBELG9EQUFTO0FBQ25FLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFrQjtBQUMvQztBQUNBLHdCQUF3QixVQUFVLEdBQUcsUUFBUTtBQUM3QztBQUNBLHdCQUF3QixTQUFTLEdBQUcsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4RUFBOEUsZ0RBQUs7QUFDbkY7QUFDQTtBQUNBLDJDQUEyQyxvREFBUztBQUNwRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CLElBQUk7QUFDbkU7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0EsV0FBVywwQkFBMEIsS0FBSyxlQUFlO0FBQ3pELDRDQUE0QyxLQUFLO0FBQ2pELHVCQUF1QixvREFBWTtBQUNuQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsV0FBVywwQkFBMEIsS0FBSyxVQUFVO0FBQ3BELGlDQUFpQyxNQUFNLE9BQU8sUUFBUSxNQUFNLHdCQUF3QjtBQUNwRjtBQUNBLGdDQUFnQywyQ0FBMkMsS0FBSyxvQ0FBb0M7QUFDcEg7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEIsS0FBSyxXQUFXO0FBQ3JELGlDQUFpQyxNQUFNLGlCQUFpQiwrQkFBK0IsU0FBUywrQ0FBK0M7QUFDL0k7QUFDQSx3Q0FBd0MsK0JBQStCLEtBQUs7QUFDNUU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvZGVidWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRVJST1IsIElOVEVSUlVQVCwgVEFHX0hJRERFTiB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEVtcHR5Q2hhbm5lbEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgcmVhZENoYW5uZWxzIH0gZnJvbSBcIi4vaW8uanNcIjtcbmltcG9ydCB7IGZpbmRTdWJncmFwaFByZWdlbCB9IGZyb20gXCIuL3V0aWxzL3N1YmdyYXBoLmpzXCI7XG5jb25zdCBDT0xPUlNfTUFQID0ge1xuICAgIGJsdWU6IHtcbiAgICAgICAgc3RhcnQ6IFwiXFx4MWJbMzRtXCIsXG4gICAgICAgIGVuZDogXCJcXHgxYlswbVwiLFxuICAgIH0sXG4gICAgZ3JlZW46IHtcbiAgICAgICAgc3RhcnQ6IFwiXFx4MWJbMzJtXCIsXG4gICAgICAgIGVuZDogXCJcXHgxYlswbVwiLFxuICAgIH0sXG4gICAgeWVsbG93OiB7XG4gICAgICAgIHN0YXJ0OiBcIlxceDFiWzMzOzFtXCIsXG4gICAgICAgIGVuZDogXCJcXHgxYlswbVwiLFxuICAgIH0sXG59O1xuLyoqXG4gKiBXcmFwIHNvbWUgdGV4dCBpbiBhIGNvbG9yIGZvciBwcmludGluZyB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyYXAgPSAoY29sb3IsIHRleHQpID0+IGAke2NvbG9yLnN0YXJ0fSR7dGV4dH0ke2NvbG9yLmVuZH1gO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50Q2hlY2twb2ludChzdGVwLCBjaGFubmVscykge1xuICAgIGNvbnNvbGUubG9nKFtcbiAgICAgICAgYCR7d3JhcChDT0xPUlNfTUFQLmJsdWUsIFwiW2xhbmdncmFwaC9jaGVja3BvaW50XVwiKX1gLFxuICAgICAgICBgRmluaXNoaW5nIHN0ZXAgJHtzdGVwfS4gQ2hhbm5lbCB2YWx1ZXM6XFxuYCxcbiAgICAgICAgYFxcbiR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKF9yZWFkQ2hhbm5lbHMoY2hhbm5lbHMpKSwgbnVsbCwgMil9YCxcbiAgICBdLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uKiBfcmVhZENoYW5uZWxzKGNoYW5uZWxzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY2hhbm5lbF0gb2YgT2JqZWN0LmVudHJpZXMoY2hhbm5lbHMpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBbbmFtZSwgY2hhbm5lbC5nZXQoKV07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09IEVtcHR5Q2hhbm5lbEVycm9yLnVubWluaWZpYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgY2hhbm5lbCBpZiBpdCdzIGVtcHR5XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdGhlIGVycm9yIGlmIGl0J3Mgbm90IGFuIEVtcHR5Q2hhbm5lbEVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24qIG1hcERlYnVnVGFza3Moc3RlcCwgdGFza3MpIHtcbiAgICBjb25zdCB0cyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBmb3IgKGNvbnN0IHsgaWQsIG5hbWUsIGlucHV0LCBjb25maWcsIHRyaWdnZXJzLCB3cml0ZXMgfSBvZiB0YXNrcykge1xuICAgICAgICBpZiAoY29uZmlnPy50YWdzPy5pbmNsdWRlcyhUQUdfSElEREVOKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBpbnRlcnJ1cHRzID0gd3JpdGVzXG4gICAgICAgICAgICAuZmlsdGVyKChbd3JpdGVJZCwgbl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUlkID09PSBpZCAmJiBuID09PSBJTlRFUlJVUFQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKChbLCB2XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiBcInRhc2tcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uKiBtYXBEZWJ1Z1Rhc2tSZXN1bHRzKHN0ZXAsIHRhc2tzLCBzdHJlYW1DaGFubmVscykge1xuICAgIGNvbnN0IHRzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGZvciAoY29uc3QgW3sgaWQsIG5hbWUsIGNvbmZpZyB9LCB3cml0ZXNdIG9mIHRhc2tzKSB7XG4gICAgICAgIGlmIChjb25maWc/LnRhZ3M/LmluY2x1ZGVzKFRBR19ISURERU4pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGFza19yZXN1bHRcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB3cml0ZXMuZmlsdGVyKChbY2hhbm5lbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3RyZWFtQ2hhbm5lbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0cmVhbUNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoYW5uZWwgPT09IHN0cmVhbUNoYW5uZWxzO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGludGVycnVwdHM6IHdyaXRlcy5maWx0ZXIoKHcpID0+IHdbMF0gPT09IElOVEVSUlVQVCkubWFwKCh3KSA9PiB3WzFdKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uKiBtYXBEZWJ1Z0NoZWNrcG9pbnQoc3RlcCwgY29uZmlnLCBjaGFubmVscywgc3RyZWFtQ2hhbm5lbHMsIG1ldGFkYXRhLCB0YXNrcywgcGVuZGluZ1dyaXRlcywgcGFyZW50Q29uZmlnKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGNvbmZpZyBpcyBjb25zaXN0ZW50IHdpdGggUHl0aG9uXG4gICAgICAgIGNvbnN0IHB5Q29uZmlnID0ge307XG4gICAgICAgIGlmIChjb25maWcuY2FsbGJhY2tzICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5jYWxsYmFja3MgPSBjb25maWcuY2FsbGJhY2tzO1xuICAgICAgICBpZiAoY29uZmlnLmNvbmZpZ3VyYWJsZSAhPSBudWxsKVxuICAgICAgICAgICAgcHlDb25maWcuY29uZmlndXJhYmxlID0gY29uZmlnLmNvbmZpZ3VyYWJsZTtcbiAgICAgICAgaWYgKGNvbmZpZy5tYXhDb25jdXJyZW5jeSAhPSBudWxsKVxuICAgICAgICAgICAgcHlDb25maWcubWF4X2NvbmN1cnJlbmN5ID0gY29uZmlnLm1heENvbmN1cnJlbmN5O1xuICAgICAgICBpZiAoY29uZmlnLm1ldGFkYXRhICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5tZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZWN1cnNpb25MaW1pdCAhPSBudWxsKVxuICAgICAgICAgICAgcHlDb25maWcucmVjdXJzaW9uX2xpbWl0ID0gY29uZmlnLnJlY3Vyc2lvbkxpbWl0O1xuICAgICAgICBpZiAoY29uZmlnLnJ1bklkICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy5ydW5faWQgPSBjb25maWcucnVuSWQ7XG4gICAgICAgIGlmIChjb25maWcucnVuTmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgcHlDb25maWcucnVuX25hbWUgPSBjb25maWcucnVuTmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy50YWdzICE9IG51bGwpXG4gICAgICAgICAgICBweUNvbmZpZy50YWdzID0gY29uZmlnLnRhZ3M7XG4gICAgICAgIHJldHVybiBweUNvbmZpZztcbiAgICB9XG4gICAgY29uc3QgcGFyZW50TnMgPSBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zO1xuICAgIGNvbnN0IHRhc2tTdGF0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHRhc2suc3ViZ3JhcGhzPy5sZW5ndGggPyB0YXNrLnN1YmdyYXBocyA6IFt0YXNrLnByb2NdO1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZXMuZmluZChmaW5kU3ViZ3JhcGhQcmVnZWwpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCB0YXNrTnMgPSBgJHt0YXNrLm5hbWV9OiR7dGFzay5pZH1gO1xuICAgICAgICBpZiAocGFyZW50TnMpXG4gICAgICAgICAgICB0YXNrTnMgPSBgJHtwYXJlbnROc318JHt0YXNrTnN9YDtcbiAgICAgICAgdGFza1N0YXRlc1t0YXNrLmlkXSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZToge1xuICAgICAgICAgICAgICAgIHRocmVhZF9pZDogY29uZmlnLmNvbmZpZ3VyYWJsZT8udGhyZWFkX2lkLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IHRhc2tOcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJjaGVja3BvaW50XCIsXG4gICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGNvbmZpZzogZm9ybWF0Q29uZmlnKGNvbmZpZyksXG4gICAgICAgICAgICB2YWx1ZXM6IHJlYWRDaGFubmVscyhjaGFubmVscywgc3RyZWFtQ2hhbm5lbHMpLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBuZXh0OiB0YXNrcy5tYXAoKHRhc2spID0+IHRhc2submFtZSksXG4gICAgICAgICAgICB0YXNrczogdGFza3NXaXRoV3JpdGVzKHRhc2tzLCBwZW5kaW5nV3JpdGVzLCB0YXNrU3RhdGVzKSxcbiAgICAgICAgICAgIHBhcmVudENvbmZpZzogcGFyZW50Q29uZmlnID8gZm9ybWF0Q29uZmlnKHBhcmVudENvbmZpZykgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YXNrc1dpdGhXcml0ZXModGFza3MsIHBlbmRpbmdXcml0ZXMsIHN0YXRlcykge1xuICAgIHJldHVybiB0YXNrcy5tYXAoKHRhc2spID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBwZW5kaW5nV3JpdGVzLmZpbmQoKFtpZCwgbl0pID0+IGlkID09PSB0YXNrLmlkICYmIG4gPT09IEVSUk9SKT8uWzJdO1xuICAgICAgICBjb25zdCBpbnRlcnJ1cHRzID0gcGVuZGluZ1dyaXRlc1xuICAgICAgICAgICAgLmZpbHRlcigoW2lkLCBuXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlkID09PSB0YXNrLmlkICYmIG4gPT09IElOVEVSUlVQVDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKFssICwgdl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB0YXNrLmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRhc2submFtZSxcbiAgICAgICAgICAgICAgICBwYXRoOiB0YXNrLnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFza1N0YXRlID0gc3RhdGVzPy5bdGFzay5pZF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGFzay5pZCxcbiAgICAgICAgICAgIG5hbWU6IHRhc2submFtZSxcbiAgICAgICAgICAgIHBhdGg6IHRhc2sucGF0aCxcbiAgICAgICAgICAgIGludGVycnVwdHMsXG4gICAgICAgICAgICAuLi4odGFza1N0YXRlICE9PSB1bmRlZmluZWQgPyB7IHN0YXRlOiB0YXNrU3RhdGUgfSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmludFN0ZXBDaGVja3BvaW50KHN0ZXAsIGNoYW5uZWxzLCB3aGl0ZWxpc3QpIHtcbiAgICBjb25zb2xlLmxvZyhbXG4gICAgICAgIGAke3dyYXAoQ09MT1JTX01BUC5ibHVlLCBgWyR7c3RlcH06Y2hlY2twb2ludF1gKX1gLFxuICAgICAgICBgXFx4MWJbMW0gU3RhdGUgYXQgdGhlIGVuZCBvZiBzdGVwICR7c3RlcH06XFx4MWJbMG1cXG5gLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShyZWFkQ2hhbm5lbHMoY2hhbm5lbHMsIHdoaXRlbGlzdCksIG51bGwsIDIpLFxuICAgIF0uam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRTdGVwVGFza3Moc3RlcCwgbmV4dFRhc2tzKSB7XG4gICAgY29uc3QgblRhc2tzID0gbmV4dFRhc2tzLmxlbmd0aDtcbiAgICBjb25zb2xlLmxvZyhbXG4gICAgICAgIGAke3dyYXAoQ09MT1JTX01BUC5ibHVlLCBgWyR7c3RlcH06dGFza3NdYCl9YCxcbiAgICAgICAgYFxceDFiWzFtIFN0YXJ0aW5nIHN0ZXAgJHtzdGVwfSB3aXRoICR7blRhc2tzfSB0YXNrJHtuVGFza3MgPT09IDEgPyBcIlwiIDogXCJzXCJ9OlxceDFiWzBtXFxuYCxcbiAgICAgICAgbmV4dFRhc2tzXG4gICAgICAgICAgICAubWFwKCh0YXNrKSA9PiBgLSAke3dyYXAoQ09MT1JTX01BUC5ncmVlbiwgU3RyaW5nKHRhc2submFtZSkpfSAtPiAke0pTT04uc3RyaW5naWZ5KHRhc2suaW5wdXQsIG51bGwsIDIpfWApXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKSxcbiAgICBdLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RlcFdyaXRlcyhzdGVwLCB3cml0ZXMsIHdoaXRlbGlzdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgYnlDaGFubmVsID0ge307XG4gICAgZm9yIChjb25zdCBbY2hhbm5lbCwgdmFsdWVdIG9mIHdyaXRlcykge1xuICAgICAgICBpZiAod2hpdGVsaXN0LmluY2x1ZGVzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICBpZiAoIWJ5Q2hhbm5lbFtjaGFubmVsXSkge1xuICAgICAgICAgICAgICAgIGJ5Q2hhbm5lbFtjaGFubmVsXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnlDaGFubmVsW2NoYW5uZWxdLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFtcbiAgICAgICAgYCR7d3JhcChDT0xPUlNfTUFQLmJsdWUsIGBbJHtzdGVwfTp3cml0ZXNdYCl9YCxcbiAgICAgICAgYFxceDFiWzFtIEZpbmlzaGVkIHN0ZXAgJHtzdGVwfSB3aXRoIHdyaXRlcyB0byAke09iamVjdC5rZXlzKGJ5Q2hhbm5lbCkubGVuZ3RofSBjaGFubmVsJHtPYmplY3Qua2V5cyhieUNoYW5uZWwpLmxlbmd0aCAhPT0gMSA/IFwic1wiIDogXCJcIn06XFx4MWJbMG1cXG5gLFxuICAgICAgICBPYmplY3QuZW50cmllcyhieUNoYW5uZWwpXG4gICAgICAgICAgICAubWFwKChbbmFtZSwgdmFsc10pID0+IGAtICR7d3JhcChDT0xPUlNfTUFQLnllbGxvdywgbmFtZSl9IC0+ICR7dmFsc1xuICAgICAgICAgICAgLm1hcCgodikgPT4gSlNPTi5zdHJpbmdpZnkodikpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfWApXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKSxcbiAgICBdLmpvaW4oXCJcIikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/index.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/index.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Channel: () => (/* binding */ Channel),\n/* harmony export */   Pregel: () => (/* binding */ Pregel)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph-checkpoint@0.0.17_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4__/node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../channels/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./read.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/validate.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./io.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/debug.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _algo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./algo.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/algo.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/subgraph.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\");\n/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loop.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/loop.js\");\n/* harmony import */ var _managed_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../managed/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _utils_config_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/config.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./messages.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/messages.js\");\n/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./runner.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/runner.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/stream.js\");\n/* eslint-disable no-param-reassign */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nclass Channel {\n    static subscribeTo(channels, options) {\n        const { key, tags } = {\n            key: undefined,\n            tags: undefined,\n            ...(options ?? {}),\n        };\n        if (Array.isArray(channels) && key !== undefined) {\n            throw new Error(\"Can't specify a key when subscribing to multiple channels\");\n        }\n        let channelMappingOrArray;\n        if (isString(channels)) {\n            if (key) {\n                channelMappingOrArray = { [key]: channels };\n            }\n            else {\n                channelMappingOrArray = [channels];\n            }\n        }\n        else {\n            channelMappingOrArray = Object.fromEntries(channels.map((chan) => [chan, chan]));\n        }\n        const triggers = Array.isArray(channels) ? channels : [channels];\n        return new _read_js__WEBPACK_IMPORTED_MODULE_3__.PregelNode({\n            channels: channelMappingOrArray,\n            triggers,\n            tags,\n        });\n    }\n    /**\n     * Creates a ChannelWrite that specifies how to write values to channels.\n     * This is used to define how nodes send output to channels.\n     *\n     * @example\n     * ```typescript\n     * // Write to multiple channels\n     * const write = Channel.writeTo([\"output\", \"state\"]);\n     *\n     * // Write with specific values\n     * const write = Channel.writeTo([\"output\"], {\n     *   state: \"completed\",\n     *   result: calculateResult()\n     * });\n     *\n     * // Write with a transformation function\n     * const write = Channel.writeTo([\"output\"], {\n     *   result: (x) => processResult(x)\n     * });\n     * ```\n     *\n     * @param channels - Array of channel names to write to\n     * @param writes - Optional map of channel names to values or transformations\n     * @returns A ChannelWrite object that can be used to write to the specified channels\n     */\n    static writeTo(channels, writes) {\n        const channelWriteEntries = [];\n        for (const channel of channels) {\n            channelWriteEntries.push({\n                channel,\n                value: _write_js__WEBPACK_IMPORTED_MODULE_7__.PASSTHROUGH,\n                skipNone: false,\n            });\n        }\n        for (const [key, value] of Object.entries(writes ?? {})) {\n            if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(value) || typeof value === \"function\") {\n                channelWriteEntries.push({\n                    channel: key,\n                    value: _write_js__WEBPACK_IMPORTED_MODULE_7__.PASSTHROUGH,\n                    skipNone: true,\n                    mapper: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(value),\n                });\n            }\n            else {\n                channelWriteEntries.push({\n                    channel: key,\n                    value,\n                    skipNone: false,\n                });\n            }\n        }\n        return new _write_js__WEBPACK_IMPORTED_MODULE_7__.ChannelWrite(channelWriteEntries);\n    }\n}\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ConfigurableFieldType - Type of configurable fields that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nclass Pregel extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    /**\n     * Name of the class when serialized\n     * @internal\n     */\n    static lc_name() {\n        return \"LangGraph\";\n    }\n    /**\n     * Constructor for Pregel - meant for internal use only.\n     *\n     * @internal\n     */\n    constructor(fields) {\n        super(fields);\n        /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langgraph\", \"pregel\"]\n        });\n        /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n        Object.defineProperty(this, \"lg_is_pregel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The nodes in the graph, mapping node names to their PregelNode instances */\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"inputChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The output channels for the graph. These channels contain the final output when the graph completes.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"outputChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n        Object.defineProperty(this, \"autoValidate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * The streaming modes enabled for this graph. Defaults to [\"values\"].\n         * Supported modes:\n         * - \"values\": Streams the full state after each step\n         * - \"updates\": Streams state updates after each step\n         * - \"messages\": Streams messages from within nodes\n         * - \"custom\": Streams custom events from within nodes\n         * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n         */\n        Object.defineProperty(this, \"streamMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"values\"]\n        });\n        /**\n         * Optional channels to stream. If not specified, all channels will be streamed.\n         * Can be a single channel key or an array of channel keys.\n         */\n        Object.defineProperty(this, \"streamChannels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional array of node names or \"all\" to interrupt after executing these nodes.\n         * Used for implementing human-in-the-loop workflows.\n         */\n        Object.defineProperty(this, \"interruptAfter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional array of node names or \"all\" to interrupt before executing these nodes.\n         * Used for implementing human-in-the-loop workflows.\n         */\n        Object.defineProperty(this, \"interruptBefore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Optional timeout in milliseconds for the execution of each superstep */\n        Object.defineProperty(this, \"stepTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to enable debug logging. Defaults to false. */\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * Optional checkpointer for persisting graph state.\n         * When provided, saves a checkpoint of the graph state at every superstep.\n         * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n         */\n        Object.defineProperty(this, \"checkpointer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Optional retry policy for handling failures in node execution */\n        Object.defineProperty(this, \"retryPolicy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Optional long-term memory store for the graph, allows for persistance & retrieval of data across threads\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        let { streamMode } = fields;\n        if (streamMode != null && !Array.isArray(streamMode)) {\n            streamMode = [streamMode];\n        }\n        this.nodes = fields.nodes;\n        this.channels = fields.channels;\n        this.autoValidate = fields.autoValidate ?? this.autoValidate;\n        this.streamMode = streamMode ?? this.streamMode;\n        this.inputChannels = fields.inputChannels;\n        this.outputChannels = fields.outputChannels;\n        this.streamChannels = fields.streamChannels ?? this.streamChannels;\n        this.interruptAfter = fields.interruptAfter;\n        this.interruptBefore = fields.interruptBefore;\n        this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n        this.debug = fields.debug ?? this.debug;\n        this.checkpointer = fields.checkpointer;\n        this.retryPolicy = fields.retryPolicy;\n        this.config = fields.config;\n        this.store = fields.store;\n        this.name = fields.name;\n        if (this.autoValidate) {\n            this.validate();\n        }\n    }\n    /**\n     * Creates a new instance of the Pregel graph with updated configuration.\n     * This method follows the immutable pattern - instead of modifying the current instance,\n     * it returns a new instance with the merged configuration.\n     *\n     * @example\n     * ```typescript\n     * // Create a new instance with debug enabled\n     * const debugGraph = graph.withConfig({ debug: true });\n     *\n     * // Create a new instance with a specific thread ID\n     * const threadGraph = graph.withConfig({\n     *   configurable: { thread_id: \"123\" }\n     * });\n     * ```\n     *\n     * @param config - The configuration to merge with the current configuration\n     * @returns A new Pregel instance with the merged configuration\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Remove ignore when we remove support for 0.2 versions of core\n    withConfig(config) {\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({ ...this, config: mergedConfig });\n    }\n    /**\n     * Validates the graph structure to ensure it is well-formed.\n     * Checks for:\n     * - No orphaned nodes\n     * - Valid input/output channel configurations\n     * - Valid interrupt configurations\n     *\n     * @returns this - The Pregel instance for method chaining\n     * @throws {GraphValidationError} If the graph structure is invalid\n     */\n    validate() {\n        (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateGraph)({\n            nodes: this.nodes,\n            channels: this.channels,\n            outputChannels: this.outputChannels,\n            inputChannels: this.inputChannels,\n            streamChannels: this.streamChannels,\n            interruptAfterNodes: this.interruptAfter,\n            interruptBeforeNodes: this.interruptBefore,\n        });\n        return this;\n    }\n    /**\n     * Gets a list of all channels that should be streamed.\n     * If streamChannels is specified, returns those channels.\n     * Otherwise, returns all channels in the graph.\n     *\n     * @returns Array of channel keys to stream\n     */\n    get streamChannelsList() {\n        if (Array.isArray(this.streamChannels)) {\n            return this.streamChannels;\n        }\n        else if (this.streamChannels) {\n            return [this.streamChannels];\n        }\n        else {\n            return Object.keys(this.channels);\n        }\n    }\n    /**\n     * Gets the channels to stream in their original format.\n     * If streamChannels is specified, returns it as-is (either single key or array).\n     * Otherwise, returns all channels in the graph as an array.\n     *\n     * @returns Channel keys to stream, either as a single key or array\n     */\n    get streamChannelsAsIs() {\n        if (this.streamChannels) {\n            return this.streamChannels;\n        }\n        else {\n            return Object.keys(this.channels);\n        }\n    }\n    /**\n     * Gets a drawable representation of the graph structure.\n     * This is an async version of getGraph() and is the preferred method to use.\n     *\n     * @param config - Configuration for generating the graph visualization\n     * @returns A representation of the graph that can be visualized\n     */\n    async getGraphAsync(config) {\n        return this.getGraph(config);\n    }\n    /**\n     * Gets all subgraphs within this graph.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns Generator yielding tuples of [name, subgraph]\n     */\n    *getSubgraphs(namespace, recurse\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        for (const [name, node] of Object.entries(this.nodes)) {\n            // filter by prefix\n            if (namespace !== undefined) {\n                if (!namespace.startsWith(name)) {\n                    continue;\n                }\n            }\n            const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n            for (const candidate of candidates) {\n                const graph = (0,_utils_subgraph_js__WEBPACK_IMPORTED_MODULE_12__.findSubgraphPregel)(candidate);\n                if (graph !== undefined) {\n                    if (name === namespace) {\n                        yield [name, graph];\n                        return;\n                    }\n                    if (namespace === undefined) {\n                        yield [name, graph];\n                    }\n                    if (recurse) {\n                        let newNamespace = namespace;\n                        if (namespace !== undefined) {\n                            newNamespace = namespace.slice(name.length + 1);\n                        }\n                        for (const [subgraphName, subgraph] of graph.getSubgraphs(newNamespace, recurse)) {\n                            yield [\n                                `${name}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                                subgraph,\n                            ];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Gets all subgraphs within this graph asynchronously.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns AsyncGenerator yielding tuples of [name, subgraph]\n     */\n    async *getSubgraphsAsync(namespace, recurse\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        yield* this.getSubgraphs(namespace, recurse);\n    }\n    /**\n     * Prepares a state snapshot from saved checkpoint data.\n     * This is an internal method used by getState and getStateHistory.\n     *\n     * @param config - Configuration for preparing the snapshot\n     * @param saved - Optional saved checkpoint data\n     * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n     * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n     * @returns A snapshot of the graph state\n     * @internal\n     */\n    async _prepareStateSnapshot({ config, saved, subgraphCheckpointer, applyPendingWrites = false, }) {\n        if (saved === undefined) {\n            return {\n                values: {},\n                next: [],\n                config,\n                tasks: [],\n            };\n        }\n        // Create all channels\n        const { managed } = await this.prepareSpecs(config, {\n            skipManaged: true,\n        });\n        const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(this.channels, saved.checkpoint);\n        // Apply null writes first (from NULL_TASK_ID)\n        if (saved.pendingWrites?.length) {\n            const nullWrites = saved.pendingWrites\n                .filter(([taskId, _]) => taskId === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                .map(([_, channel, value]) => [String(channel), value]);\n            if (nullWrites.length > 0) {\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                        writes: nullWrites,\n                        triggers: [],\n                    },\n                ]);\n            }\n        }\n        // Prepare next tasks\n        const nextTasks = Object.values((0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(saved.checkpoint, saved.pendingWrites, this.nodes, channels, managed, saved.config, true, { step: (saved.metadata?.step ?? -1) + 1, store: this.store }));\n        // Find subgraphs\n        const subgraphs = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.gatherIterator)(this.getSubgraphsAsync());\n        const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n        const taskStates = {};\n        // Prepare task states for subgraphs\n        for (const task of nextTasks) {\n            const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n            if (!matchingSubgraph) {\n                continue;\n            }\n            // assemble checkpoint_ns for this task\n            let taskNs = `${String(task.name)}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_END}${task.id}`;\n            if (parentNamespace) {\n                taskNs = `${parentNamespace}${_constants_js__WEBPACK_IMPORTED_MODULE_8__.CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n            }\n            if (subgraphCheckpointer === undefined) {\n                // set config as signal that subgraph checkpoints exist\n                const config = {\n                    configurable: {\n                        thread_id: saved.config.configurable?.thread_id,\n                        checkpoint_ns: taskNs,\n                    },\n                };\n                taskStates[task.id] = config;\n            }\n            else {\n                // get the state of the subgraph\n                const subgraphConfig = {\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n                        thread_id: saved.config.configurable?.thread_id,\n                        checkpoint_ns: taskNs,\n                    },\n                };\n                const pregel = matchingSubgraph[1];\n                taskStates[task.id] = await pregel.getState(subgraphConfig, {\n                    subgraphs: true,\n                });\n            }\n        }\n        // Apply pending writes to tasks and then to channels if applyPendingWrites is true\n        if (applyPendingWrites && saved.pendingWrites?.length) {\n            // Map task IDs to task objects for easy lookup\n            const nextTaskById = Object.fromEntries(nextTasks.map((task) => [task.id, task]));\n            // Apply pending writes to the appropriate tasks\n            for (const [taskId, channel, value] of saved.pendingWrites) {\n                // Skip special channels and tasks not in nextTasks\n                if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(channel)) {\n                    continue;\n                }\n                if (!(taskId in nextTaskById)) {\n                    continue;\n                }\n                // Add the write to the task\n                nextTaskById[taskId].writes.push([String(channel), value]);\n            }\n            // Apply writes from tasks that have writes\n            const tasksWithWrites = nextTasks.filter((task) => task.writes.length > 0);\n            if (tasksWithWrites.length > 0) {\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, tasksWithWrites);\n            }\n        }\n        // Preserve thread_id from the config in metadata\n        let metadata = saved?.metadata;\n        if (metadata && saved?.config?.configurable?.thread_id) {\n            metadata = {\n                ...metadata,\n                thread_id: saved.config.configurable.thread_id,\n            };\n        }\n        // Filter next tasks - only include tasks without writes\n        const nextList = nextTasks\n            .filter((task) => task.writes.length === 0)\n            .map((task) => task.name);\n        // assemble the state snapshot\n        return {\n            values: (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.readChannels)(channels, this.streamChannelsAsIs),\n            next: nextList,\n            tasks: (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.tasksWithWrites)(nextTasks, saved?.pendingWrites ?? [], taskStates),\n            metadata,\n            config: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(saved.config, saved.metadata),\n            createdAt: saved.checkpoint.ts,\n            parentConfig: saved.parentConfig,\n        };\n    }\n    /**\n     * Gets the current state of the graph.\n     * Requires a checkpointer to be configured.\n     *\n     * @param config - Configuration for retrieving the state\n     * @param options - Additional options\n     * @returns A snapshot of the current graph state\n     * @throws {GraphValueError} If no checkpointer is configured\n     */\n    async getState(config, options) {\n        const checkpointer = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphValueError(\"No checkpointer set\");\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            // remove task_ids from checkpoint_ns\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            for await (const [name, subgraph] of this.getSubgraphsAsync(recastNamespace, true)) {\n                if (name === recastNamespace) {\n                    return await subgraph.getState((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                    }), { subgraphs: options?.subgraphs });\n                }\n            }\n            throw new Error(`Subgraph with namespace \"${recastNamespace}\" not found.`);\n        }\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        const saved = await checkpointer.getTuple(config);\n        const snapshot = await this._prepareStateSnapshot({\n            config: mergedConfig,\n            saved,\n            subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n            applyPendingWrites: !config.configurable?.checkpoint_id,\n        });\n        return snapshot;\n    }\n    /**\n     * Gets the history of graph states.\n     * Requires a checkpointer to be configured.\n     * Useful for:\n     * - Debugging execution history\n     * - Implementing time travel\n     * - Analyzing graph behavior\n     *\n     * @param config - Configuration for retrieving the history\n     * @param options - Options for filtering the history\n     * @returns An async iterator of state snapshots\n     * @throws {Error} If no checkpointer is configured\n     */\n    async *getStateHistory(config, options) {\n        const checkpointer = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new Error(\"No checkpointer set\");\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            // find the subgraph with the matching name\n            for await (const [name, pregel] of this.getSubgraphsAsync(recastNamespace, true)) {\n                if (name === recastNamespace) {\n                    yield* pregel.getStateHistory((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                    }), options);\n                    return;\n                }\n            }\n            throw new Error(`Subgraph with namespace \"${recastNamespace}\" not found.`);\n        }\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config, {\n            configurable: { checkpoint_ns: checkpointNamespace },\n        });\n        for await (const checkpointTuple of checkpointer.list(mergedConfig, options)) {\n            yield this._prepareStateSnapshot({\n                config: checkpointTuple.config,\n                saved: checkpointTuple,\n            });\n        }\n    }\n    /**\n     * Apply updates to the graph state in bulk.\n     * Requires a checkpointer to be configured.\n     *\n     * This method is useful for recreating a thread\n     * from a list of updates, especially if a checkpoint\n     * is created as a result of multiple tasks.\n     *\n     * @internal The API might change in the future.\n     *\n     * @param startConfig - Configuration for the update\n     * @param updates - The list of updates to apply to graph state\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n     */\n    async bulkUpdateState(startConfig, supersteps) {\n        const checkpointer = startConfig.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n        if (!checkpointer) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphValueError(\"No checkpointer set\");\n        }\n        if (supersteps.length === 0) {\n            throw new Error(\"No supersteps provided\");\n        }\n        if (supersteps.some((s) => s.updates.length === 0)) {\n            throw new Error(\"No updates provided\");\n        }\n        // delegate to subgraph\n        const checkpointNamespace = startConfig.configurable?.checkpoint_ns ?? \"\";\n        if (checkpointNamespace !== \"\" &&\n            startConfig.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] === undefined) {\n            // remove task_ids from checkpoint_ns\n            const recastNamespace = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.recastCheckpointNamespace)(checkpointNamespace);\n            // find the subgraph with the matching name\n            // eslint-disable-next-line no-unreachable-loop\n            for await (const [, pregel] of this.getSubgraphsAsync(recastNamespace, true)) {\n                return await pregel.bulkUpdateState((0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(startConfig, {\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER]: checkpointer,\n                }), supersteps);\n            }\n            throw new Error(`Subgraph \"${recastNamespace}\" not found`);\n        }\n        const updateSuperStep = async (inputConfig, updates) => {\n            // get last checkpoint\n            const config = this.config\n                ? (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, inputConfig)\n                : inputConfig;\n            const saved = await checkpointer.getTuple(config);\n            const checkpoint = saved !== undefined\n                ? (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.copyCheckpoint)(saved.checkpoint)\n                : (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.emptyCheckpoint)();\n            const checkpointPreviousVersions = {\n                ...saved?.checkpoint.channel_versions,\n            };\n            const step = saved?.metadata?.step ?? -1;\n            // merge configurable fields with previous checkpoint config\n            let checkpointConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, {\n                checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n            });\n            let checkpointMetadata = config.metadata ?? {};\n            if (saved?.config.configurable) {\n                checkpointConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.patchConfigurable)(config, saved.config.configurable);\n                checkpointMetadata = {\n                    ...saved.metadata,\n                    ...checkpointMetadata,\n                };\n            }\n            // Find last node that updated the state, if not provided\n            const { values, asNode } = updates[0];\n            if (values == null && asNode === undefined) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot create empty checkpoint with multiple updates`);\n                }\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    source: \"update\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            // update channels\n            const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.emptyChannels)(this.channels, checkpoint);\n            // Pass `skipManaged: true` as managed values are not used/relevant in update state calls.\n            const { managed } = await this.prepareSpecs(config, {\n                skipManaged: true,\n            });\n            if (values === null && asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.END) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot apply multiple updates when clearing state`);\n                }\n                if (saved) {\n                    // tasks for this checkpoint\n                    const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(checkpoint, saved.pendingWrites || [], this.nodes, channels, managed, saved.config, true, {\n                        step: (saved.metadata?.step ?? -1) + 1,\n                        checkpointer: this.checkpointer || undefined,\n                        store: this.store,\n                    });\n                    // apply null writes\n                    const nullWrites = (saved.pendingWrites || [])\n                        .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                        .map((w) => w.slice(1));\n                    if (nullWrites.length > 0) {\n                        (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                            {\n                                name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                                writes: nullWrites,\n                                triggers: [],\n                            },\n                        ]);\n                    }\n                    // apply writes from tasks that already ran\n                    for (const [taskId, k, v] of saved.pendingWrites || []) {\n                        if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(k)) {\n                            continue;\n                        }\n                        if (!(taskId in nextTasks)) {\n                            continue;\n                        }\n                        nextTasks[taskId].writes.push([k, v]);\n                    }\n                    // clear all current tasks\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, Object.values(nextTasks));\n                }\n                // save checkpoint\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    ...checkpointMetadata,\n                    source: \"update\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            if (values == null && asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.COPY) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot copy checkpoint with multiple updates`);\n                }\n                const nextConfig = await checkpointer.put(saved?.parentConfig ?? checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, undefined, step), {\n                    source: \"fork\",\n                    step: step + 1,\n                    writes: {},\n                    parents: saved?.metadata?.parents ?? {},\n                }, {});\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            if (asNode === _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT) {\n                if (updates.length > 1) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Cannot apply multiple updates when updating as input`);\n                }\n                const inputWrites = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_15__.gatherIterator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapInput)(this.inputChannels, values));\n                if (inputWrites.length === 0) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);\n                }\n                // apply to checkpoint\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, [\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                        writes: inputWrites,\n                        triggers: [],\n                    },\n                ], checkpointer.getNextVersion.bind(this.checkpointer));\n                // apply input write to channels\n                const nextStep = saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;\n                const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, channels, nextStep), {\n                    source: \"input\",\n                    step: nextStep,\n                    writes: Object.fromEntries(inputWrites),\n                    parents: saved?.metadata?.parents ?? {},\n                }, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.getNewChannelVersions)(checkpointPreviousVersions, checkpoint.channel_versions));\n                // Store the writes\n                await checkpointer.putWrites(nextConfig, inputWrites, (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT, checkpoint.id));\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n            }\n            // apply pending writes, if not on specific checkpoint\n            if (config.configurable?.checkpoint_id === undefined &&\n                saved?.pendingWrites !== undefined &&\n                saved.pendingWrites.length > 0) {\n                // tasks for this checkpoint\n                const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._prepareNextTasks)(checkpoint, saved.pendingWrites, this.nodes, channels, managed, saved.config, true, {\n                    store: this.store,\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    checkpointer: this.checkpointer,\n                    step: (saved.metadata?.step ?? -1) + 1,\n                });\n                // apply null writes\n                const nullWrites = (saved.pendingWrites ?? [])\n                    .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.NULL_TASK_ID)\n                    .map((w) => w.slice(1));\n                if (nullWrites.length > 0) {\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(saved.checkpoint, channels, [\n                        {\n                            name: _constants_js__WEBPACK_IMPORTED_MODULE_8__.INPUT,\n                            writes: nullWrites,\n                            triggers: [],\n                        },\n                    ]);\n                }\n                // apply writes\n                for (const [tid, k, v] of saved.pendingWrites) {\n                    if ([_constants_js__WEBPACK_IMPORTED_MODULE_8__.ERROR, _constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED].includes(k) ||\n                        nextTasks[tid] === undefined) {\n                        continue;\n                    }\n                    nextTasks[tid].writes.push([k, v]);\n                }\n                const tasks = Object.values(nextTasks).filter((task) => {\n                    return task.writes.length > 0;\n                });\n                if (tasks.length > 0) {\n                    (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, tasks);\n                }\n            }\n            const nonNullVersion = Object.values(checkpoint.versions_seen)\n                .map((seenVersions) => {\n                return Object.values(seenVersions);\n            })\n                .flat()\n                .find((v) => !!v);\n            const validUpdates = [];\n            if (updates.length === 1) {\n                // eslint-disable-next-line prefer-const\n                let { values, asNode } = updates[0];\n                if (asNode === undefined && Object.keys(this.nodes).length === 1) {\n                    // if only one node, use it\n                    [asNode] = Object.keys(this.nodes);\n                }\n                else if (asNode === undefined && nonNullVersion === undefined) {\n                    if (typeof this.inputChannels === \"string\" &&\n                        this.nodes[this.inputChannels] !== undefined) {\n                        asNode = this.inputChannels;\n                    }\n                }\n                else if (asNode === undefined) {\n                    const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n                        .map(([n, seen]) => {\n                        return Object.values(seen).map((v) => {\n                            return [v, n];\n                        });\n                    })\n                        .flat()\n                        .sort(([aNumber], [bNumber]) => (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.compareChannelVersions)(aNumber, bNumber));\n                    // if two nodes updated the state at the same time, it's ambiguous\n                    if (lastSeenByNode) {\n                        if (lastSeenByNode.length === 1) {\n                            // eslint-disable-next-line prefer-destructuring\n                            asNode = lastSeenByNode[0][1];\n                        }\n                        else if (lastSeenByNode[lastSeenByNode.length - 1][0] !==\n                            lastSeenByNode[lastSeenByNode.length - 2][0]) {\n                            // eslint-disable-next-line prefer-destructuring\n                            asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n                        }\n                    }\n                }\n                if (asNode === undefined) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n                }\n                validUpdates.push({ values, asNode });\n            }\n            else {\n                for (const { asNode, values } of updates) {\n                    if (asNode == null) {\n                        throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`\"asNode\" is required when applying multiple updates`);\n                    }\n                    validUpdates.push({ values, asNode });\n                }\n            }\n            const tasks = [];\n            for (const { asNode, values } of validUpdates) {\n                if (this.nodes[asNode] === undefined) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`Node \"${asNode.toString()}\" does not exist`);\n                }\n                // run all writers of the chosen node\n                const writers = this.nodes[asNode].getWriters();\n                if (!writers.length) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.InvalidUpdateError(`No writers found for node \"${asNode.toString()}\"`);\n                }\n                tasks.push({\n                    name: asNode,\n                    input: values,\n                    proc: writers.length > 1\n                        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence.from(writers, {\n                                omitSequenceTags: true,\n                            })\n                        : writers[0],\n                    writes: [],\n                    triggers: [_constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT],\n                    id: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_1__.uuid5)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.INTERRUPT, checkpoint.id),\n                    writers: [],\n                });\n            }\n            for (const task of tasks) {\n                // execute task\n                await task.proc.invoke(task.input, (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)({\n                    ...config,\n                    store: config?.store ?? this.store,\n                }, {\n                    runName: config.runName ?? `${this.getName()}UpdateState`,\n                    configurable: {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_SEND]: (items) => task.writes.push(...items),\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_READ]: (select_, fresh_ = false) => (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._localRead)(step, checkpoint, channels, managed, \n                        // TODO: Why does keyof StrRecord allow number and symbol?\n                        task, select_, fresh_),\n                    },\n                }));\n            }\n            for (const task of tasks) {\n                // channel writes are saved to current checkpoint\n                const channelWrites = task.writes.filter((w) => w[0] !== _constants_js__WEBPACK_IMPORTED_MODULE_8__.PUSH);\n                // save task writes\n                if (saved !== undefined && channelWrites.length > 0) {\n                    await checkpointer.putWrites(checkpointConfig, channelWrites, task.id);\n                }\n            }\n            // apply to checkpoint\n            // TODO: Why does keyof StrRecord allow number and symbol?\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_10__._applyWrites)(checkpoint, channels, tasks, checkpointer.getNextVersion.bind(this.checkpointer));\n            const newVersions = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.getNewChannelVersions)(checkpointPreviousVersions, checkpoint.channel_versions);\n            const nextConfig = await checkpointer.put(checkpointConfig, (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.createCheckpoint)(checkpoint, channels, step + 1), {\n                source: \"update\",\n                step: step + 1,\n                writes: Object.fromEntries(validUpdates.map((update) => [update.asNode, update.values])),\n                parents: saved?.metadata?.parents ?? {},\n            }, newVersions);\n            for (const task of tasks) {\n                // push writes are saved to next checkpoint\n                const pushWrites = task.writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_8__.PUSH);\n                if (pushWrites.length > 0) {\n                    await checkpointer.putWrites(nextConfig, pushWrites, task.id);\n                }\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.patchCheckpointMap)(nextConfig, saved ? saved.metadata : undefined);\n        };\n        let currentConfig = startConfig;\n        for (const { updates } of supersteps) {\n            currentConfig = await updateSuperStep(currentConfig, updates);\n        }\n        return currentConfig;\n    }\n    /**\n     * Updates the state of the graph with new values.\n     * Requires a checkpointer to be configured.\n     *\n     * This method can be used for:\n     * - Implementing human-in-the-loop workflows\n     * - Modifying graph state during breakpoints\n     * - Integrating external inputs into the graph\n     *\n     * @param inputConfig - Configuration for the update\n     * @param values - The values to update the state with\n     * @param asNode - Optional node name to attribute the update to\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n     */\n    async updateState(inputConfig, values, asNode) {\n        return this.bulkUpdateState(inputConfig, [\n            { updates: [{ values, asNode }] },\n        ]);\n    }\n    /**\n     * Gets the default values for various graph configuration options.\n     * This is an internal method used to process and normalize configuration options.\n     *\n     * @param config - The input configuration options\n     * @returns A tuple containing normalized values for:\n     * - debug mode\n     * - stream modes\n     * - input keys\n     * - output keys\n     * - remaining config\n     * - interrupt before nodes\n     * - interrupt after nodes\n     * - checkpointer\n     * - store\n     * - whether stream mode is single\n     * @internal\n     */\n    _defaults(config) {\n        const { debug, streamMode, inputKeys, outputKeys, interruptAfter, interruptBefore, ...rest } = config;\n        let streamModeSingle = true;\n        const defaultDebug = debug !== undefined ? debug : this.debug;\n        let defaultOutputKeys = outputKeys;\n        if (defaultOutputKeys === undefined) {\n            defaultOutputKeys = this.streamChannelsAsIs;\n        }\n        else {\n            (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateKeys)(defaultOutputKeys, this.channels);\n        }\n        let defaultInputKeys = inputKeys;\n        if (defaultInputKeys === undefined) {\n            defaultInputKeys = this.inputChannels;\n        }\n        else {\n            (0,_validate_js__WEBPACK_IMPORTED_MODULE_4__.validateKeys)(defaultInputKeys, this.channels);\n        }\n        const defaultInterruptBefore = interruptBefore ?? this.interruptBefore ?? [];\n        const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n        let defaultStreamMode;\n        if (streamMode !== undefined) {\n            defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n            streamModeSingle = typeof streamMode === \"string\";\n        }\n        else {\n            defaultStreamMode = this.streamMode;\n            streamModeSingle = true;\n        }\n        // if being called as a node in another graph, always use values mode\n        if (config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_TASK_ID] !== undefined) {\n            defaultStreamMode = [\"values\"];\n        }\n        let defaultCheckpointer;\n        if (this.checkpointer === false) {\n            defaultCheckpointer = undefined;\n        }\n        else if (config !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER] !== undefined) {\n            defaultCheckpointer = config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_CHECKPOINTER];\n        }\n        else {\n            defaultCheckpointer = this.checkpointer;\n        }\n        const defaultStore = config.store ?? this.store;\n        return [\n            defaultDebug,\n            defaultStreamMode,\n            defaultInputKeys,\n            defaultOutputKeys,\n            rest,\n            defaultInterruptBefore,\n            defaultInterruptAfter,\n            defaultCheckpointer,\n            defaultStore,\n            streamModeSingle,\n        ];\n    }\n    /**\n     * Streams the execution of the graph, emitting state updates as they occur.\n     * This is the primary method for observing graph execution in real-time.\n     *\n     * Stream modes:\n     * - \"values\": Emits complete state after each step\n     * - \"updates\": Emits only state changes after each step\n     * - \"debug\": Emits detailed debug information\n     * - \"messages\": Emits messages from within nodes\n     *\n     * For more details, see the [Streaming how-to guides](../../how-tos/#streaming_1).\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns An async iterable stream of graph state updates\n     */\n    async stream(input, options) {\n        // The ensureConfig method called internally defaults recursionLimit to 25 if not\n        // passed directly in `options`.\n        // There is currently no way in _streamIterator to determine whether this was\n        // set by by ensureConfig or manually by the user, so we specify the bound value here\n        // and override if it is passed as an explicit param in `options`.\n        const abortController = new AbortController();\n        const config = {\n            recursionLimit: this.config?.recursionLimit,\n            ...options,\n            signal: options?.signal\n                ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.combineAbortSignals)(options.signal, abortController.signal)\n                : abortController.signal,\n        };\n        return new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableStreamWithAbortSignal(await super.stream(input, config), abortController);\n    }\n    streamEvents(input, options, streamOptions) {\n        const abortController = new AbortController();\n        const config = {\n            recursionLimit: this.config?.recursionLimit,\n            // Similar to `stream`, we need to pass the `config.callbacks` here,\n            // otherwise the user-provided callback will get lost in `ensureLangGraphConfig`.\n            callbacks: this.config?.callbacks,\n            ...options,\n            signal: options?.signal\n                ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.combineAbortSignals)(options.signal, abortController.signal)\n                : abortController.signal,\n        };\n        return new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableStreamWithAbortSignal(super.streamEvents(input, config, streamOptions), abortController);\n    }\n    /**\n     * Prepares channel specifications and managed values for graph execution.\n     * This is an internal method used to set up the graph's communication channels\n     * and managed state before execution.\n     *\n     * @param config - Configuration for preparing specs\n     * @param options - Additional options\n     * @param options.skipManaged - Whether to skip initialization of managed values\n     * @returns Object containing channel specs and managed value mapping\n     * @internal\n     */\n    async prepareSpecs(config, options) {\n        const configForManaged = {\n            ...config,\n            store: this.store,\n        };\n        const channelSpecs = {};\n        const managedSpecs = {};\n        for (const [name, spec] of Object.entries(this.channels)) {\n            if ((0,_channels_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseChannel)(spec)) {\n                channelSpecs[name] = spec;\n            }\n            else if (options?.skipManaged) {\n                managedSpecs[name] = {\n                    cls: _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.NoopManagedValue,\n                    params: { config: {} },\n                };\n            }\n            else {\n                managedSpecs[name] = spec;\n            }\n        }\n        const managed = new _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.ManagedValueMapping(await Object.entries(managedSpecs).reduce(async (accPromise, [key, value]) => {\n            const acc = await accPromise;\n            let initializedValue;\n            if ((0,_managed_base_js__WEBPACK_IMPORTED_MODULE_14__.isConfiguredManagedValue)(value)) {\n                if (\"key\" in value.params &&\n                    value.params.key === _managed_base_js__WEBPACK_IMPORTED_MODULE_14__.ChannelKeyPlaceholder) {\n                    value.params.key = key;\n                }\n                initializedValue = await value.cls.initialize(configForManaged, value.params);\n            }\n            else {\n                initializedValue = await value.initialize(configForManaged);\n            }\n            if (initializedValue !== undefined) {\n                acc.push([key, initializedValue]);\n            }\n            return acc;\n        }, Promise.resolve([])));\n        return {\n            channelSpecs,\n            managed,\n        };\n    }\n    /**\n     * Validates the input for the graph.\n     * @param input - The input to validate\n     * @returns The validated input\n     * @internal\n     */\n    async _validateInput(input) {\n        return input;\n    }\n    /**\n     * Validates the configurable options for the graph.\n     * @param config - The configurable options to validate\n     * @returns The validated configurable options\n     * @internal\n     */\n    async _validateConfigurable(config) {\n        return config;\n    }\n    /**\n     * Internal iterator used by stream() to generate state updates.\n     * This method handles the core logic of graph execution and streaming.\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns AsyncGenerator yielding state updates\n     * @internal\n     */\n    async *_streamIterator(input, options) {\n        const streamSubgraphs = options?.subgraphs;\n        const inputConfig = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_16__.ensureLangGraphConfig)(this.config, options);\n        if (inputConfig.recursionLimit === undefined ||\n            inputConfig.recursionLimit < 1) {\n            throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n        }\n        if (this.checkpointer !== undefined &&\n            this.checkpointer !== false &&\n            inputConfig.configurable === undefined) {\n            throw new Error(`Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`);\n        }\n        const validInput = await this._validateInput(input);\n        const { runId, ...restConfig } = inputConfig;\n        // assign defaults\n        const [debug, streamMode, , outputKeys, config, interruptBefore, interruptAfter, checkpointer, store, streamModeSingle,] = this._defaults(restConfig);\n        config.configurable = await this._validateConfigurable(config.configurable);\n        const stream = new _stream_js__WEBPACK_IMPORTED_MODULE_19__.IterableReadableWritableStream({\n            modes: new Set(streamMode),\n        });\n        // set up messages stream mode\n        if (streamMode.includes(\"messages\")) {\n            const messageStreamer = new _messages_js__WEBPACK_IMPORTED_MODULE_17__.StreamMessagesHandler((chunk) => stream.push(chunk));\n            const { callbacks } = config;\n            if (callbacks === undefined) {\n                config.callbacks = [messageStreamer];\n            }\n            else if (Array.isArray(callbacks)) {\n                config.callbacks = callbacks.concat(messageStreamer);\n            }\n            else {\n                const copiedCallbacks = callbacks.copy();\n                copiedCallbacks.addHandler(messageStreamer, true);\n                config.callbacks = copiedCallbacks;\n            }\n        }\n        // setup custom stream mode\n        if (streamMode.includes(\"custom\")) {\n            config.writer = (chunk) => stream.push([[], \"custom\", chunk]);\n        }\n        const callbackManager = await (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager?.handleChainStart(this.toJSON(), // chain\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__._coerceToDict)(input, \"input\"), // inputs\n        runId, // run_id\n        undefined, // run_type\n        undefined, // tags\n        undefined, // metadata\n        config?.runName ?? this.getName() // run_name\n        );\n        const { channelSpecs, managed } = await this.prepareSpecs(config);\n        let loop;\n        let loopError;\n        /**\n         * The PregelLoop will yield events from concurrent tasks as soon as they are\n         * generated. Each task can push multiple events onto the stream in any order.\n         *\n         * We use a separate background method and stream here in order to yield events\n         * from the loop to the main stream and therefore back to the user as soon as\n         * they are available.\n         */\n        const createAndRunLoop = async () => {\n            try {\n                loop = await _loop_js__WEBPACK_IMPORTED_MODULE_13__.PregelLoop.initialize({\n                    input: validInput,\n                    config,\n                    checkpointer,\n                    nodes: this.nodes,\n                    channelSpecs,\n                    managed,\n                    outputKeys,\n                    streamKeys: this.streamChannelsAsIs,\n                    store,\n                    stream,\n                    interruptAfter,\n                    interruptBefore,\n                    manager: runManager,\n                    debug: this.debug,\n                });\n                const runner = new _runner_js__WEBPACK_IMPORTED_MODULE_18__.PregelRunner({\n                    loop,\n                    nodeFinished: config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_NODE_FINISHED],\n                });\n                if (options?.subgraphs) {\n                    loop.config.configurable = {\n                        ...loop.config.configurable,\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG_KEY_STREAM]: loop.stream,\n                    };\n                }\n                await this._runLoop({ loop, runner, debug, config });\n            }\n            catch (e) {\n                loopError = e;\n            }\n            finally {\n                try {\n                    // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n                    if (loop) {\n                        await loop.store?.stop();\n                    }\n                    await Promise.all([\n                        ...(loop?.checkpointerPromises ?? []),\n                        ...Array.from(managed.values()).map((mv) => mv.promises()),\n                    ]);\n                }\n                catch (e) {\n                    loopError = loopError ?? e;\n                }\n                if (loopError) {\n                    // \"Causes any future interactions with the associated stream to error\".\n                    // Wraps ReadableStreamDefaultController#error:\n                    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n                    stream.error(loopError);\n                }\n                else {\n                    // Will end the iterator outside of this method,\n                    // keeping previously enqueued chunks.\n                    // Wraps ReadableStreamDefaultController#close:\n                    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n                    stream.close();\n                }\n            }\n        };\n        const runLoopPromise = createAndRunLoop();\n        try {\n            for await (const chunk of stream) {\n                if (chunk === undefined) {\n                    throw new Error(\"Data structure error.\");\n                }\n                const [namespace, mode, payload] = chunk;\n                if (streamMode.includes(mode)) {\n                    if (streamSubgraphs && !streamModeSingle) {\n                        yield [namespace, mode, payload];\n                    }\n                    else if (!streamModeSingle) {\n                        yield [mode, payload];\n                    }\n                    else if (streamSubgraphs) {\n                        yield [namespace, payload];\n                    }\n                    else {\n                        yield payload;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(loopError);\n            throw e;\n        }\n        finally {\n            await runLoopPromise;\n        }\n        await runManager?.handleChainEnd(loop?.output ?? {}, runId, // run_id\n        undefined, // run_type\n        undefined, // tags\n        undefined // metadata\n        );\n    }\n    /**\n     * Run the graph with a single input and config.\n     * @param input The input to the graph.\n     * @param options The configuration to use for the run.\n     */\n    async invoke(input, options) {\n        const streamMode = options?.streamMode ?? \"values\";\n        const config = {\n            ...options,\n            outputKeys: options?.outputKeys ?? this.outputChannels,\n            streamMode,\n        };\n        const chunks = [];\n        const stream = await this.stream(input, config);\n        for await (const chunk of stream) {\n            chunks.push(chunk);\n        }\n        if (streamMode === \"values\") {\n            return chunks[chunks.length - 1];\n        }\n        return chunks;\n    }\n    async _runLoop(params) {\n        const { loop, runner, debug, config } = params;\n        let tickError;\n        try {\n            while (await loop.tick({\n                inputKeys: this.inputChannels,\n            })) {\n                if (debug) {\n                    (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepCheckpoint)(loop.checkpointMetadata.step, loop.channels, this.streamChannelsList);\n                }\n                if (debug) {\n                    (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepTasks)(loop.step, Object.values(loop.tasks));\n                }\n                await runner.tick({\n                    timeout: this.stepTimeout,\n                    retryPolicy: this.retryPolicy,\n                    onStepWrite: (step, writes) => {\n                        if (debug) {\n                            (0,_debug_js__WEBPACK_IMPORTED_MODULE_6__.printStepWrites)(step, writes, this.streamChannelsList);\n                        }\n                    },\n                    maxConcurrency: config.maxConcurrency,\n                    signal: config.signal,\n                });\n            }\n            if (loop.status === \"out_of_steps\") {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_9__.GraphRecursionError([\n                    `Recursion limit of ${config.recursionLimit} reached`,\n                    \"without hitting a stop condition. You can increase the\",\n                    `limit by setting the \"recursionLimit\" config key.`,\n                ].join(\" \"), {\n                    lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n                });\n            }\n        }\n        catch (e) {\n            tickError = e;\n            const suppress = await loop.finishAndHandleError(tickError);\n            if (!suppress) {\n                throw e;\n            }\n        }\n        finally {\n            if (tickError === undefined) {\n                await loop.finishAndHandleError();\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDbUo7QUFDdEI7QUFDdkM7QUFDL0M7QUFDcUI7QUFDWDtBQUNtRDtBQUM3QztBQUN5TjtBQUN2TDtBQUNoQjtBQUN5QztBQUN6RDtBQUNsQjtBQUNzRjtBQUM3RDtBQUNzQjtBQUNoQztBQUNYO0FBQzBEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4REFBOEQ7QUFDOUQsZ0JBQWdCLCtEQUFRO0FBQ3hCO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQVc7QUFDdEM7QUFDQSw0QkFBNEIsNEVBQWlCO0FBQzdDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1CQUFtQixtREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixvQkFBb0Isa0JBQWtCLGVBQWUscUJBQXFCO0FBQzFFO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFLDREQUE0RCxtQkFBbUIsSUFBSSx3QkFBd0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsK0RBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1RUFBWTtBQUN6QztBQUNBLHNDQUFzQywrQkFBK0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsUUFBUSwyREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUVBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLEVBQUUseUVBQThCLENBQUMsRUFBRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0VBQWtFO0FBQ3BHO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCLGdFQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1REFBWTtBQUNoRTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFZO0FBQzVCO0FBQ0EsOEJBQThCLGdEQUFLO0FBQ25DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNERBQWlCLDZGQUE2RiwyREFBMkQ7QUFDak47QUFDQSxnQ0FBZ0MsMERBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQixFQUFFLG1FQUF3QixDQUFDLEVBQUUsUUFBUTtBQUNuRjtBQUNBLDRCQUE0QixnQkFBZ0IsRUFBRSx5RUFBOEIsQ0FBQyxFQUFFLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQXVCO0FBQ2hEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFLLEVBQUUsb0RBQVMsRUFBRSxzRUFBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFZO0FBQ2hDO0FBQ0EsbUJBQW1CLDBEQUFlO0FBQ2xDO0FBQ0Esb0JBQW9CLG9FQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsbURBQW1ELGtFQUF1QjtBQUMxRTtBQUNBLHNCQUFzQix1REFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0VBQXVCO0FBQ3pEO0FBQ0Esb0NBQW9DLDRFQUF5QjtBQUM3RDtBQUNBO0FBQ0EsbURBQW1ELDZEQUFpQjtBQUNwRSx5QkFBeUIsa0VBQXVCO0FBQ2hELHFCQUFxQixLQUFLLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBLDZCQUE2Qix1RUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsbURBQW1ELGtFQUF1QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUF1QjtBQUN6RCxvQ0FBb0MsNEVBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2REFBaUI7QUFDbkUseUJBQXlCLGtFQUF1QjtBQUNoRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBLDZCQUE2Qix1RUFBWTtBQUN6Qyw0QkFBNEIsb0NBQW9DO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLHdEQUF3RCxrRUFBdUI7QUFDL0U7QUFDQSxzQkFBc0IsdURBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0VBQXVCO0FBQzlEO0FBQ0Esb0NBQW9DLDRFQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNkRBQWlCO0FBQ3JFLHFCQUFxQixrRUFBdUI7QUFDNUMsaUJBQWlCO0FBQ2pCO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0VBQWM7QUFDaEMsa0JBQWtCLGdGQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkRBQWlCO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsNkRBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQSw0RUFBNEUsbUVBQWdCO0FBQzVGO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMkRBQTJEO0FBQzNELGlCQUFpQixJQUFJO0FBQ3JCLHVCQUF1QixvRUFBa0I7QUFDekM7QUFDQTtBQUNBLDZCQUE2QixnRUFBYTtBQUMxQztBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsYUFBYTtBQUNiLDhDQUE4Qyw4Q0FBRztBQUNqRDtBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDREQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdEQUFnRCx1REFBWTtBQUM1RDtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFZO0FBQ3BDO0FBQ0Esc0NBQXNDLGdEQUFLO0FBQzNDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQUssRUFBRSxvREFBUyxFQUFFLHNFQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVk7QUFDaEM7QUFDQTtBQUNBLDRFQUE0RSxtRUFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCxpQkFBaUIsSUFBSTtBQUNyQix1QkFBdUIsb0VBQWtCO0FBQ3pDO0FBQ0EsNkNBQTZDLCtDQUFJO0FBQ2pEO0FBQ0EsOEJBQThCLDBEQUFrQjtBQUNoRDtBQUNBLG1HQUFtRyxtRUFBZ0I7QUFDbkg7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwyREFBMkQ7QUFDM0QsaUJBQWlCLElBQUk7QUFDckIsdUJBQXVCLG9FQUFrQjtBQUN6QztBQUNBLDJCQUEyQixnREFBSztBQUNoQztBQUNBLDhCQUE4QiwwREFBa0I7QUFDaEQ7QUFDQSwwQ0FBMEMsMERBQWMsQ0FBQyxnREFBUTtBQUNqRTtBQUNBLDhCQUE4QiwwREFBa0IsaUNBQWlDLDRDQUE0QztBQUM3SDtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFZO0FBQzVCO0FBQ0EsOEJBQThCLGdEQUFLO0FBQ25DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLG1FQUFnQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsaUJBQWlCLEVBQUUsdUVBQXFCO0FBQ3hDO0FBQ0Esc0VBQXNFLHNFQUFLLENBQUMsZ0RBQUs7QUFDakYsdUJBQXVCLG9FQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0Q0FBNEMsdURBQVk7QUFDeEQ7QUFDQTtBQUNBLG9CQUFvQix1REFBWTtBQUNoQztBQUNBLGtDQUFrQyxnREFBSztBQUN2QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFLLEVBQUUsb0RBQVMsRUFBRSxzRUFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9CQUFvQix1REFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSx3REFBd0QsdUZBQXNCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBLGtDQUFrQywwREFBa0I7QUFDcEQ7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQSw4QkFBOEIsMERBQWtCLFVBQVUsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFrQiwrQkFBK0Isa0JBQWtCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1RUFBZ0I7QUFDNUM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLCtCQUErQixvREFBUztBQUN4Qyx3QkFBd0Isc0VBQUssQ0FBQyxvREFBUztBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0VBQVc7QUFDOUQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrREFBa0QsZUFBZTtBQUNqRTtBQUNBLHlCQUF5QiwwREFBZTtBQUN4Qyx5QkFBeUIsMERBQWUsZ0NBQWdDLHFEQUFVO0FBQ2xGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwrQ0FBSTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQVk7QUFDeEIsZ0NBQWdDLHVFQUFxQjtBQUNyRCx3RUFBd0UsbUVBQWdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNFQUFzRSwrQ0FBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRUFBa0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZLGdCQUFnQixHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRkFBcUY7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUF1QjtBQUN6RCxzREFBc0Qsa0VBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxRUFBbUI7QUFDckM7QUFDQTtBQUNBLG1CQUFtQiw4RUFBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQWdCO0FBQ3pDLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBbUI7QUFDL0M7QUFDQTtBQUNBLGdCQUFnQiwyRUFBd0I7QUFDeEM7QUFDQSx5Q0FBeUMsb0VBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUVBQThCO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3Q0FBd0MsZ0VBQXFCO0FBQzdELG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNGQUEyQjtBQUNqRTtBQUNBLFFBQVEsK0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaURBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQ0FBbUMscURBQVk7QUFDL0M7QUFDQSx3REFBd0QsbUVBQXdCO0FBQ2hGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQWlCO0FBQzFDO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0IsOERBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxvQkFBb0IseURBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFlO0FBQzNDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQiwyREFBbUI7QUFDN0MsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvcHJlZ2VsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBSdW5uYWJsZSwgUnVubmFibGVTZXF1ZW5jZSwgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnLCBtZXJnZUNvbmZpZ3MsIHBhdGNoQ29uZmlnLCBfY29lcmNlVG9SdW5uYWJsZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuaW1wb3J0IHsgY29tcGFyZUNoYW5uZWxWZXJzaW9ucywgY29weUNoZWNrcG9pbnQsIGVtcHR5Q2hlY2twb2ludCwgU0NIRURVTEVELCB1dWlkNSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2hlY2twb2ludCwgZW1wdHlDaGFubmVscywgaXNCYXNlQ2hhbm5lbCwgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgUHJlZ2VsTm9kZSB9IGZyb20gXCIuL3JlYWQuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlR3JhcGgsIHZhbGlkYXRlS2V5cyB9IGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5pbXBvcnQgeyBtYXBJbnB1dCwgcmVhZENoYW5uZWxzIH0gZnJvbSBcIi4vaW8uanNcIjtcbmltcG9ydCB7IHByaW50U3RlcENoZWNrcG9pbnQsIHByaW50U3RlcFRhc2tzLCBwcmludFN0ZXBXcml0ZXMsIHRhc2tzV2l0aFdyaXRlcywgfSBmcm9tIFwiLi9kZWJ1Zy5qc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbFdyaXRlLCBQQVNTVEhST1VHSCB9IGZyb20gXCIuL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBDT05GSUdfS0VZX0NIRUNLUE9JTlRFUiwgQ09ORklHX0tFWV9SRUFELCBDT05GSUdfS0VZX1NFTkQsIENPTkZJR19LRVlfVEFTS19JRCwgRVJST1IsIElOUFVULCBJTlRFUlJVUFQsIFBVU0gsIENIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUiwgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5ELCBDT05GSUdfS0VZX1NUUkVBTSwgTlVMTF9UQVNLX0lELCBDT1BZLCBFTkQsIENPTkZJR19LRVlfTk9ERV9GSU5JU0hFRCwgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBHcmFwaFJlY3Vyc2lvbkVycm9yLCBHcmFwaFZhbHVlRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciwgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBfcHJlcGFyZU5leHRUYXNrcywgX2xvY2FsUmVhZCwgX2FwcGx5V3JpdGVzLCB9IGZyb20gXCIuL2FsZ28uanNcIjtcbmltcG9ydCB7IF9jb2VyY2VUb0RpY3QsIGNvbWJpbmVBYm9ydFNpZ25hbHMsIGdldE5ld0NoYW5uZWxWZXJzaW9ucywgcGF0Y2hDaGVja3BvaW50TWFwLCB9IGZyb20gXCIuL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBmaW5kU3ViZ3JhcGhQcmVnZWwgfSBmcm9tIFwiLi91dGlscy9zdWJncmFwaC5qc1wiO1xuaW1wb3J0IHsgUHJlZ2VsTG9vcCB9IGZyb20gXCIuL2xvb3AuanNcIjtcbmltcG9ydCB7IENoYW5uZWxLZXlQbGFjZWhvbGRlciwgaXNDb25maWd1cmVkTWFuYWdlZFZhbHVlLCBNYW5hZ2VkVmFsdWVNYXBwaW5nLCBOb29wTWFuYWdlZFZhbHVlLCB9IGZyb20gXCIuLi9tYW5hZ2VkL2Jhc2UuanNcIjtcbmltcG9ydCB7IGdhdGhlckl0ZXJhdG9yLCBwYXRjaENvbmZpZ3VyYWJsZSB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgZW5zdXJlTGFuZ0dyYXBoQ29uZmlnLCByZWNhc3RDaGVja3BvaW50TmFtZXNwYWNlLCB9IGZyb20gXCIuL3V0aWxzL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgU3RyZWFtTWVzc2FnZXNIYW5kbGVyIH0gZnJvbSBcIi4vbWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IFByZWdlbFJ1bm5lciB9IGZyb20gXCIuL3J1bm5lci5qc1wiO1xuaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbVdpdGhBYm9ydFNpZ25hbCwgSXRlcmFibGVSZWFkYWJsZVdyaXRhYmxlU3RyZWFtLCB9IGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciB3b3JraW5nIHdpdGggY2hhbm5lbHMgaW4gdGhlIFByZWdlbCBzeXN0ZW0uXG4gKiBQcm92aWRlcyBzdGF0aWMgbWV0aG9kcyBmb3Igc3Vic2NyaWJpbmcgdG8gY2hhbm5lbHMgYW5kIHdyaXRpbmcgdG8gdGhlbS5cbiAqXG4gKiBDaGFubmVscyBhcmUgdGhlIGNvbW11bmljYXRpb24gcGF0aHdheXMgYmV0d2VlbiBub2RlcyBpbiBhIFByZWdlbCBncmFwaC5cbiAqIFRoZXkgZW5hYmxlIG1lc3NhZ2UgcGFzc2luZyBhbmQgc3RhdGUgdXBkYXRlcyBiZXR3ZWVuIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgZ3JhcGguXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFubmVsIHtcbiAgICBzdGF0aWMgc3Vic2NyaWJlVG8oY2hhbm5lbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIHRhZ3MgfSA9IHtcbiAgICAgICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGFnczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMgPz8ge30pLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFubmVscykgJiYga2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNwZWNpZnkgYSBrZXkgd2hlbiBzdWJzY3JpYmluZyB0byBtdWx0aXBsZSBjaGFubmVsc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbm5lbE1hcHBpbmdPckFycmF5O1xuICAgICAgICBpZiAoaXNTdHJpbmcoY2hhbm5lbHMpKSB7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE1hcHBpbmdPckFycmF5ID0geyBba2V5XTogY2hhbm5lbHMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxNYXBwaW5nT3JBcnJheSA9IFtjaGFubmVsc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsTWFwcGluZ09yQXJyYXkgPSBPYmplY3QuZnJvbUVudHJpZXMoY2hhbm5lbHMubWFwKChjaGFuKSA9PiBbY2hhbiwgY2hhbl0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmlnZ2VycyA9IEFycmF5LmlzQXJyYXkoY2hhbm5lbHMpID8gY2hhbm5lbHMgOiBbY2hhbm5lbHNdO1xuICAgICAgICByZXR1cm4gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxNYXBwaW5nT3JBcnJheSxcbiAgICAgICAgICAgIHRyaWdnZXJzLFxuICAgICAgICAgICAgdGFncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDaGFubmVsV3JpdGUgdGhhdCBzcGVjaWZpZXMgaG93IHRvIHdyaXRlIHZhbHVlcyB0byBjaGFubmVscy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZGVmaW5lIGhvdyBub2RlcyBzZW5kIG91dHB1dCB0byBjaGFubmVscy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIFdyaXRlIHRvIG11bHRpcGxlIGNoYW5uZWxzXG4gICAgICogY29uc3Qgd3JpdGUgPSBDaGFubmVsLndyaXRlVG8oW1wib3V0cHV0XCIsIFwic3RhdGVcIl0pO1xuICAgICAqXG4gICAgICogLy8gV3JpdGUgd2l0aCBzcGVjaWZpYyB2YWx1ZXNcbiAgICAgKiBjb25zdCB3cml0ZSA9IENoYW5uZWwud3JpdGVUbyhbXCJvdXRwdXRcIl0sIHtcbiAgICAgKiAgIHN0YXRlOiBcImNvbXBsZXRlZFwiLFxuICAgICAqICAgcmVzdWx0OiBjYWxjdWxhdGVSZXN1bHQoKVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gV3JpdGUgd2l0aCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uXG4gICAgICogY29uc3Qgd3JpdGUgPSBDaGFubmVsLndyaXRlVG8oW1wib3V0cHV0XCJdLCB7XG4gICAgICogICByZXN1bHQ6ICh4KSA9PiBwcm9jZXNzUmVzdWx0KHgpXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbHMgLSBBcnJheSBvZiBjaGFubmVsIG5hbWVzIHRvIHdyaXRlIHRvXG4gICAgICogQHBhcmFtIHdyaXRlcyAtIE9wdGlvbmFsIG1hcCBvZiBjaGFubmVsIG5hbWVzIHRvIHZhbHVlcyBvciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIENoYW5uZWxXcml0ZSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byB3cml0ZSB0byB0aGUgc3BlY2lmaWVkIGNoYW5uZWxzXG4gICAgICovXG4gICAgc3RhdGljIHdyaXRlVG8oY2hhbm5lbHMsIHdyaXRlcykge1xuICAgICAgICBjb25zdCBjaGFubmVsV3JpdGVFbnRyaWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBjaGFubmVscykge1xuICAgICAgICAgICAgY2hhbm5lbFdyaXRlRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBQQVNTVEhST1VHSCxcbiAgICAgICAgICAgICAgICBza2lwTm9uZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh3cml0ZXMgPz8ge30pKSB7XG4gICAgICAgICAgICBpZiAoUnVubmFibGUuaXNSdW5uYWJsZSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsV3JpdGVFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBQQVNTVEhST1VHSCxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE5vbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlcjogX2NvZXJjZVRvUnVubmFibGUodmFsdWUpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbFdyaXRlRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDoga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE5vbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbm5lbFdyaXRlKGNoYW5uZWxXcml0ZUVudHJpZXMpO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIFByZWdlbCBjbGFzcyBpcyB0aGUgY29yZSBydW50aW1lIGVuZ2luZSBvZiBMYW5nR3JhcGgsIGltcGxlbWVudGluZyBhIG1lc3NhZ2UtcGFzc2luZyBncmFwaCBjb21wdXRhdGlvbiBtb2RlbFxuICogaW5zcGlyZWQgYnkgW0dvb2dsZSdzIFByZWdlbCBzeXN0ZW1dKGh0dHBzOi8vcmVzZWFyY2guZ29vZ2xlL3B1YnMvcHJlZ2VsLWEtc3lzdGVtLWZvci1sYXJnZS1zY2FsZS1ncmFwaC1wcm9jZXNzaW5nLykuXG4gKiBJdCBwcm92aWRlcyB0aGUgZm91bmRhdGlvbiBmb3IgYnVpbGRpbmcgcmVsaWFibGUsIGNvbnRyb2xsYWJsZSBhZ2VudCB3b3JrZmxvd3MgdGhhdCBjYW4gZXZvbHZlIHN0YXRlIG92ZXIgdGltZS5cbiAqXG4gKiBLZXkgZmVhdHVyZXM6XG4gKiAtIE1lc3NhZ2UgcGFzc2luZyBiZXR3ZWVuIG5vZGVzIGluIGRpc2NyZXRlIFwic3VwZXJzdGVwc1wiXG4gKiAtIEJ1aWx0LWluIHBlcnNpc3RlbmNlIGxheWVyIHRocm91Z2ggY2hlY2twb2ludGVyc1xuICogLSBGaXJzdC1jbGFzcyBzdHJlYW1pbmcgc3VwcG9ydCBmb3IgdmFsdWVzLCB1cGRhdGVzLCBhbmQgZXZlbnRzXG4gKiAtIEh1bWFuLWluLXRoZS1sb29wIGNhcGFiaWxpdGllcyB2aWEgaW50ZXJydXB0c1xuICogLSBTdXBwb3J0IGZvciBwYXJhbGxlbCBub2RlIGV4ZWN1dGlvbiB3aXRoaW4gc3VwZXJzdGVwc1xuICpcbiAqIFRoZSBQcmVnZWwgY2xhc3MgaXMgbm90IGludGVuZGVkIHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseSBieSBjb25zdW1lcnMuIEluc3RlYWQsIHVzZSB0aGUgZm9sbG93aW5nIGhpZ2hlci1sZXZlbCBBUElzOlxuICogLSB7QGxpbmsgU3RhdGVHcmFwaH06IFRoZSBtYWluIGdyYXBoIGNsYXNzIGZvciBidWlsZGluZyBhZ2VudCB3b3JrZmxvd3NcbiAqICAgLSBDb21waWxpbmcgYSB7QGxpbmsgU3RhdGVHcmFwaH0gd2lsbCByZXR1cm4gYSB7QGxpbmsgQ29tcGlsZWRHcmFwaH0gaW5zdGFuY2UsIHdoaWNoIGV4dGVuZHMgYFByZWdlbGBcbiAqIC0gRnVuY3Rpb25hbCBBUEk6IEEgZGVjbGFyYXRpdmUgYXBwcm9hY2ggdXNpbmcgdGFza3MgYW5kIGVudHJ5cG9pbnRzXG4gKiAgIC0gQSBgUHJlZ2VsYCBpbnN0YW5jZSBpcyByZXR1cm5lZCBieSB0aGUge0BsaW5rIGVudHJ5cG9pbnR9IGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFVzaW5nIFN0YXRlR3JhcGggQVBJXG4gKiBjb25zdCBncmFwaCA9IG5ldyBTdGF0ZUdyYXBoKGFubm90YXRpb24pXG4gKiAgIC5hZGROb2RlKFwibm9kZUFcIiwgbXlOb2RlRnVuY3Rpb24pXG4gKiAgIC5hZGRFZGdlKFwibm9kZUFcIiwgXCJub2RlQlwiKVxuICogICAuY29tcGlsZSgpO1xuICpcbiAqIC8vIFRoZSBjb21waWxlZCBncmFwaCBpcyBhIFByZWdlbCBpbnN0YW5jZVxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3JhcGguaW52b2tlKGlucHV0KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBVc2luZyBGdW5jdGlvbmFsIEFQSVxuICogaW1wb3J0IHsgdGFzaywgZW50cnlwb2ludCB9IGZyb20gXCJAbGFuZ2NoYWluL2xhbmdncmFwaFwiO1xuICogaW1wb3J0IHsgTWVtb3J5U2F2ZXIgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuICpcbiAqIC8vIERlZmluZSB0YXNrcyB0aGF0IGNhbiBiZSBjb21wb3NlZFxuICogY29uc3QgYWRkT25lID0gdGFzayhcImFkZFwiLCBhc3luYyAoeDogbnVtYmVyKSA9PiB4ICsgMSk7XG4gKlxuICogLy8gQ3JlYXRlIGEgd29ya2Zsb3cgdXNpbmcgdGhlIGVudHJ5cG9pbnQgZnVuY3Rpb25cbiAqIGNvbnN0IHdvcmtmbG93ID0gZW50cnlwb2ludCh7XG4gKiAgIG5hbWU6IFwid29ya2Zsb3dcIixcbiAqICAgY2hlY2twb2ludGVyOiBuZXcgTWVtb3J5U2F2ZXIoKVxuICogfSwgYXN5bmMgKG51bWJlcnM6IG51bWJlcltdKSA9PiB7XG4gKiAgIC8vIFRhc2tzIGNhbiBiZSBydW4gaW4gcGFyYWxsZWxcbiAqICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKG51bWJlcnMubWFwKG4gPT4gYWRkT25lKG4pKSk7XG4gKiAgIHJldHVybiByZXN1bHRzO1xuICogfSk7XG4gKlxuICogLy8gVGhlIHdvcmtmbG93IGlzIGEgUHJlZ2VsIGluc3RhbmNlXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCB3b3JrZmxvdy5pbnZva2UoWzEsIDIsIDNdKTsgLy8gUmV0dXJucyBbMiwgMywgNF1cbiAqIGBgYFxuICpcbiAqIEB0eXBlUGFyYW0gTm9kZXMgLSBNYXBwaW5nIG9mIG5vZGUgbmFtZXMgdG8gdGhlaXIge0BsaW5rIFByZWdlbE5vZGV9IGltcGxlbWVudGF0aW9uc1xuICogQHR5cGVQYXJhbSBDaGFubmVscyAtIE1hcHBpbmcgb2YgY2hhbm5lbCBuYW1lcyB0byB0aGVpciB7QGxpbmsgQmFzZUNoYW5uZWx9IG9yIHtAbGluayBNYW5hZ2VkVmFsdWVTcGVjfSBpbXBsZW1lbnRhdGlvbnNcbiAqIEB0eXBlUGFyYW0gQ29uZmlndXJhYmxlRmllbGRUeXBlIC0gVHlwZSBvZiBjb25maWd1cmFibGUgZmllbGRzIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgZ3JhcGhcbiAqIEB0eXBlUGFyYW0gSW5wdXRUeXBlIC0gVHlwZSBvZiBpbnB1dCB2YWx1ZXMgYWNjZXB0ZWQgYnkgdGhlIGdyYXBoXG4gKiBAdHlwZVBhcmFtIE91dHB1dFR5cGUgLSBUeXBlIG9mIG91dHB1dCB2YWx1ZXMgcHJvZHVjZWQgYnkgdGhlIGdyYXBoXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmVnZWwgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgY2xhc3Mgd2hlbiBzZXJpYWxpemVkXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkxhbmdHcmFwaFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgUHJlZ2VsIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgTGFuZ0NoYWluIG5hbWVzcGFjZSBmb3Igc2VyaWFsaXphdGlvbiBuZWNlc3NhcnkgYmVjYXVzZSBQcmVnZWwgZXh0ZW5kcyBSdW5uYWJsZSAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdncmFwaFwiLCBcInByZWdlbFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBGbGFnIGluZGljYXRpbmcgdGhpcyBpcyBhIFByZWdlbCBpbnN0YW5jZSAtIG5lY2Vzc2FyeSBmb3Igc2VyaWFsaXphdGlvbiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZ19pc19wcmVnZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgbm9kZXMgaW4gdGhlIGdyYXBoLCBtYXBwaW5nIG5vZGUgbmFtZXMgdG8gdGhlaXIgUHJlZ2VsTm9kZSBpbnN0YW5jZXMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBjaGFubmVscyBpbiB0aGUgZ3JhcGgsIG1hcHBpbmcgY2hhbm5lbCBuYW1lcyB0byB0aGVpciBCYXNlQ2hhbm5lbCBvciBNYW5hZ2VkVmFsdWVTcGVjIGluc3RhbmNlcyAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlucHV0IGNoYW5uZWxzIGZvciB0aGUgZ3JhcGguIFRoZXNlIGNoYW5uZWxzIHJlY2VpdmUgdGhlIGluaXRpYWwgaW5wdXQgd2hlbiB0aGUgZ3JhcGggaXMgaW52b2tlZC5cbiAgICAgICAgICogQ2FuIGJlIGEgc2luZ2xlIGNoYW5uZWwga2V5IG9yIGFuIGFycmF5IG9mIGNoYW5uZWwga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0Q2hhbm5lbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvdXRwdXQgY2hhbm5lbHMgZm9yIHRoZSBncmFwaC4gVGhlc2UgY2hhbm5lbHMgY29udGFpbiB0aGUgZmluYWwgb3V0cHV0IHdoZW4gdGhlIGdyYXBoIGNvbXBsZXRlcy5cbiAgICAgICAgICogQ2FuIGJlIGEgc2luZ2xlIGNoYW5uZWwga2V5IG9yIGFuIGFycmF5IG9mIGNoYW5uZWwga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dENoYW5uZWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgdmFsaWRhdGUgdGhlIGdyYXBoIHN0cnVjdHVyZSB3aGVuIGl0IGlzIGNvbXBpbGVkLiBEZWZhdWx0cyB0byB0cnVlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvVmFsaWRhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RyZWFtaW5nIG1vZGVzIGVuYWJsZWQgZm9yIHRoaXMgZ3JhcGguIERlZmF1bHRzIHRvIFtcInZhbHVlc1wiXS5cbiAgICAgICAgICogU3VwcG9ydGVkIG1vZGVzOlxuICAgICAgICAgKiAtIFwidmFsdWVzXCI6IFN0cmVhbXMgdGhlIGZ1bGwgc3RhdGUgYWZ0ZXIgZWFjaCBzdGVwXG4gICAgICAgICAqIC0gXCJ1cGRhdGVzXCI6IFN0cmVhbXMgc3RhdGUgdXBkYXRlcyBhZnRlciBlYWNoIHN0ZXBcbiAgICAgICAgICogLSBcIm1lc3NhZ2VzXCI6IFN0cmVhbXMgbWVzc2FnZXMgZnJvbSB3aXRoaW4gbm9kZXNcbiAgICAgICAgICogLSBcImN1c3RvbVwiOiBTdHJlYW1zIGN1c3RvbSBldmVudHMgZnJvbSB3aXRoaW4gbm9kZXNcbiAgICAgICAgICogLSBcImRlYnVnXCI6IFN0cmVhbXMgZXZlbnRzIHJlbGF0ZWQgdG8gdGhlIGV4ZWN1dGlvbiBvZiB0aGUgZ3JhcGggLSB1c2VmdWwgZm9yIHRyYWNpbmcgJiBkZWJ1Z2dpbmcgZ3JhcGggZXhlY3V0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1Nb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJ2YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBjaGFubmVscyB0byBzdHJlYW0uIElmIG5vdCBzcGVjaWZpZWQsIGFsbCBjaGFubmVscyB3aWxsIGJlIHN0cmVhbWVkLlxuICAgICAgICAgKiBDYW4gYmUgYSBzaW5nbGUgY2hhbm5lbCBrZXkgb3IgYW4gYXJyYXkgb2YgY2hhbm5lbCBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtQ2hhbm5lbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGFycmF5IG9mIG5vZGUgbmFtZXMgb3IgXCJhbGxcIiB0byBpbnRlcnJ1cHQgYWZ0ZXIgZXhlY3V0aW5nIHRoZXNlIG5vZGVzLlxuICAgICAgICAgKiBVc2VkIGZvciBpbXBsZW1lbnRpbmcgaHVtYW4taW4tdGhlLWxvb3Agd29ya2Zsb3dzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJydXB0QWZ0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIGFycmF5IG9mIG5vZGUgbmFtZXMgb3IgXCJhbGxcIiB0byBpbnRlcnJ1cHQgYmVmb3JlIGV4ZWN1dGluZyB0aGVzZSBub2Rlcy5cbiAgICAgICAgICogVXNlZCBmb3IgaW1wbGVtZW50aW5nIGh1bWFuLWluLXRoZS1sb29wIHdvcmtmbG93cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVycnVwdEJlZm9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBleGVjdXRpb24gb2YgZWFjaCBzdXBlcnN0ZXAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RlcFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmcuIERlZmF1bHRzIHRvIGZhbHNlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBjaGVja3BvaW50ZXIgZm9yIHBlcnNpc3RpbmcgZ3JhcGggc3RhdGUuXG4gICAgICAgICAqIFdoZW4gcHJvdmlkZWQsIHNhdmVzIGEgY2hlY2twb2ludCBvZiB0aGUgZ3JhcGggc3RhdGUgYXQgZXZlcnkgc3VwZXJzdGVwLlxuICAgICAgICAgKiBXaGVuIGZhbHNlIG9yIHVuZGVmaW5lZCwgY2hlY2twb2ludGluZyBpcyBkaXNhYmxlZCwgYW5kIHRoZSBncmFwaCB3aWxsIG5vdCBiZSBhYmxlIHRvIHNhdmUgb3IgcmVzdG9yZSBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogT3B0aW9uYWwgcmV0cnkgcG9saWN5IGZvciBoYW5kbGluZyBmYWlsdXJlcyBpbiBub2RlIGV4ZWN1dGlvbiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXRyeVBvbGljeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgZ3JhcGggZXhlY3V0aW9uLCBjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlci1pbnZvY2F0aW9uIGJhc2lzICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgbG9uZy10ZXJtIG1lbW9yeSBzdG9yZSBmb3IgdGhlIGdyYXBoLCBhbGxvd3MgZm9yIHBlcnNpc3RhbmNlICYgcmV0cmlldmFsIG9mIGRhdGEgYWNyb3NzIHRocmVhZHNcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB7IHN0cmVhbU1vZGUgfSA9IGZpZWxkcztcbiAgICAgICAgaWYgKHN0cmVhbU1vZGUgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShzdHJlYW1Nb2RlKSkge1xuICAgICAgICAgICAgc3RyZWFtTW9kZSA9IFtzdHJlYW1Nb2RlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzID0gZmllbGRzLm5vZGVzO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gZmllbGRzLmNoYW5uZWxzO1xuICAgICAgICB0aGlzLmF1dG9WYWxpZGF0ZSA9IGZpZWxkcy5hdXRvVmFsaWRhdGUgPz8gdGhpcy5hdXRvVmFsaWRhdGU7XG4gICAgICAgIHRoaXMuc3RyZWFtTW9kZSA9IHN0cmVhbU1vZGUgPz8gdGhpcy5zdHJlYW1Nb2RlO1xuICAgICAgICB0aGlzLmlucHV0Q2hhbm5lbHMgPSBmaWVsZHMuaW5wdXRDaGFubmVscztcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVscyA9IGZpZWxkcy5vdXRwdXRDaGFubmVscztcbiAgICAgICAgdGhpcy5zdHJlYW1DaGFubmVscyA9IGZpZWxkcy5zdHJlYW1DaGFubmVscyA/PyB0aGlzLnN0cmVhbUNoYW5uZWxzO1xuICAgICAgICB0aGlzLmludGVycnVwdEFmdGVyID0gZmllbGRzLmludGVycnVwdEFmdGVyO1xuICAgICAgICB0aGlzLmludGVycnVwdEJlZm9yZSA9IGZpZWxkcy5pbnRlcnJ1cHRCZWZvcmU7XG4gICAgICAgIHRoaXMuc3RlcFRpbWVvdXQgPSBmaWVsZHMuc3RlcFRpbWVvdXQgPz8gdGhpcy5zdGVwVGltZW91dDtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZpZWxkcy5kZWJ1ZyA/PyB0aGlzLmRlYnVnO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRlciA9IGZpZWxkcy5jaGVja3BvaW50ZXI7XG4gICAgICAgIHRoaXMucmV0cnlQb2xpY3kgPSBmaWVsZHMucmV0cnlQb2xpY3k7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZmllbGRzLmNvbmZpZztcbiAgICAgICAgdGhpcy5zdG9yZSA9IGZpZWxkcy5zdG9yZTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmF1dG9WYWxpZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFByZWdlbCBncmFwaCB3aXRoIHVwZGF0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBmb2xsb3dzIHRoZSBpbW11dGFibGUgcGF0dGVybiAtIGluc3RlYWQgb2YgbW9kaWZ5aW5nIHRoZSBjdXJyZW50IGluc3RhbmNlLFxuICAgICAqIGl0IHJldHVybnMgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgbWVyZ2VkIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCBkZWJ1ZyBlbmFibGVkXG4gICAgICogY29uc3QgZGVidWdHcmFwaCA9IGdyYXBoLndpdGhDb25maWcoeyBkZWJ1ZzogdHJ1ZSB9KTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWMgdGhyZWFkIElEXG4gICAgICogY29uc3QgdGhyZWFkR3JhcGggPSBncmFwaC53aXRoQ29uZmlnKHtcbiAgICAgKiAgIGNvbmZpZ3VyYWJsZTogeyB0aHJlYWRfaWQ6IFwiMTIzXCIgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIHRvIG1lcmdlIHdpdGggdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIEEgbmV3IFByZWdlbCBpbnN0YW5jZSB3aXRoIHRoZSBtZXJnZWQgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIFJlbW92ZSBpZ25vcmUgd2hlbiB3ZSByZW1vdmUgc3VwcG9ydCBmb3IgMC4yIHZlcnNpb25zIG9mIGNvcmVcbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7IC4uLnRoaXMsIGNvbmZpZzogbWVyZ2VkQ29uZmlnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGdyYXBoIHN0cnVjdHVyZSB0byBlbnN1cmUgaXQgaXMgd2VsbC1mb3JtZWQuXG4gICAgICogQ2hlY2tzIGZvcjpcbiAgICAgKiAtIE5vIG9ycGhhbmVkIG5vZGVzXG4gICAgICogLSBWYWxpZCBpbnB1dC9vdXRwdXQgY2hhbm5lbCBjb25maWd1cmF0aW9uc1xuICAgICAqIC0gVmFsaWQgaW50ZXJydXB0IGNvbmZpZ3VyYXRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGlzIC0gVGhlIFByZWdlbCBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAgICogQHRocm93cyB7R3JhcGhWYWxpZGF0aW9uRXJyb3J9IElmIHRoZSBncmFwaCBzdHJ1Y3R1cmUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIHZhbGlkYXRlKCkge1xuICAgICAgICB2YWxpZGF0ZUdyYXBoKHtcbiAgICAgICAgICAgIG5vZGVzOiB0aGlzLm5vZGVzLFxuICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHMsXG4gICAgICAgICAgICBvdXRwdXRDaGFubmVsczogdGhpcy5vdXRwdXRDaGFubmVscyxcbiAgICAgICAgICAgIGlucHV0Q2hhbm5lbHM6IHRoaXMuaW5wdXRDaGFubmVscyxcbiAgICAgICAgICAgIHN0cmVhbUNoYW5uZWxzOiB0aGlzLnN0cmVhbUNoYW5uZWxzLFxuICAgICAgICAgICAgaW50ZXJydXB0QWZ0ZXJOb2RlczogdGhpcy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIGludGVycnVwdEJlZm9yZU5vZGVzOiB0aGlzLmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgdGhhdCBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAgICogSWYgc3RyZWFtQ2hhbm5lbHMgaXMgc3BlY2lmaWVkLCByZXR1cm5zIHRob3NlIGNoYW5uZWxzLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgY2hhbm5lbHMgaW4gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgY2hhbm5lbCBrZXlzIHRvIHN0cmVhbVxuICAgICAqL1xuICAgIGdldCBzdHJlYW1DaGFubmVsc0xpc3QoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3RyZWFtQ2hhbm5lbHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmVhbUNoYW5uZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RyZWFtQ2hhbm5lbHNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNoYW5uZWxzIHRvIHN0cmVhbSBpbiB0aGVpciBvcmlnaW5hbCBmb3JtYXQuXG4gICAgICogSWYgc3RyZWFtQ2hhbm5lbHMgaXMgc3BlY2lmaWVkLCByZXR1cm5zIGl0IGFzLWlzIChlaXRoZXIgc2luZ2xlIGtleSBvciBhcnJheSkuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBjaGFubmVscyBpbiB0aGUgZ3JhcGggYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBDaGFubmVsIGtleXMgdG8gc3RyZWFtLCBlaXRoZXIgYXMgYSBzaW5nbGUga2V5IG9yIGFycmF5XG4gICAgICovXG4gICAgZ2V0IHN0cmVhbUNoYW5uZWxzQXNJcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBkcmF3YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggc3RydWN0dXJlLlxuICAgICAqIFRoaXMgaXMgYW4gYXN5bmMgdmVyc2lvbiBvZiBnZXRHcmFwaCgpIGFuZCBpcyB0aGUgcHJlZmVycmVkIG1ldGhvZCB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgZ2VuZXJhdGluZyB0aGUgZ3JhcGggdmlzdWFsaXphdGlvblxuICAgICAqIEByZXR1cm5zIEEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYXBoIHRoYXQgY2FuIGJlIHZpc3VhbGl6ZWRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRHcmFwaEFzeW5jKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmFwaChjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBzdWJncmFwaHMgd2l0aGluIHRoaXMgZ3JhcGguXG4gICAgICogQSBzdWJncmFwaCBpcyBhIFByZWdlbCBpbnN0YW5jZSB0aGF0IGlzIG5lc3RlZCB3aXRoaW4gYSBub2RlIG9mIHRoaXMgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZ2V0U3ViZ3JhcGhzQXN5bmMgaW5zdGVhZC4gVGhlIGFzeW5jIG1ldGhvZCB3aWxsIGJlY29tZSB0aGUgZGVmYXVsdCBpbiB0aGUgbmV4dCBtaW5vciByZWxlYXNlLlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIHN1YmdyYXBoc1xuICAgICAqIEBwYXJhbSByZWN1cnNlIC0gV2hldGhlciB0byByZWN1cnNpdmVseSBnZXQgc3ViZ3JhcGhzIG9mIHN1YmdyYXBoc1xuICAgICAqIEByZXR1cm5zIEdlbmVyYXRvciB5aWVsZGluZyB0dXBsZXMgb2YgW25hbWUsIHN1YmdyYXBoXVxuICAgICAqL1xuICAgICpnZXRTdWJncmFwaHMobmFtZXNwYWNlLCByZWN1cnNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykpIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBieSBwcmVmaXhcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghbmFtZXNwYWNlLnN0YXJ0c1dpdGgobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IG5vZGUuc3ViZ3JhcGhzPy5sZW5ndGggPyBub2RlLnN1YmdyYXBocyA6IFtub2RlLmJvdW5kXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmFwaCA9IGZpbmRTdWJncmFwaFByZWdlbChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChncmFwaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtuYW1lLCBncmFwaF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbmFtZSwgZ3JhcGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TmFtZXNwYWNlID0gbmFtZXNwYWNlLnNsaWNlKG5hbWUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzdWJncmFwaE5hbWUsIHN1YmdyYXBoXSBvZiBncmFwaC5nZXRTdWJncmFwaHMobmV3TmFtZXNwYWNlLCByZWN1cnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7bmFtZX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX1NFUEFSQVRPUn0ke3N1YmdyYXBoTmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHN1YmdyYXBocyB3aXRoaW4gdGhpcyBncmFwaCBhc3luY2hyb25vdXNseS5cbiAgICAgKiBBIHN1YmdyYXBoIGlzIGEgUHJlZ2VsIGluc3RhbmNlIHRoYXQgaXMgbmVzdGVkIHdpdGhpbiBhIG5vZGUgb2YgdGhpcyBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIHN1YmdyYXBoc1xuICAgICAqIEBwYXJhbSByZWN1cnNlIC0gV2hldGhlciB0byByZWN1cnNpdmVseSBnZXQgc3ViZ3JhcGhzIG9mIHN1YmdyYXBoc1xuICAgICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIHR1cGxlcyBvZiBbbmFtZSwgc3ViZ3JhcGhdXG4gICAgICovXG4gICAgYXN5bmMgKmdldFN1YmdyYXBoc0FzeW5jKG5hbWVzcGFjZSwgcmVjdXJzZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmdldFN1YmdyYXBocyhuYW1lc3BhY2UsIHJlY3Vyc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIHN0YXRlIHNuYXBzaG90IGZyb20gc2F2ZWQgY2hlY2twb2ludCBkYXRhLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgbWV0aG9kIHVzZWQgYnkgZ2V0U3RhdGUgYW5kIGdldFN0YXRlSGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIGZvciBwcmVwYXJpbmcgdGhlIHNuYXBzaG90XG4gICAgICogQHBhcmFtIHNhdmVkIC0gT3B0aW9uYWwgc2F2ZWQgY2hlY2twb2ludCBkYXRhXG4gICAgICogQHBhcmFtIHN1YmdyYXBoQ2hlY2twb2ludGVyIC0gT3B0aW9uYWwgY2hlY2twb2ludGVyIGZvciBzdWJncmFwaHNcbiAgICAgKiBAcGFyYW0gYXBwbHlQZW5kaW5nV3JpdGVzIC0gV2hldGhlciB0byBhcHBseSBwZW5kaW5nIHdyaXRlcyB0byB0YXNrcyBhbmQgdGhlbiB0byBjaGFubmVsc1xuICAgICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgdGhlIGdyYXBoIHN0YXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgX3ByZXBhcmVTdGF0ZVNuYXBzaG90KHsgY29uZmlnLCBzYXZlZCwgc3ViZ3JhcGhDaGVja3BvaW50ZXIsIGFwcGx5UGVuZGluZ1dyaXRlcyA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGlmIChzYXZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlczoge30sXG4gICAgICAgICAgICAgICAgbmV4dDogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBjaGFubmVsc1xuICAgICAgICBjb25zdCB7IG1hbmFnZWQgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNwZWNzKGNvbmZpZywge1xuICAgICAgICAgICAgc2tpcE1hbmFnZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGVtcHR5Q2hhbm5lbHModGhpcy5jaGFubmVscywgc2F2ZWQuY2hlY2twb2ludCk7XG4gICAgICAgIC8vIEFwcGx5IG51bGwgd3JpdGVzIGZpcnN0IChmcm9tIE5VTExfVEFTS19JRClcbiAgICAgICAgaWYgKHNhdmVkLnBlbmRpbmdXcml0ZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbnVsbFdyaXRlcyA9IHNhdmVkLnBlbmRpbmdXcml0ZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbdGFza0lkLCBfXSkgPT4gdGFza0lkID09PSBOVUxMX1RBU0tfSUQpXG4gICAgICAgICAgICAgICAgLm1hcCgoW18sIGNoYW5uZWwsIHZhbHVlXSkgPT4gW1N0cmluZyhjaGFubmVsKSwgdmFsdWVdKTtcbiAgICAgICAgICAgIGlmIChudWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoc2F2ZWQuY2hlY2twb2ludCwgY2hhbm5lbHMsIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IG51bGxXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBuZXh0IHRhc2tzXG4gICAgICAgIGNvbnN0IG5leHRUYXNrcyA9IE9iamVjdC52YWx1ZXMoX3ByZXBhcmVOZXh0VGFza3Moc2F2ZWQuY2hlY2twb2ludCwgc2F2ZWQucGVuZGluZ1dyaXRlcywgdGhpcy5ub2RlcywgY2hhbm5lbHMsIG1hbmFnZWQsIHNhdmVkLmNvbmZpZywgdHJ1ZSwgeyBzdGVwOiAoc2F2ZWQubWV0YWRhdGE/LnN0ZXAgPz8gLTEpICsgMSwgc3RvcmU6IHRoaXMuc3RvcmUgfSkpO1xuICAgICAgICAvLyBGaW5kIHN1YmdyYXBoc1xuICAgICAgICBjb25zdCBzdWJncmFwaHMgPSBhd2FpdCBnYXRoZXJJdGVyYXRvcih0aGlzLmdldFN1YmdyYXBoc0FzeW5jKCkpO1xuICAgICAgICBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBzYXZlZC5jb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHRhc2tTdGF0ZXMgPSB7fTtcbiAgICAgICAgLy8gUHJlcGFyZSB0YXNrIHN0YXRlcyBmb3Igc3ViZ3JhcGhzXG4gICAgICAgIGZvciAoY29uc3QgdGFzayBvZiBuZXh0VGFza3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nU3ViZ3JhcGggPSBzdWJncmFwaHMuZmluZCgoW25hbWVdKSA9PiBuYW1lID09PSB0YXNrLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGluZ1N1YmdyYXBoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBjaGVja3BvaW50X25zIGZvciB0aGlzIHRhc2tcbiAgICAgICAgICAgIGxldCB0YXNrTnMgPSBgJHtTdHJpbmcodGFzay5uYW1lKX0ke0NIRUNLUE9JTlRfTkFNRVNQQUNFX0VORH0ke3Rhc2suaWR9YDtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0YXNrTnMgPSBgJHtwYXJlbnROYW1lc3BhY2V9JHtDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1J9JHt0YXNrTnN9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJncmFwaENoZWNrcG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGNvbmZpZyBhcyBzaWduYWwgdGhhdCBzdWJncmFwaCBjaGVja3BvaW50cyBleGlzdFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHNhdmVkLmNvbmZpZy5jb25maWd1cmFibGU/LnRocmVhZF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IHRhc2tOcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRhc2tTdGF0ZXNbdGFzay5pZF0gPSBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXRlIG9mIHRoZSBzdWJncmFwaFxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmdyYXBoQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IHN1YmdyYXBoQ2hlY2twb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBzYXZlZC5jb25maWcuY29uZmlndXJhYmxlPy50aHJlYWRfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiB0YXNrTnMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVnZWwgPSBtYXRjaGluZ1N1YmdyYXBoWzFdO1xuICAgICAgICAgICAgICAgIHRhc2tTdGF0ZXNbdGFzay5pZF0gPSBhd2FpdCBwcmVnZWwuZ2V0U3RhdGUoc3ViZ3JhcGhDb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGhzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IHBlbmRpbmcgd3JpdGVzIHRvIHRhc2tzIGFuZCB0aGVuIHRvIGNoYW5uZWxzIGlmIGFwcGx5UGVuZGluZ1dyaXRlcyBpcyB0cnVlXG4gICAgICAgIGlmIChhcHBseVBlbmRpbmdXcml0ZXMgJiYgc2F2ZWQucGVuZGluZ1dyaXRlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBNYXAgdGFzayBJRHMgdG8gdGFzayBvYmplY3RzIGZvciBlYXN5IGxvb2t1cFxuICAgICAgICAgICAgY29uc3QgbmV4dFRhc2tCeUlkID0gT2JqZWN0LmZyb21FbnRyaWVzKG5leHRUYXNrcy5tYXAoKHRhc2spID0+IFt0YXNrLmlkLCB0YXNrXSkpO1xuICAgICAgICAgICAgLy8gQXBwbHkgcGVuZGluZyB3cml0ZXMgdG8gdGhlIGFwcHJvcHJpYXRlIHRhc2tzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YXNrSWQsIGNoYW5uZWwsIHZhbHVlXSBvZiBzYXZlZC5wZW5kaW5nV3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBzcGVjaWFsIGNoYW5uZWxzIGFuZCB0YXNrcyBub3QgaW4gbmV4dFRhc2tzXG4gICAgICAgICAgICAgICAgaWYgKFtFUlJPUiwgSU5URVJSVVBULCBTQ0hFRFVMRURdLmluY2x1ZGVzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISh0YXNrSWQgaW4gbmV4dFRhc2tCeUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB3cml0ZSB0byB0aGUgdGFza1xuICAgICAgICAgICAgICAgIG5leHRUYXNrQnlJZFt0YXNrSWRdLndyaXRlcy5wdXNoKFtTdHJpbmcoY2hhbm5lbCksIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBseSB3cml0ZXMgZnJvbSB0YXNrcyB0aGF0IGhhdmUgd3JpdGVzXG4gICAgICAgICAgICBjb25zdCB0YXNrc1dpdGhXcml0ZXMgPSBuZXh0VGFza3MuZmlsdGVyKCh0YXNrKSA9PiB0YXNrLndyaXRlcy5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGlmICh0YXNrc1dpdGhXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF9hcHBseVdyaXRlcyhzYXZlZC5jaGVja3BvaW50LCBjaGFubmVscywgdGFza3NXaXRoV3JpdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aHJlYWRfaWQgZnJvbSB0aGUgY29uZmlnIGluIG1ldGFkYXRhXG4gICAgICAgIGxldCBtZXRhZGF0YSA9IHNhdmVkPy5tZXRhZGF0YTtcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIHNhdmVkPy5jb25maWc/LmNvbmZpZ3VyYWJsZT8udGhyZWFkX2lkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHNhdmVkLmNvbmZpZy5jb25maWd1cmFibGUudGhyZWFkX2lkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXIgbmV4dCB0YXNrcyAtIG9ubHkgaW5jbHVkZSB0YXNrcyB3aXRob3V0IHdyaXRlc1xuICAgICAgICBjb25zdCBuZXh0TGlzdCA9IG5leHRUYXNrc1xuICAgICAgICAgICAgLmZpbHRlcigodGFzaykgPT4gdGFzay53cml0ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgLm1hcCgodGFzaykgPT4gdGFzay5uYW1lKTtcbiAgICAgICAgLy8gYXNzZW1ibGUgdGhlIHN0YXRlIHNuYXBzaG90XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHJlYWRDaGFubmVscyhjaGFubmVscywgdGhpcy5zdHJlYW1DaGFubmVsc0FzSXMpLFxuICAgICAgICAgICAgbmV4dDogbmV4dExpc3QsXG4gICAgICAgICAgICB0YXNrczogdGFza3NXaXRoV3JpdGVzKG5leHRUYXNrcywgc2F2ZWQ/LnBlbmRpbmdXcml0ZXMgPz8gW10sIHRhc2tTdGF0ZXMpLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBjb25maWc6IHBhdGNoQ2hlY2twb2ludE1hcChzYXZlZC5jb25maWcsIHNhdmVkLm1ldGFkYXRhKSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogc2F2ZWQuY2hlY2twb2ludC50cyxcbiAgICAgICAgICAgIHBhcmVudENvbmZpZzogc2F2ZWQucGFyZW50Q29uZmlnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBncmFwaC5cbiAgICAgKiBSZXF1aXJlcyBhIGNoZWNrcG9pbnRlciB0byBiZSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHJldHJpZXZpbmcgdGhlIHN0YXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IGdyYXBoIHN0YXRlXG4gICAgICogQHRocm93cyB7R3JhcGhWYWx1ZUVycm9yfSBJZiBubyBjaGVja3BvaW50ZXIgaXMgY29uZmlndXJlZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlKGNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGVja3BvaW50ZXIgPSBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdID8/IHRoaXMuY2hlY2twb2ludGVyO1xuICAgICAgICBpZiAoIWNoZWNrcG9pbnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsdWVFcnJvcihcIk5vIGNoZWNrcG9pbnRlciBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgPz8gXCJcIjtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnROYW1lc3BhY2UgIT09IFwiXCIgJiZcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRhc2tfaWRzIGZyb20gY2hlY2twb2ludF9uc1xuICAgICAgICAgICAgY29uc3QgcmVjYXN0TmFtZXNwYWNlID0gcmVjYXN0Q2hlY2twb2ludE5hbWVzcGFjZShjaGVja3BvaW50TmFtZXNwYWNlKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgW25hbWUsIHN1YmdyYXBoXSBvZiB0aGlzLmdldFN1YmdyYXBoc0FzeW5jKHJlY2FzdE5hbWVzcGFjZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gcmVjYXN0TmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdWJncmFwaC5nZXRTdGF0ZShwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgfSksIHsgc3ViZ3JhcGhzOiBvcHRpb25zPy5zdWJncmFwaHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJncmFwaCB3aXRoIG5hbWVzcGFjZSBcIiR7cmVjYXN0TmFtZXNwYWNlfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHNhdmVkID0gYXdhaXQgY2hlY2twb2ludGVyLmdldFR1cGxlKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgdGhpcy5fcHJlcGFyZVN0YXRlU25hcHNob3Qoe1xuICAgICAgICAgICAgY29uZmlnOiBtZXJnZWRDb25maWcsXG4gICAgICAgICAgICBzYXZlZCxcbiAgICAgICAgICAgIHN1YmdyYXBoQ2hlY2twb2ludGVyOiBvcHRpb25zPy5zdWJncmFwaHMgPyBjaGVja3BvaW50ZXIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcHBseVBlbmRpbmdXcml0ZXM6ICFjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X2lkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoaXN0b3J5IG9mIGdyYXBoIHN0YXRlcy5cbiAgICAgKiBSZXF1aXJlcyBhIGNoZWNrcG9pbnRlciB0byBiZSBjb25maWd1cmVkLlxuICAgICAqIFVzZWZ1bCBmb3I6XG4gICAgICogLSBEZWJ1Z2dpbmcgZXhlY3V0aW9uIGhpc3RvcnlcbiAgICAgKiAtIEltcGxlbWVudGluZyB0aW1lIHRyYXZlbFxuICAgICAqIC0gQW5hbHl6aW5nIGdyYXBoIGJlaGF2aW9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgaGlzdG9yeVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZmlsdGVyaW5nIHRoZSBoaXN0b3J5XG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgaXRlcmF0b3Igb2Ygc3RhdGUgc25hcHNob3RzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIG5vIGNoZWNrcG9pbnRlciBpcyBjb25maWd1cmVkXG4gICAgICovXG4gICAgYXN5bmMgKmdldFN0YXRlSGlzdG9yeShjb25maWcsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludGVyID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSA/PyB0aGlzLmNoZWNrcG9pbnRlcjtcbiAgICAgICAgaWYgKCFjaGVja3BvaW50ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoZWNrcG9pbnRlciBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgPz8gXCJcIjtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnROYW1lc3BhY2UgIT09IFwiXCIgJiZcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVjYXN0TmFtZXNwYWNlID0gcmVjYXN0Q2hlY2twb2ludE5hbWVzcGFjZShjaGVja3BvaW50TmFtZXNwYWNlKTtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHN1YmdyYXBoIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgW25hbWUsIHByZWdlbF0gb2YgdGhpcy5nZXRTdWJncmFwaHNBc3luYyhyZWNhc3ROYW1lc3BhY2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IHJlY2FzdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogcHJlZ2VsLmdldFN0YXRlSGlzdG9yeShwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgICAgfSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJncmFwaCB3aXRoIG5hbWVzcGFjZSBcIiR7cmVjYXN0TmFtZXNwYWNlfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIGNvbmZpZywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7IGNoZWNrcG9pbnRfbnM6IGNoZWNrcG9pbnROYW1lc3BhY2UgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2hlY2twb2ludFR1cGxlIG9mIGNoZWNrcG9pbnRlci5saXN0KG1lcmdlZENvbmZpZywgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3ByZXBhcmVTdGF0ZVNuYXBzaG90KHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGNoZWNrcG9pbnRUdXBsZS5jb25maWcsXG4gICAgICAgICAgICAgICAgc2F2ZWQ6IGNoZWNrcG9pbnRUdXBsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHVwZGF0ZXMgdG8gdGhlIGdyYXBoIHN0YXRlIGluIGJ1bGsuXG4gICAgICogUmVxdWlyZXMgYSBjaGVja3BvaW50ZXIgdG8gYmUgY29uZmlndXJlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgcmVjcmVhdGluZyBhIHRocmVhZFxuICAgICAqIGZyb20gYSBsaXN0IG9mIHVwZGF0ZXMsIGVzcGVjaWFsbHkgaWYgYSBjaGVja3BvaW50XG4gICAgICogaXMgY3JlYXRlZCBhcyBhIHJlc3VsdCBvZiBtdWx0aXBsZSB0YXNrcy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbCBUaGUgQVBJIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0Q29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB1cGRhdGVzIC0gVGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBhcHBseSB0byBncmFwaCBzdGF0ZVxuICAgICAqIEByZXR1cm5zIFVwZGF0ZWQgY29uZmlndXJhdGlvblxuICAgICAqIEB0aHJvd3Mge0dyYXBoVmFsdWVFcnJvcn0gSWYgbm8gY2hlY2twb2ludGVyIGlzIGNvbmZpZ3VyZWRcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkVXBkYXRlRXJyb3J9IElmIHRoZSB1cGRhdGUgY2Fubm90IGJlIGF0dHJpYnV0ZWQgdG8gYSBub2RlIG9yIGFuIHVwZGF0ZSBjYW4gYmUgb25seSBhcHBsaWVkIGluIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1bGtVcGRhdGVTdGF0ZShzdGFydENvbmZpZywgc3VwZXJzdGVwcykge1xuICAgICAgICBjb25zdCBjaGVja3BvaW50ZXIgPSBzdGFydENvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl0gPz8gdGhpcy5jaGVja3BvaW50ZXI7XG4gICAgICAgIGlmICghY2hlY2twb2ludGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWx1ZUVycm9yKFwiTm8gY2hlY2twb2ludGVyIHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwZXJzdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1cGVyc3RlcHMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cGVyc3RlcHMuc29tZSgocykgPT4gcy51cGRhdGVzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVwZGF0ZXMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVsZWdhdGUgdG8gc3ViZ3JhcGhcbiAgICAgICAgY29uc3QgY2hlY2twb2ludE5hbWVzcGFjZSA9IHN0YXJ0Q29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiO1xuICAgICAgICBpZiAoY2hlY2twb2ludE5hbWVzcGFjZSAhPT0gXCJcIiAmJlxuICAgICAgICAgICAgc3RhcnRDb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5URVJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0YXNrX2lkcyBmcm9tIGNoZWNrcG9pbnRfbnNcbiAgICAgICAgICAgIGNvbnN0IHJlY2FzdE5hbWVzcGFjZSA9IHJlY2FzdENoZWNrcG9pbnROYW1lc3BhY2UoY2hlY2twb2ludE5hbWVzcGFjZSk7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBzdWJncmFwaCB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGUtbG9vcFxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbLCBwcmVnZWxdIG9mIHRoaXMuZ2V0U3ViZ3JhcGhzQXN5bmMocmVjYXN0TmFtZXNwYWNlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcmVnZWwuYnVsa1VwZGF0ZVN0YXRlKHBhdGNoQ29uZmlndXJhYmxlKHN0YXJ0Q29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl06IGNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgICAgICB9KSwgc3VwZXJzdGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YmdyYXBoIFwiJHtyZWNhc3ROYW1lc3BhY2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlU3VwZXJTdGVwID0gYXN5bmMgKGlucHV0Q29uZmlnLCB1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgbGFzdCBjaGVja3BvaW50XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ1xuICAgICAgICAgICAgICAgID8gbWVyZ2VDb25maWdzKHRoaXMuY29uZmlnLCBpbnB1dENvbmZpZylcbiAgICAgICAgICAgICAgICA6IGlucHV0Q29uZmlnO1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWQgPSBhd2FpdCBjaGVja3BvaW50ZXIuZ2V0VHVwbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBzYXZlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb3B5Q2hlY2twb2ludChzYXZlZC5jaGVja3BvaW50KVxuICAgICAgICAgICAgICAgIDogZW1wdHlDaGVja3BvaW50KCk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zYXZlZD8uY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzYXZlZD8ubWV0YWRhdGE/LnN0ZXAgPz8gLTE7XG4gICAgICAgICAgICAvLyBtZXJnZSBjb25maWd1cmFibGUgZmllbGRzIHdpdGggcHJldmlvdXMgY2hlY2twb2ludCBjb25maWdcbiAgICAgICAgICAgIGxldCBjaGVja3BvaW50Q29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgY2hlY2twb2ludE1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhID8/IHt9O1xuICAgICAgICAgICAgaWYgKHNhdmVkPy5jb25maWcuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludENvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywgc2F2ZWQuY29uZmlnLmNvbmZpZ3VyYWJsZSk7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zYXZlZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hlY2twb2ludE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIGxhc3Qgbm9kZSB0aGF0IHVwZGF0ZWQgdGhlIHN0YXRlLCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWVzLCBhc05vZGUgfSA9IHVwZGF0ZXNbMF07XG4gICAgICAgICAgICBpZiAodmFsdWVzID09IG51bGwgJiYgYXNOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYENhbm5vdCBjcmVhdGUgZW1wdHkgY2hlY2twb2ludCB3aXRoIG11bHRpcGxlIHVwZGF0ZXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENvbmZpZyA9IGF3YWl0IGNoZWNrcG9pbnRlci5wdXQoY2hlY2twb2ludENvbmZpZywgY3JlYXRlQ2hlY2twb2ludChjaGVja3BvaW50LCB1bmRlZmluZWQsIHN0ZXApLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHM6IHNhdmVkPy5tZXRhZGF0YT8ucGFyZW50cyA/PyB7fSxcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoQ2hlY2twb2ludE1hcChuZXh0Q29uZmlnLCBzYXZlZCA/IHNhdmVkLm1ldGFkYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjaGFubmVsc1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBlbXB0eUNoYW5uZWxzKHRoaXMuY2hhbm5lbHMsIGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgLy8gUGFzcyBgc2tpcE1hbmFnZWQ6IHRydWVgIGFzIG1hbmFnZWQgdmFsdWVzIGFyZSBub3QgdXNlZC9yZWxldmFudCBpbiB1cGRhdGUgc3RhdGUgY2FsbHMuXG4gICAgICAgICAgICBjb25zdCB7IG1hbmFnZWQgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNwZWNzKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIHNraXBNYW5hZ2VkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzID09PSBudWxsICYmIGFzTm9kZSA9PT0gRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBDYW5ub3QgYXBwbHkgbXVsdGlwbGUgdXBkYXRlcyB3aGVuIGNsZWFyaW5nIHN0YXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0YXNrcyBmb3IgdGhpcyBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXNrcyA9IF9wcmVwYXJlTmV4dFRhc2tzKGNoZWNrcG9pbnQsIHNhdmVkLnBlbmRpbmdXcml0ZXMgfHwgW10sIHRoaXMubm9kZXMsIGNoYW5uZWxzLCBtYW5hZ2VkLCBzYXZlZC5jb25maWcsIHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IChzYXZlZC5tZXRhZGF0YT8uc3RlcCA/PyAtMSkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludGVyOiB0aGlzLmNoZWNrcG9pbnRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IG51bGwgd3JpdGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bGxXcml0ZXMgPSAoc2F2ZWQucGVuZGluZ1dyaXRlcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHcpID0+IHdbMF0gPT09IE5VTExfVEFTS19JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHcpID0+IHcuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoc2F2ZWQuY2hlY2twb2ludCwgY2hhbm5lbHMsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IElOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IG51bGxXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgd3JpdGVzIGZyb20gdGFza3MgdGhhdCBhbHJlYWR5IHJhblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt0YXNrSWQsIGssIHZdIG9mIHNhdmVkLnBlbmRpbmdXcml0ZXMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbRVJST1IsIElOVEVSUlVQVCwgU0NIRURVTEVEXS5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGFza0lkIGluIG5leHRUYXNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUYXNrc1t0YXNrSWRdLndyaXRlcy5wdXNoKFtrLCB2XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGN1cnJlbnQgdGFza3NcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5V3JpdGVzKGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBPYmplY3QudmFsdWVzKG5leHRUYXNrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzYXZlIGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29uZmlnID0gYXdhaXQgY2hlY2twb2ludGVyLnB1dChjaGVja3BvaW50Q29uZmlnLCBjcmVhdGVDaGVja3BvaW50KGNoZWNrcG9pbnQsIHVuZGVmaW5lZCwgc3RlcCksIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hlY2twb2ludE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBzYXZlZD8ubWV0YWRhdGE/LnBhcmVudHMgPz8ge30sXG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaENoZWNrcG9pbnRNYXAobmV4dENvbmZpZywgc2F2ZWQgPyBzYXZlZC5tZXRhZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzID09IG51bGwgJiYgYXNOb2RlID09PSBDT1BZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBDYW5ub3QgY29weSBjaGVja3BvaW50IHdpdGggbXVsdGlwbGUgdXBkYXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29uZmlnID0gYXdhaXQgY2hlY2twb2ludGVyLnB1dChzYXZlZD8ucGFyZW50Q29uZmlnID8/IGNoZWNrcG9pbnRDb25maWcsIGNyZWF0ZUNoZWNrcG9pbnQoY2hlY2twb2ludCwgdW5kZWZpbmVkLCBzdGVwKSwge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZm9ya1wiLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBzdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50czogc2F2ZWQ/Lm1ldGFkYXRhPy5wYXJlbnRzID8/IHt9LFxuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hDaGVja3BvaW50TWFwKG5leHRDb25maWcsIHNhdmVkID8gc2F2ZWQubWV0YWRhdGEgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzTm9kZSA9PT0gSU5QVVQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoYENhbm5vdCBhcHBseSBtdWx0aXBsZSB1cGRhdGVzIHdoZW4gdXBkYXRpbmcgYXMgaW5wdXRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRXcml0ZXMgPSBhd2FpdCBnYXRoZXJJdGVyYXRvcihtYXBJbnB1dCh0aGlzLmlucHV0Q2hhbm5lbHMsIHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFdyaXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcGRhdGVFcnJvcihgUmVjZWl2ZWQgbm8gaW5wdXQgd3JpdGVzIGZvciAke0pTT04uc3RyaW5naWZ5KHRoaXMuaW5wdXRDaGFubmVscywgbnVsbCwgMil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRvIGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICBfYXBwbHlXcml0ZXMoY2hlY2twb2ludCwgY2hhbm5lbHMsIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IGlucHV0V3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sIGNoZWNrcG9pbnRlci5nZXROZXh0VmVyc2lvbi5iaW5kKHRoaXMuY2hlY2twb2ludGVyKSk7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgaW5wdXQgd3JpdGUgdG8gY2hhbm5lbHNcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3RlcCA9IHNhdmVkPy5tZXRhZGF0YT8uc3RlcCAhPSBudWxsID8gc2F2ZWQubWV0YWRhdGEuc3RlcCArIDEgOiAtMTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29uZmlnID0gYXdhaXQgY2hlY2twb2ludGVyLnB1dChjaGVja3BvaW50Q29uZmlnLCBjcmVhdGVDaGVja3BvaW50KGNoZWNrcG9pbnQsIGNoYW5uZWxzLCBuZXh0U3RlcCksIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IG5leHRTdGVwLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dFdyaXRlcyksXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHM6IHNhdmVkPy5tZXRhZGF0YT8ucGFyZW50cyA/PyB7fSxcbiAgICAgICAgICAgICAgICB9LCBnZXROZXdDaGFubmVsVmVyc2lvbnMoY2hlY2twb2ludFByZXZpb3VzVmVyc2lvbnMsIGNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykpO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB3cml0ZXNcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGVja3BvaW50ZXIucHV0V3JpdGVzKG5leHRDb25maWcsIGlucHV0V3JpdGVzLCB1dWlkNShJTlBVVCwgY2hlY2twb2ludC5pZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaENoZWNrcG9pbnRNYXAobmV4dENvbmZpZywgc2F2ZWQgPyBzYXZlZC5tZXRhZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBseSBwZW5kaW5nIHdyaXRlcywgaWYgbm90IG9uIHNwZWNpZmljIGNoZWNrcG9pbnRcbiAgICAgICAgICAgIGlmIChjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X2lkID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzYXZlZD8ucGVuZGluZ1dyaXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2F2ZWQucGVuZGluZ1dyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGFza3MgZm9yIHRoaXMgY2hlY2twb2ludFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXNrcyA9IF9wcmVwYXJlTmV4dFRhc2tzKGNoZWNrcG9pbnQsIHNhdmVkLnBlbmRpbmdXcml0ZXMsIHRoaXMubm9kZXMsIGNoYW5uZWxzLCBtYW5hZ2VkLCBzYXZlZC5jb25maWcsIHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRlcjogdGhpcy5jaGVja3BvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IChzYXZlZC5tZXRhZGF0YT8uc3RlcCA/PyAtMSkgKyAxLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGFwcGx5IG51bGwgd3JpdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgbnVsbFdyaXRlcyA9IChzYXZlZC5wZW5kaW5nV3JpdGVzID8/IFtdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh3KSA9PiB3WzBdID09PSBOVUxMX1RBU0tfSUQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHcpID0+IHcuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIGlmIChudWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5V3JpdGVzKHNhdmVkLmNoZWNrcG9pbnQsIGNoYW5uZWxzLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiBudWxsV3JpdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBseSB3cml0ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt0aWQsIGssIHZdIG9mIHNhdmVkLnBlbmRpbmdXcml0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFtFUlJPUiwgSU5URVJSVVBULCBTQ0hFRFVMRURdLmluY2x1ZGVzKGspIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGFza3NbdGlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0VGFza3NbdGlkXS53cml0ZXMucHVzaChbaywgdl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrcyA9IE9iamVjdC52YWx1ZXMobmV4dFRhc2tzKS5maWx0ZXIoKHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2sud3JpdGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5V3JpdGVzKGNoZWNrcG9pbnQsIGNoYW5uZWxzLCB0YXNrcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9uTnVsbFZlcnNpb24gPSBPYmplY3QudmFsdWVzKGNoZWNrcG9pbnQudmVyc2lvbnNfc2VlbilcbiAgICAgICAgICAgICAgICAubWFwKChzZWVuVmVyc2lvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzZWVuVmVyc2lvbnMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmxhdCgpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHYpID0+ICEhdik7XG4gICAgICAgICAgICBjb25zdCB2YWxpZFVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZXMsIGFzTm9kZSB9ID0gdXBkYXRlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXNOb2RlID09PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXModGhpcy5ub2RlcykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9ubHkgb25lIG5vZGUsIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICBbYXNOb2RlXSA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhc05vZGUgPT09IHVuZGVmaW5lZCAmJiBub25OdWxsVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dENoYW5uZWxzID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW3RoaXMuaW5wdXRDaGFubmVsc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNOb2RlID0gdGhpcy5pbnB1dENoYW5uZWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFzTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQnlOb2RlID0gT2JqZWN0LmVudHJpZXMoY2hlY2twb2ludC52ZXJzaW9uc19zZWVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoW24sIHNlZW5dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzZWVuKS5tYXAoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3YsIG5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoW2FOdW1iZXJdLCBbYk51bWJlcl0pID0+IGNvbXBhcmVDaGFubmVsVmVyc2lvbnMoYU51bWJlciwgYk51bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0d28gbm9kZXMgdXBkYXRlZCB0aGUgc3RhdGUgYXQgdGhlIHNhbWUgdGltZSwgaXQncyBhbWJpZ3VvdXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTZWVuQnlOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNlZW5CeU5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb2RlID0gbGFzdFNlZW5CeU5vZGVbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0U2VlbkJ5Tm9kZVtsYXN0U2VlbkJ5Tm9kZS5sZW5ndGggLSAxXVswXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VlbkJ5Tm9kZVtsYXN0U2VlbkJ5Tm9kZS5sZW5ndGggLSAyXVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9kZSA9IGxhc3RTZWVuQnlOb2RlW2xhc3RTZWVuQnlOb2RlLmxlbmd0aCAtIDFdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhc05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBBbWJpZ3VvdXMgdXBkYXRlLCBzcGVjaWZ5IFwiYXNOb2RlXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsaWRVcGRhdGVzLnB1c2goeyB2YWx1ZXMsIGFzTm9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBhc05vZGUsIHZhbHVlcyB9IG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBcImFzTm9kZVwiIGlzIHJlcXVpcmVkIHdoZW4gYXBwbHlpbmcgbXVsdGlwbGUgdXBkYXRlc2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkVXBkYXRlcy5wdXNoKHsgdmFsdWVzLCBhc05vZGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFza3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBhc05vZGUsIHZhbHVlcyB9IG9mIHZhbGlkVXBkYXRlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2FzTm9kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBOb2RlIFwiJHthc05vZGUudG9TdHJpbmcoKX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBydW4gYWxsIHdyaXRlcnMgb2YgdGhlIGNob3NlbiBub2RlXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVycyA9IHRoaXMubm9kZXNbYXNOb2RlXS5nZXRXcml0ZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKGBObyB3cml0ZXJzIGZvdW5kIGZvciBub2RlIFwiJHthc05vZGUudG9TdHJpbmcoKX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYXNOb2RlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICBwcm9jOiB3cml0ZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSdW5uYWJsZVNlcXVlbmNlLmZyb20od3JpdGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbWl0U2VxdWVuY2VUYWdzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdyaXRlcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlczogW10sXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbSU5URVJSVVBUXSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHV1aWQ1KElOVEVSUlVQVCwgY2hlY2twb2ludC5pZCksXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlcnM6IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSB0YXNrXG4gICAgICAgICAgICAgICAgYXdhaXQgdGFzay5wcm9jLmludm9rZSh0YXNrLmlucHV0LCBwYXRjaENvbmZpZyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGNvbmZpZz8uc3RvcmUgPz8gdGhpcy5zdG9yZSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bk5hbWU6IGNvbmZpZy5ydW5OYW1lID8/IGAke3RoaXMuZ2V0TmFtZSgpfVVwZGF0ZVN0YXRlYCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbQ09ORklHX0tFWV9TRU5EXTogKGl0ZW1zKSA9PiB0YXNrLndyaXRlcy5wdXNoKC4uLml0ZW1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1JFQURdOiAoc2VsZWN0XywgZnJlc2hfID0gZmFsc2UpID0+IF9sb2NhbFJlYWQoc3RlcCwgY2hlY2twb2ludCwgY2hhbm5lbHMsIG1hbmFnZWQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2h5IGRvZXMga2V5b2YgU3RyUmVjb3JkIGFsbG93IG51bWJlciBhbmQgc3ltYm9sP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzaywgc2VsZWN0XywgZnJlc2hfKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVsIHdyaXRlcyBhcmUgc2F2ZWQgdG8gY3VycmVudCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbFdyaXRlcyA9IHRhc2sud3JpdGVzLmZpbHRlcigodykgPT4gd1swXSAhPT0gUFVTSCk7XG4gICAgICAgICAgICAgICAgLy8gc2F2ZSB0YXNrIHdyaXRlc1xuICAgICAgICAgICAgICAgIGlmIChzYXZlZCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWxXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja3BvaW50ZXIucHV0V3JpdGVzKGNoZWNrcG9pbnRDb25maWcsIGNoYW5uZWxXcml0ZXMsIHRhc2suaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IHRvIGNoZWNrcG9pbnRcbiAgICAgICAgICAgIC8vIFRPRE86IFdoeSBkb2VzIGtleW9mIFN0clJlY29yZCBhbGxvdyBudW1iZXIgYW5kIHN5bWJvbD9cbiAgICAgICAgICAgIF9hcHBseVdyaXRlcyhjaGVja3BvaW50LCBjaGFubmVscywgdGFza3MsIGNoZWNrcG9pbnRlci5nZXROZXh0VmVyc2lvbi5iaW5kKHRoaXMuY2hlY2twb2ludGVyKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdWZXJzaW9ucyA9IGdldE5ld0NoYW5uZWxWZXJzaW9ucyhjaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucywgY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDb25maWcgPSBhd2FpdCBjaGVja3BvaW50ZXIucHV0KGNoZWNrcG9pbnRDb25maWcsIGNyZWF0ZUNoZWNrcG9pbnQoY2hlY2twb2ludCwgY2hhbm5lbHMsIHN0ZXAgKyAxKSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICBzdGVwOiBzdGVwICsgMSxcbiAgICAgICAgICAgICAgICB3cml0ZXM6IE9iamVjdC5mcm9tRW50cmllcyh2YWxpZFVwZGF0ZXMubWFwKCh1cGRhdGUpID0+IFt1cGRhdGUuYXNOb2RlLCB1cGRhdGUudmFsdWVzXSkpLFxuICAgICAgICAgICAgICAgIHBhcmVudHM6IHNhdmVkPy5tZXRhZGF0YT8ucGFyZW50cyA/PyB7fSxcbiAgICAgICAgICAgIH0sIG5ld1ZlcnNpb25zKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggd3JpdGVzIGFyZSBzYXZlZCB0byBuZXh0IGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoV3JpdGVzID0gdGFzay53cml0ZXMuZmlsdGVyKCh3KSA9PiB3WzBdID09PSBQVVNIKTtcbiAgICAgICAgICAgICAgICBpZiAocHVzaFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrcG9pbnRlci5wdXRXcml0ZXMobmV4dENvbmZpZywgcHVzaFdyaXRlcywgdGFzay5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGNoQ2hlY2twb2ludE1hcChuZXh0Q29uZmlnLCBzYXZlZCA/IHNhdmVkLm1ldGFkYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWcgPSBzdGFydENvbmZpZztcbiAgICAgICAgZm9yIChjb25zdCB7IHVwZGF0ZXMgfSBvZiBzdXBlcnN0ZXBzKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29uZmlnID0gYXdhaXQgdXBkYXRlU3VwZXJTdGVwKGN1cnJlbnRDb25maWcsIHVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgZ3JhcGggd2l0aCBuZXcgdmFsdWVzLlxuICAgICAqIFJlcXVpcmVzIGEgY2hlY2twb2ludGVyIHRvIGJlIGNvbmZpZ3VyZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3I6XG4gICAgICogLSBJbXBsZW1lbnRpbmcgaHVtYW4taW4tdGhlLWxvb3Agd29ya2Zsb3dzXG4gICAgICogLSBNb2RpZnlpbmcgZ3JhcGggc3RhdGUgZHVyaW5nIGJyZWFrcG9pbnRzXG4gICAgICogLSBJbnRlZ3JhdGluZyBleHRlcm5hbCBpbnB1dHMgaW50byB0aGUgZ3JhcGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dENvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSB1cGRhdGVcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgdGhlIHN0YXRlIHdpdGhcbiAgICAgKiBAcGFyYW0gYXNOb2RlIC0gT3B0aW9uYWwgbm9kZSBuYW1lIHRvIGF0dHJpYnV0ZSB0aGUgdXBkYXRlIHRvXG4gICAgICogQHJldHVybnMgVXBkYXRlZCBjb25maWd1cmF0aW9uXG4gICAgICogQHRocm93cyB7R3JhcGhWYWx1ZUVycm9yfSBJZiBubyBjaGVja3BvaW50ZXIgaXMgY29uZmlndXJlZFxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRVcGRhdGVFcnJvcn0gSWYgdGhlIHVwZGF0ZSBjYW5ub3QgYmUgYXR0cmlidXRlZCB0byBhIG5vZGVcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTdGF0ZShpbnB1dENvbmZpZywgdmFsdWVzLCBhc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVsa1VwZGF0ZVN0YXRlKGlucHV0Q29uZmlnLCBbXG4gICAgICAgICAgICB7IHVwZGF0ZXM6IFt7IHZhbHVlcywgYXNOb2RlIH1dIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdmFyaW91cyBncmFwaCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QgdXNlZCB0byBwcm9jZXNzIGFuZCBub3JtYWxpemUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBpbnB1dCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgbm9ybWFsaXplZCB2YWx1ZXMgZm9yOlxuICAgICAqIC0gZGVidWcgbW9kZVxuICAgICAqIC0gc3RyZWFtIG1vZGVzXG4gICAgICogLSBpbnB1dCBrZXlzXG4gICAgICogLSBvdXRwdXQga2V5c1xuICAgICAqIC0gcmVtYWluaW5nIGNvbmZpZ1xuICAgICAqIC0gaW50ZXJydXB0IGJlZm9yZSBub2Rlc1xuICAgICAqIC0gaW50ZXJydXB0IGFmdGVyIG5vZGVzXG4gICAgICogLSBjaGVja3BvaW50ZXJcbiAgICAgKiAtIHN0b3JlXG4gICAgICogLSB3aGV0aGVyIHN0cmVhbSBtb2RlIGlzIHNpbmdsZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9kZWZhdWx0cyhjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBkZWJ1Zywgc3RyZWFtTW9kZSwgaW5wdXRLZXlzLCBvdXRwdXRLZXlzLCBpbnRlcnJ1cHRBZnRlciwgaW50ZXJydXB0QmVmb3JlLCAuLi5yZXN0IH0gPSBjb25maWc7XG4gICAgICAgIGxldCBzdHJlYW1Nb2RlU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZGVmYXVsdERlYnVnID0gZGVidWcgIT09IHVuZGVmaW5lZCA/IGRlYnVnIDogdGhpcy5kZWJ1ZztcbiAgICAgICAgbGV0IGRlZmF1bHRPdXRwdXRLZXlzID0gb3V0cHV0S2V5cztcbiAgICAgICAgaWYgKGRlZmF1bHRPdXRwdXRLZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRPdXRwdXRLZXlzID0gdGhpcy5zdHJlYW1DaGFubmVsc0FzSXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUtleXMoZGVmYXVsdE91dHB1dEtleXMsIHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0SW5wdXRLZXlzID0gaW5wdXRLZXlzO1xuICAgICAgICBpZiAoZGVmYXVsdElucHV0S2V5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0SW5wdXRLZXlzID0gdGhpcy5pbnB1dENoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGVLZXlzKGRlZmF1bHRJbnB1dEtleXMsIHRoaXMuY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRJbnRlcnJ1cHRCZWZvcmUgPSBpbnRlcnJ1cHRCZWZvcmUgPz8gdGhpcy5pbnRlcnJ1cHRCZWZvcmUgPz8gW107XG4gICAgICAgIGNvbnN0IGRlZmF1bHRJbnRlcnJ1cHRBZnRlciA9IGludGVycnVwdEFmdGVyID8/IHRoaXMuaW50ZXJydXB0QWZ0ZXIgPz8gW107XG4gICAgICAgIGxldCBkZWZhdWx0U3RyZWFtTW9kZTtcbiAgICAgICAgaWYgKHN0cmVhbU1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmYXVsdFN0cmVhbU1vZGUgPSBBcnJheS5pc0FycmF5KHN0cmVhbU1vZGUpID8gc3RyZWFtTW9kZSA6IFtzdHJlYW1Nb2RlXTtcbiAgICAgICAgICAgIHN0cmVhbU1vZGVTaW5nbGUgPSB0eXBlb2Ygc3RyZWFtTW9kZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRTdHJlYW1Nb2RlID0gdGhpcy5zdHJlYW1Nb2RlO1xuICAgICAgICAgICAgc3RyZWFtTW9kZVNpbmdsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYmVpbmcgY2FsbGVkIGFzIGEgbm9kZSBpbiBhbm90aGVyIGdyYXBoLCBhbHdheXMgdXNlIHZhbHVlcyBtb2RlXG4gICAgICAgIGlmIChjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9UQVNLX0lEXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0U3RyZWFtTW9kZSA9IFtcInZhbHVlc1wiXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdENoZWNrcG9pbnRlcjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVmYXVsdENoZWNrcG9pbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVEVSXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2twb2ludGVyID0gY29uZmlnLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX0NIRUNLUE9JTlRFUl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2twb2ludGVyID0gdGhpcy5jaGVja3BvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdFN0b3JlID0gY29uZmlnLnN0b3JlID8/IHRoaXMuc3RvcmU7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkZWZhdWx0RGVidWcsXG4gICAgICAgICAgICBkZWZhdWx0U3RyZWFtTW9kZSxcbiAgICAgICAgICAgIGRlZmF1bHRJbnB1dEtleXMsXG4gICAgICAgICAgICBkZWZhdWx0T3V0cHV0S2V5cyxcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgICAgICBkZWZhdWx0SW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgZGVmYXVsdEludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrcG9pbnRlcixcbiAgICAgICAgICAgIGRlZmF1bHRTdG9yZSxcbiAgICAgICAgICAgIHN0cmVhbU1vZGVTaW5nbGUsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgZ3JhcGgsIGVtaXR0aW5nIHN0YXRlIHVwZGF0ZXMgYXMgdGhleSBvY2N1ci5cbiAgICAgKiBUaGlzIGlzIHRoZSBwcmltYXJ5IG1ldGhvZCBmb3Igb2JzZXJ2aW5nIGdyYXBoIGV4ZWN1dGlvbiBpbiByZWFsLXRpbWUuXG4gICAgICpcbiAgICAgKiBTdHJlYW0gbW9kZXM6XG4gICAgICogLSBcInZhbHVlc1wiOiBFbWl0cyBjb21wbGV0ZSBzdGF0ZSBhZnRlciBlYWNoIHN0ZXBcbiAgICAgKiAtIFwidXBkYXRlc1wiOiBFbWl0cyBvbmx5IHN0YXRlIGNoYW5nZXMgYWZ0ZXIgZWFjaCBzdGVwXG4gICAgICogLSBcImRlYnVnXCI6IEVtaXRzIGRldGFpbGVkIGRlYnVnIGluZm9ybWF0aW9uXG4gICAgICogLSBcIm1lc3NhZ2VzXCI6IEVtaXRzIG1lc3NhZ2VzIGZyb20gd2l0aGluIG5vZGVzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIFtTdHJlYW1pbmcgaG93LXRvIGd1aWRlc10oLi4vLi4vaG93LXRvcy8jc3RyZWFtaW5nXzEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHRvIHN0YXJ0IGdyYXBoIGV4ZWN1dGlvbiB3aXRoXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHN0cmVhbWluZ1xuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jIGl0ZXJhYmxlIHN0cmVhbSBvZiBncmFwaCBzdGF0ZSB1cGRhdGVzXG4gICAgICovXG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoZSBlbnN1cmVDb25maWcgbWV0aG9kIGNhbGxlZCBpbnRlcm5hbGx5IGRlZmF1bHRzIHJlY3Vyc2lvbkxpbWl0IHRvIDI1IGlmIG5vdFxuICAgICAgICAvLyBwYXNzZWQgZGlyZWN0bHkgaW4gYG9wdGlvbnNgLlxuICAgICAgICAvLyBUaGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IGluIF9zdHJlYW1JdGVyYXRvciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHdhc1xuICAgICAgICAvLyBzZXQgYnkgYnkgZW5zdXJlQ29uZmlnIG9yIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBzbyB3ZSBzcGVjaWZ5IHRoZSBib3VuZCB2YWx1ZSBoZXJlXG4gICAgICAgIC8vIGFuZCBvdmVycmlkZSBpZiBpdCBpcyBwYXNzZWQgYXMgYW4gZXhwbGljaXQgcGFyYW0gaW4gYG9wdGlvbnNgLlxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiB0aGlzLmNvbmZpZz8ucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICAgICAgICAgICAgICA/IGNvbWJpbmVBYm9ydFNpZ25hbHMob3B0aW9ucy5zaWduYWwsIGFib3J0Q29udHJvbGxlci5zaWduYWwpXG4gICAgICAgICAgICAgICAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW1XaXRoQWJvcnRTaWduYWwoYXdhaXQgc3VwZXIuc3RyZWFtKGlucHV0LCBjb25maWcpLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICByZWN1cnNpb25MaW1pdDogdGhpcy5jb25maWc/LnJlY3Vyc2lvbkxpbWl0LFxuICAgICAgICAgICAgLy8gU2ltaWxhciB0byBgc3RyZWFtYCwgd2UgbmVlZCB0byBwYXNzIHRoZSBgY29uZmlnLmNhbGxiYWNrc2AgaGVyZSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB3aWxsIGdldCBsb3N0IGluIGBlbnN1cmVMYW5nR3JhcGhDb25maWdgLlxuICAgICAgICAgICAgY2FsbGJhY2tzOiB0aGlzLmNvbmZpZz8uY2FsbGJhY2tzLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsXG4gICAgICAgICAgICAgICAgPyBjb21iaW5lQWJvcnRTaWduYWxzKG9wdGlvbnMuc2lnbmFsLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKVxuICAgICAgICAgICAgICAgIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtV2l0aEFib3J0U2lnbmFsKHN1cGVyLnN0cmVhbUV2ZW50cyhpbnB1dCwgY29uZmlnLCBzdHJlYW1PcHRpb25zKSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgY2hhbm5lbCBzcGVjaWZpY2F0aW9ucyBhbmQgbWFuYWdlZCB2YWx1ZXMgZm9yIGdyYXBoIGV4ZWN1dGlvbi5cbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCB1c2VkIHRvIHNldCB1cCB0aGUgZ3JhcGgncyBjb21tdW5pY2F0aW9uIGNoYW5uZWxzXG4gICAgICogYW5kIG1hbmFnZWQgc3RhdGUgYmVmb3JlIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIGZvciBwcmVwYXJpbmcgc3BlY3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnNraXBNYW5hZ2VkIC0gV2hldGhlciB0byBza2lwIGluaXRpYWxpemF0aW9uIG9mIG1hbmFnZWQgdmFsdWVzXG4gICAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgY2hhbm5lbCBzcGVjcyBhbmQgbWFuYWdlZCB2YWx1ZSBtYXBwaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZVNwZWNzKGNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdGb3JNYW5hZ2VkID0ge1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYW5uZWxTcGVjcyA9IHt9O1xuICAgICAgICBjb25zdCBtYW5hZ2VkU3BlY3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc3BlY10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jaGFubmVscykpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2VDaGFubmVsKHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbFNwZWNzW25hbWVdID0gc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnM/LnNraXBNYW5hZ2VkKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZFNwZWNzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IE5vb3BNYW5hZ2VkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBjb25maWc6IHt9IH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hbmFnZWRTcGVjc1tuYW1lXSA9IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFuYWdlZCA9IG5ldyBNYW5hZ2VkVmFsdWVNYXBwaW5nKGF3YWl0IE9iamVjdC5lbnRyaWVzKG1hbmFnZWRTcGVjcykucmVkdWNlKGFzeW5jIChhY2NQcm9taXNlLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjYyA9IGF3YWl0IGFjY1Byb21pc2U7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbGl6ZWRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0NvbmZpZ3VyZWRNYW5hZ2VkVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwia2V5XCIgaW4gdmFsdWUucGFyYW1zICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnBhcmFtcy5rZXkgPT09IENoYW5uZWxLZXlQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wYXJhbXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZFZhbHVlID0gYXdhaXQgdmFsdWUuY2xzLmluaXRpYWxpemUoY29uZmlnRm9yTWFuYWdlZCwgdmFsdWUucGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkVmFsdWUgPSBhd2FpdCB2YWx1ZS5pbml0aWFsaXplKGNvbmZpZ0Zvck1hbmFnZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKFtrZXksIGluaXRpYWxpemVkVmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShbXSkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5uZWxTcGVjcyxcbiAgICAgICAgICAgIG1hbmFnZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgaW5wdXQgZm9yIHRoZSBncmFwaC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gdmFsaWRhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsaWRhdGVkIGlucHV0XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciB0aGUgZ3JhcGguXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmFibGUgb3B0aW9ucyB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0ZWQgY29uZmlndXJhYmxlIG9wdGlvbnNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfdmFsaWRhdGVDb25maWd1cmFibGUoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGl0ZXJhdG9yIHVzZWQgYnkgc3RyZWFtKCkgdG8gZ2VuZXJhdGUgc3RhdGUgdXBkYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBjb3JlIGxvZ2ljIG9mIGdyYXBoIGV4ZWN1dGlvbiBhbmQgc3RyZWFtaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHRvIHN0YXJ0IGdyYXBoIGV4ZWN1dGlvbiB3aXRoXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHN0cmVhbWluZ1xuICAgICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIHN0YXRlIHVwZGF0ZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbVN1YmdyYXBocyA9IG9wdGlvbnM/LnN1YmdyYXBocztcbiAgICAgICAgY29uc3QgaW5wdXRDb25maWcgPSBlbnN1cmVMYW5nR3JhcGhDb25maWcodGhpcy5jb25maWcsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaW5wdXRDb25maWcucmVjdXJzaW9uTGltaXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW5wdXRDb25maWcucmVjdXJzaW9uTGltaXQgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBcInJlY3Vyc2lvbkxpbWl0XCIgbXVzdCBiZSBhdCBsZWFzdCAxLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRlciAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIGlucHV0Q29uZmlnLmNvbmZpZ3VyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoZWNrcG9pbnRlciByZXF1aXJlcyBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIFwiY29uZmlndXJhYmxlXCIga2V5czogXCJ0aHJlYWRfaWRcIiwgXCJjaGVja3BvaW50X25zXCIsIFwiY2hlY2twb2ludF9pZFwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRJbnB1dCA9IGF3YWl0IHRoaXMuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5yZXN0Q29uZmlnIH0gPSBpbnB1dENvbmZpZztcbiAgICAgICAgLy8gYXNzaWduIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0IFtkZWJ1Zywgc3RyZWFtTW9kZSwgLCBvdXRwdXRLZXlzLCBjb25maWcsIGludGVycnVwdEJlZm9yZSwgaW50ZXJydXB0QWZ0ZXIsIGNoZWNrcG9pbnRlciwgc3RvcmUsIHN0cmVhbU1vZGVTaW5nbGUsXSA9IHRoaXMuX2RlZmF1bHRzKHJlc3RDb25maWcpO1xuICAgICAgICBjb25maWcuY29uZmlndXJhYmxlID0gYXdhaXQgdGhpcy5fdmFsaWRhdGVDb25maWd1cmFibGUoY29uZmlnLmNvbmZpZ3VyYWJsZSk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBJdGVyYWJsZVJlYWRhYmxlV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZXM6IG5ldyBTZXQoc3RyZWFtTW9kZSksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXQgdXAgbWVzc2FnZXMgc3RyZWFtIG1vZGVcbiAgICAgICAgaWYgKHN0cmVhbU1vZGUuaW5jbHVkZXMoXCJtZXNzYWdlc1wiKSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmVhbWVyID0gbmV3IFN0cmVhbU1lc3NhZ2VzSGFuZGxlcigoY2h1bmspID0+IHN0cmVhbS5wdXNoKGNodW5rKSk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IFttZXNzYWdlU3RyZWFtZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQobWVzc2FnZVN0cmVhbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmFkZEhhbmRsZXIobWVzc2FnZVN0cmVhbWVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIGN1c3RvbSBzdHJlYW0gbW9kZVxuICAgICAgICBpZiAoc3RyZWFtTW9kZS5pbmNsdWRlcyhcImN1c3RvbVwiKSkge1xuICAgICAgICAgICAgY29uZmlnLndyaXRlciA9IChjaHVuaykgPT4gc3RyZWFtLnB1c2goW1tdLCBcImN1c3RvbVwiLCBjaHVua10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIC8vIGNoYWluXG4gICAgICAgIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIC8vIGlucHV0c1xuICAgICAgICBydW5JZCwgLy8gcnVuX2lkXG4gICAgICAgIHVuZGVmaW5lZCwgLy8gcnVuX3R5cGVcbiAgICAgICAgdW5kZWZpbmVkLCAvLyB0YWdzXG4gICAgICAgIHVuZGVmaW5lZCwgLy8gbWV0YWRhdGFcbiAgICAgICAgY29uZmlnPy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpIC8vIHJ1bl9uYW1lXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgY2hhbm5lbFNwZWNzLCBtYW5hZ2VkIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVTcGVjcyhjb25maWcpO1xuICAgICAgICBsZXQgbG9vcDtcbiAgICAgICAgbGV0IGxvb3BFcnJvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBQcmVnZWxMb29wIHdpbGwgeWllbGQgZXZlbnRzIGZyb20gY29uY3VycmVudCB0YXNrcyBhcyBzb29uIGFzIHRoZXkgYXJlXG4gICAgICAgICAqIGdlbmVyYXRlZC4gRWFjaCB0YXNrIGNhbiBwdXNoIG11bHRpcGxlIGV2ZW50cyBvbnRvIHRoZSBzdHJlYW0gaW4gYW55IG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSB1c2UgYSBzZXBhcmF0ZSBiYWNrZ3JvdW5kIG1ldGhvZCBhbmQgc3RyZWFtIGhlcmUgaW4gb3JkZXIgdG8geWllbGQgZXZlbnRzXG4gICAgICAgICAqIGZyb20gdGhlIGxvb3AgdG8gdGhlIG1haW4gc3RyZWFtIGFuZCB0aGVyZWZvcmUgYmFjayB0byB0aGUgdXNlciBhcyBzb29uIGFzXG4gICAgICAgICAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNyZWF0ZUFuZFJ1bkxvb3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvb3AgPSBhd2FpdCBQcmVnZWxMb29wLmluaXRpYWxpemUoe1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdmFsaWRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiB0aGlzLm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsU3BlY3MsXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWQsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbUtleXM6IHRoaXMuc3RyZWFtQ2hhbm5lbHNBc0lzLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyOiBydW5NYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgUHJlZ2VsUnVubmVyKHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUZpbmlzaGVkOiBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9OT0RFX0ZJTklTSEVEXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8uc3ViZ3JhcGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb3AuY29uZmlnLmNvbmZpZ3VyYWJsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxvb3AuY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NUUkVBTV06IGxvb3Auc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ydW5Mb29wKHsgbG9vcCwgcnVubmVyLCBkZWJ1ZywgY29uZmlnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb29wRXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBgLnN0b3AoKWAgYWdhaW4gaW5jYXNlIGl0IHdhcyBub3QgY2FsbGVkIGluIHRoZSBsb29wLCBlLmcgZHVlIHRvIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9vcC5zdG9yZT8uc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihsb29wPy5jaGVja3BvaW50ZXJQcm9taXNlcyA/PyBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKG1hbmFnZWQudmFsdWVzKCkpLm1hcCgobXYpID0+IG12LnByb21pc2VzKCkpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9yID0gbG9vcEVycm9yID8/IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb29wRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJDYXVzZXMgYW55IGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gdG8gZXJyb3JcIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcHMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciNlcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIvZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVycm9yKGxvb3BFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxsIGVuZCB0aGUgaXRlcmF0b3Igb3V0c2lkZSBvZiB0aGlzIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcGluZyBwcmV2aW91c2x5IGVucXVldWVkIGNodW5rcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcHMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciNjbG9zZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIvY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5Mb29wUHJvbWlzZSA9IGNyZWF0ZUFuZFJ1bkxvb3AoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzdHJ1Y3R1cmUgZXJyb3IuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbbmFtZXNwYWNlLCBtb2RlLCBwYXlsb2FkXSA9IGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1Nb2RlLmluY2x1ZGVzKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1TdWJncmFwaHMgJiYgIXN0cmVhbU1vZGVTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtuYW1lc3BhY2UsIG1vZGUsIHBheWxvYWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzdHJlYW1Nb2RlU2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbW9kZSwgcGF5bG9hZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtU3ViZ3JhcGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbmFtZXNwYWNlLCBwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IobG9vcEVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBydW5Mb29wUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChsb29wPy5vdXRwdXQgPz8ge30sIHJ1bklkLCAvLyBydW5faWRcbiAgICAgICAgdW5kZWZpbmVkLCAvLyBydW5fdHlwZVxuICAgICAgICB1bmRlZmluZWQsIC8vIHRhZ3NcbiAgICAgICAgdW5kZWZpbmVkIC8vIG1ldGFkYXRhXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgZ3JhcGggd2l0aCBhIHNpbmdsZSBpbnB1dCBhbmQgY29uZmlnLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gdGhlIGdyYXBoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjb25maWd1cmF0aW9uIHRvIHVzZSBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtTW9kZSA9IG9wdGlvbnM/LnN0cmVhbU1vZGUgPz8gXCJ2YWx1ZXNcIjtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG91dHB1dEtleXM6IG9wdGlvbnM/Lm91dHB1dEtleXMgPz8gdGhpcy5vdXRwdXRDaGFubmVscyxcbiAgICAgICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLnN0cmVhbShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtTW9kZSA9PT0gXCJ2YWx1ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9XG4gICAgYXN5bmMgX3J1bkxvb3AocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgbG9vcCwgcnVubmVyLCBkZWJ1ZywgY29uZmlnIH0gPSBwYXJhbXM7XG4gICAgICAgIGxldCB0aWNrRXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAoYXdhaXQgbG9vcC50aWNrKHtcbiAgICAgICAgICAgICAgICBpbnB1dEtleXM6IHRoaXMuaW5wdXRDaGFubmVscyxcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50U3RlcENoZWNrcG9pbnQobG9vcC5jaGVja3BvaW50TWV0YWRhdGEuc3RlcCwgbG9vcC5jaGFubmVscywgdGhpcy5zdHJlYW1DaGFubmVsc0xpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRTdGVwVGFza3MobG9vcC5zdGVwLCBPYmplY3QudmFsdWVzKGxvb3AudGFza3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVubmVyLnRpY2soe1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnN0ZXBUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICByZXRyeVBvbGljeTogdGhpcy5yZXRyeVBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgb25TdGVwV3JpdGU6IChzdGVwLCB3cml0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50U3RlcFdyaXRlcyhzdGVwLCB3cml0ZXMsIHRoaXMuc3RyZWFtQ2hhbm5lbHNMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IGNvbmZpZy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb25maWcuc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvb3Auc3RhdHVzID09PSBcIm91dF9vZl9zdGVwc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUmVjdXJzaW9uRXJyb3IoW1xuICAgICAgICAgICAgICAgICAgICBgUmVjdXJzaW9uIGxpbWl0IG9mICR7Y29uZmlnLnJlY3Vyc2lvbkxpbWl0fSByZWFjaGVkYCxcbiAgICAgICAgICAgICAgICAgICAgXCJ3aXRob3V0IGhpdHRpbmcgYSBzdG9wIGNvbmRpdGlvbi4gWW91IGNhbiBpbmNyZWFzZSB0aGVcIixcbiAgICAgICAgICAgICAgICAgICAgYGxpbWl0IGJ5IHNldHRpbmcgdGhlIFwicmVjdXJzaW9uTGltaXRcIiBjb25maWcga2V5LmAsXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKSwge1xuICAgICAgICAgICAgICAgICAgICBsY19lcnJvcl9jb2RlOiBcIkdSQVBIX1JFQ1VSU0lPTl9MSU1JVFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aWNrRXJyb3IgPSBlO1xuICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3MgPSBhd2FpdCBsb29wLmZpbmlzaEFuZEhhbmRsZUVycm9yKHRpY2tFcnJvcik7XG4gICAgICAgICAgICBpZiAoIXN1cHByZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aWNrRXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvb3AuZmluaXNoQW5kSGFuZGxlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapCommand: () => (/* binding */ mapCommand),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   mapOutputUpdates: () => (/* binding */ mapOutputUpdates),\n/* harmony export */   mapOutputValues: () => (/* binding */ mapOutputValues),\n/* harmony export */   readChannel: () => (/* binding */ readChannel),\n/* harmony export */   readChannels: () => (/* binding */ readChannels),\n/* harmony export */   single: () => (/* binding */ single)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n\n\n\nfunction readChannel(channels, chan, catchErrors = true, returnException = false) {\n    try {\n        return channels[chan].get();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n            if (returnException) {\n                return e;\n            }\n            else if (catchErrors) {\n                return null;\n            }\n        }\n        throw e;\n    }\n}\nfunction readChannels(channels, select, skipEmpty = true\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (Array.isArray(select)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const values = {};\n        for (const k of select) {\n            try {\n                values[k] = readChannel(channels, k, !skipEmpty);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (e) {\n                if (e.name === _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError.unminifiable_name) {\n                    continue;\n                }\n            }\n        }\n        return values;\n    }\n    else {\n        return readChannel(channels, select);\n    }\n}\n/**\n * Map input chunk to a sequence of pending writes in the form (channel, value).\n */\nfunction* mapCommand(cmd, pendingWrites) {\n    if (cmd.graph === _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command.PARENT) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError(\"There is no parent graph.\");\n    }\n    if (cmd.goto) {\n        let sends;\n        if (Array.isArray(cmd.goto)) {\n            sends = cmd.goto;\n        }\n        else {\n            sends = [cmd.goto];\n        }\n        for (const send of sends) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_0__._isSend)(send)) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, _constants_js__WEBPACK_IMPORTED_MODULE_0__.TASKS, send];\n            }\n            else if (typeof send === \"string\") {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, `branch:__start__:${_constants_js__WEBPACK_IMPORTED_MODULE_0__.SELF}:${send}`, \"__start__\"];\n            }\n            else {\n                throw new Error(`In Command.send, expected Send or string, got ${typeof send}`);\n            }\n        }\n    }\n    if (cmd.resume) {\n        if (typeof cmd.resume === \"object\" &&\n            Object.keys(cmd.resume).length &&\n            Object.keys(cmd.resume).every(uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n            for (const [tid, resume] of Object.entries(cmd.resume)) {\n                const existing = pendingWrites\n                    .filter((w) => w[0] === tid && w[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME)\n                    .map((w) => w[2])\n                    .slice(0, 1) ?? [];\n                existing.push(resume);\n                yield [tid, _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME, existing];\n            }\n        }\n        else {\n            yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, _constants_js__WEBPACK_IMPORTED_MODULE_0__.RESUME, cmd.resume];\n        }\n    }\n    if (cmd.update) {\n        if (typeof cmd.update !== \"object\" || !cmd.update) {\n            throw new Error(\"Expected cmd.update to be a dict mapping channel names to update values\");\n        }\n        if (Array.isArray(cmd.update)) {\n            for (const [k, v] of cmd.update) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, k, v];\n            }\n        }\n        else {\n            for (const [k, v] of Object.entries(cmd.update)) {\n                yield [_constants_js__WEBPACK_IMPORTED_MODULE_0__.NULL_TASK_ID, k, v];\n            }\n        }\n    }\n}\n/**\n * Map input chunk to a sequence of pending writes in the form [channel, value].\n */\nfunction* mapInput(inputChannels, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nchunk\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (chunk !== undefined && chunk !== null) {\n        if (Array.isArray(inputChannels) &&\n            typeof chunk === \"object\" &&\n            !Array.isArray(chunk)) {\n            for (const k in chunk) {\n                if (inputChannels.includes(k)) {\n                    yield [k, chunk[k]];\n                }\n            }\n        }\n        else if (Array.isArray(inputChannels)) {\n            throw new Error(`Input chunk must be an object when \"inputChannels\" is an array`);\n        }\n        else {\n            yield [inputChannels, chunk];\n        }\n    }\n}\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nfunction* mapOutputValues(outputChannels, pendingWrites, channels\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    if (Array.isArray(outputChannels)) {\n        if (pendingWrites === true ||\n            pendingWrites.find(([chan, _]) => outputChannels.includes(chan))) {\n            yield readChannels(channels, outputChannels);\n        }\n    }\n    else {\n        if (pendingWrites === true ||\n            pendingWrites.some(([chan, _]) => chan === outputChannels)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            yield readChannel(channels, outputChannels);\n        }\n    }\n}\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n * @internal\n *\n * @param outputChannels - The channels to output.\n * @param tasks - The tasks to output.\n * @param cached - Whether the output is cached.\n *\n * @returns A generator that yields the output chunk (if any).\n */\nfunction* mapOutputUpdates(outputChannels, tasks, cached) {\n    const outputTasks = tasks.filter(([task, ww]) => {\n        return ((task.config === undefined || !task.config.tags?.includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TAG_HIDDEN)) &&\n            ww[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR &&\n            ww[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT);\n    });\n    if (!outputTasks.length) {\n        return;\n    }\n    let updated;\n    if (outputTasks.some(([task]) => task.writes.some(([chan, _]) => chan === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RETURN))) {\n        // TODO: probably should assert that RETURN is the only \"non-special\" channel (starts with \"__\")\n        updated = outputTasks.flatMap(([task]) => task.writes\n            .filter(([chan, _]) => chan === _constants_js__WEBPACK_IMPORTED_MODULE_0__.RETURN)\n            .map(([_, value]) => [task.name, value]));\n    }\n    else if (!Array.isArray(outputChannels)) {\n        // special case where graph state is a single channel (MessageGraph)\n        // probably using this in functional API, too\n        updated = outputTasks.flatMap(([task]) => task.writes\n            .filter(([chan, _]) => chan === outputChannels)\n            .map(([_, value]) => [task.name, value]));\n    }\n    else {\n        updated = outputTasks.flatMap(([task]) => {\n            const { writes } = task;\n            const counts = {};\n            for (const [chan] of writes) {\n                if (outputChannels.includes(chan)) {\n                    counts[chan] = (counts[chan] || 0) + 1;\n                }\n            }\n            if (Object.values(counts).some((count) => count > 1)) {\n                // Multiple writes to the same channel: create separate entries\n                return writes\n                    .filter(([chan]) => outputChannels.includes(chan))\n                    .map(([chan, value]) => [task.name, { [chan]: value }]);\n            }\n            else {\n                // Single write to each channel: create a single combined entry\n                return [\n                    [\n                        task.name,\n                        Object.fromEntries(writes.filter(([chan]) => outputChannels.includes(chan))),\n                    ],\n                ];\n            }\n        });\n    }\n    const grouped = {};\n    for (const [node, value] of updated) {\n        if (!(node in grouped)) {\n            grouped[node] = [];\n        }\n        grouped[node].push(value);\n    }\n    const flattened = {};\n    for (const node in grouped) {\n        if (grouped[node].length === 1) {\n            const [write] = grouped[node];\n            flattened[node] = write;\n        }\n        else {\n            flattened[node] = grouped[node];\n        }\n    }\n    if (cached) {\n        flattened[\"__metadata__\"] = { cached };\n    }\n    yield flattened;\n}\nfunction single(iter) {\n    // eslint-disable-next-line no-unreachable-loop\n    for (const value of iter) {\n        return value;\n    }\n    return null;\n}\n//# sourceMappingURL=io.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9pby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQzZGO0FBQ3hEO0FBQzlEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQkFBc0Isa0RBQU87QUFDN0Isa0JBQWtCLDBEQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTztBQUN2Qix1QkFBdUIsdURBQVksRUFBRSxnREFBSztBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZLHNCQUFzQiwrQ0FBSSxDQUFDLEdBQUcsS0FBSztBQUN0RTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRDQUFRO0FBQ2xEO0FBQ0E7QUFDQSw0REFBNEQsaURBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBWSxFQUFFLGlEQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBFQUEwRSxxREFBVTtBQUNwRix5QkFBeUIsZ0RBQUs7QUFDOUIseUJBQXlCLG9EQUFTO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxpREFBTTtBQUNwRjtBQUNBO0FBQ0EsNENBQTRDLGlEQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvaW8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmFsaWRhdGUgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgX2lzU2VuZCwgQ29tbWFuZCwgRVJST1IsIElOVEVSUlVQVCwgTlVMTF9UQVNLX0lELCBSRVNVTUUsIFJFVFVSTiwgU0VMRiwgVEFHX0hJRERFTiwgVEFTS1MsIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgRW1wdHlDaGFubmVsRXJyb3IsIEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkQ2hhbm5lbChjaGFubmVscywgY2hhbiwgY2F0Y2hFcnJvcnMgPSB0cnVlLCByZXR1cm5FeGNlcHRpb24gPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsc1tjaGFuXS5nZXQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gRW1wdHlDaGFubmVsRXJyb3IudW5taW5pZmlhYmxlX25hbWUpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhdGNoRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZENoYW5uZWxzKGNoYW5uZWxzLCBzZWxlY3QsIHNraXBFbXB0eSA9IHRydWVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3QpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Ygc2VsZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1trXSA9IHJlYWRDaGFubmVsKGNoYW5uZWxzLCBrLCAhc2tpcEVtcHR5KTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSBFbXB0eUNoYW5uZWxFcnJvci51bm1pbmlmaWFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZWFkQ2hhbm5lbChjaGFubmVscywgc2VsZWN0KTtcbiAgICB9XG59XG4vKipcbiAqIE1hcCBpbnB1dCBjaHVuayB0byBhIHNlcXVlbmNlIG9mIHBlbmRpbmcgd3JpdGVzIGluIHRoZSBmb3JtIChjaGFubmVsLCB2YWx1ZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogbWFwQ29tbWFuZChjbWQsIHBlbmRpbmdXcml0ZXMpIHtcbiAgICBpZiAoY21kLmdyYXBoID09PSBDb21tYW5kLlBBUkVOVCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiVGhlcmUgaXMgbm8gcGFyZW50IGdyYXBoLlwiKTtcbiAgICB9XG4gICAgaWYgKGNtZC5nb3RvKSB7XG4gICAgICAgIGxldCBzZW5kcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY21kLmdvdG8pKSB7XG4gICAgICAgICAgICBzZW5kcyA9IGNtZC5nb3RvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VuZHMgPSBbY21kLmdvdG9dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2VuZCBvZiBzZW5kcykge1xuICAgICAgICAgICAgaWYgKF9pc1NlbmQoc2VuZCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbTlVMTF9UQVNLX0lELCBUQVNLUywgc2VuZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VuZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtOVUxMX1RBU0tfSUQsIGBicmFuY2g6X19zdGFydF9fOiR7U0VMRn06JHtzZW5kfWAsIFwiX19zdGFydF9fXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiBDb21tYW5kLnNlbmQsIGV4cGVjdGVkIFNlbmQgb3Igc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc2VuZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY21kLnJlc3VtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNtZC5yZXN1bWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNtZC5yZXN1bWUpLmxlbmd0aCAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY21kLnJlc3VtZSkuZXZlcnkodmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0aWQsIHJlc3VtZV0gb2YgT2JqZWN0LmVudHJpZXMoY21kLnJlc3VtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHBlbmRpbmdXcml0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodykgPT4gd1swXSA9PT0gdGlkICYmIHdbMV0gPT09IFJFU1VNRSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodykgPT4gd1syXSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDEpID8/IFtdO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVzdW1lKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGlkLCBSRVNVTUUsIGV4aXN0aW5nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIFtOVUxMX1RBU0tfSUQsIFJFU1VNRSwgY21kLnJlc3VtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNtZC51cGRhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbWQudXBkYXRlICE9PSBcIm9iamVjdFwiIHx8ICFjbWQudXBkYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBjbWQudXBkYXRlIHRvIGJlIGEgZGljdCBtYXBwaW5nIGNoYW5uZWwgbmFtZXMgdG8gdXBkYXRlIHZhbHVlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQudXBkYXRlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgY21kLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtOVUxMX1RBU0tfSUQsIGssIHZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY21kLnVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbTlVMTF9UQVNLX0lELCBrLCB2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWFwIGlucHV0IGNodW5rIHRvIGEgc2VxdWVuY2Ugb2YgcGVuZGluZyB3cml0ZXMgaW4gdGhlIGZvcm0gW2NoYW5uZWwsIHZhbHVlXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBtYXBJbnB1dChpbnB1dENoYW5uZWxzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jaHVua1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkICYmIGNodW5rICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0Q2hhbm5lbHMpICYmXG4gICAgICAgICAgICB0eXBlb2YgY2h1bmsgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Q2hhbm5lbHMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGNodW5rW2tdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dENoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBjaHVuayBtdXN0IGJlIGFuIG9iamVjdCB3aGVuIFwiaW5wdXRDaGFubmVsc1wiIGlzIGFuIGFycmF5YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBbaW5wdXRDaGFubmVscywgY2h1bmtdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBNYXAgcGVuZGluZyB3cml0ZXMgKGEgc2VxdWVuY2Ugb2YgdHVwbGVzIChjaGFubmVsLCB2YWx1ZSkpIHRvIG91dHB1dCBjaHVuay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBtYXBPdXRwdXRWYWx1ZXMob3V0cHV0Q2hhbm5lbHMsIHBlbmRpbmdXcml0ZXMsIGNoYW5uZWxzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0Q2hhbm5lbHMpKSB7XG4gICAgICAgIGlmIChwZW5kaW5nV3JpdGVzID09PSB0cnVlIHx8XG4gICAgICAgICAgICBwZW5kaW5nV3JpdGVzLmZpbmQoKFtjaGFuLCBfXSkgPT4gb3V0cHV0Q2hhbm5lbHMuaW5jbHVkZXMoY2hhbikpKSB7XG4gICAgICAgICAgICB5aWVsZCByZWFkQ2hhbm5lbHMoY2hhbm5lbHMsIG91dHB1dENoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHBlbmRpbmdXcml0ZXMgPT09IHRydWUgfHxcbiAgICAgICAgICAgIHBlbmRpbmdXcml0ZXMuc29tZSgoW2NoYW4sIF9dKSA9PiBjaGFuID09PSBvdXRwdXRDaGFubmVscykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB5aWVsZCByZWFkQ2hhbm5lbChjaGFubmVscywgb3V0cHV0Q2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBNYXAgcGVuZGluZyB3cml0ZXMgKGEgc2VxdWVuY2Ugb2YgdHVwbGVzIChjaGFubmVsLCB2YWx1ZSkpIHRvIG91dHB1dCBjaHVuay5cbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBwYXJhbSBvdXRwdXRDaGFubmVscyAtIFRoZSBjaGFubmVscyB0byBvdXRwdXQuXG4gKiBAcGFyYW0gdGFza3MgLSBUaGUgdGFza3MgdG8gb3V0cHV0LlxuICogQHBhcmFtIGNhY2hlZCAtIFdoZXRoZXIgdGhlIG91dHB1dCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybnMgQSBnZW5lcmF0b3IgdGhhdCB5aWVsZHMgdGhlIG91dHB1dCBjaHVuayAoaWYgYW55KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBtYXBPdXRwdXRVcGRhdGVzKG91dHB1dENoYW5uZWxzLCB0YXNrcywgY2FjaGVkKSB7XG4gICAgY29uc3Qgb3V0cHV0VGFza3MgPSB0YXNrcy5maWx0ZXIoKFt0YXNrLCB3d10pID0+IHtcbiAgICAgICAgcmV0dXJuICgodGFzay5jb25maWcgPT09IHVuZGVmaW5lZCB8fCAhdGFzay5jb25maWcudGFncz8uaW5jbHVkZXMoVEFHX0hJRERFTikpICYmXG4gICAgICAgICAgICB3d1swXVswXSAhPT0gRVJST1IgJiZcbiAgICAgICAgICAgIHd3WzBdWzBdICE9PSBJTlRFUlJVUFQpO1xuICAgIH0pO1xuICAgIGlmICghb3V0cHV0VGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQ7XG4gICAgaWYgKG91dHB1dFRhc2tzLnNvbWUoKFt0YXNrXSkgPT4gdGFzay53cml0ZXMuc29tZSgoW2NoYW4sIF9dKSA9PiBjaGFuID09PSBSRVRVUk4pKSkge1xuICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSBzaG91bGQgYXNzZXJ0IHRoYXQgUkVUVVJOIGlzIHRoZSBvbmx5IFwibm9uLXNwZWNpYWxcIiBjaGFubmVsIChzdGFydHMgd2l0aCBcIl9fXCIpXG4gICAgICAgIHVwZGF0ZWQgPSBvdXRwdXRUYXNrcy5mbGF0TWFwKChbdGFza10pID0+IHRhc2sud3JpdGVzXG4gICAgICAgICAgICAuZmlsdGVyKChbY2hhbiwgX10pID0+IGNoYW4gPT09IFJFVFVSTilcbiAgICAgICAgICAgIC5tYXAoKFtfLCB2YWx1ZV0pID0+IFt0YXNrLm5hbWUsIHZhbHVlXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShvdXRwdXRDaGFubmVscykpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHdoZXJlIGdyYXBoIHN0YXRlIGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1lc3NhZ2VHcmFwaClcbiAgICAgICAgLy8gcHJvYmFibHkgdXNpbmcgdGhpcyBpbiBmdW5jdGlvbmFsIEFQSSwgdG9vXG4gICAgICAgIHVwZGF0ZWQgPSBvdXRwdXRUYXNrcy5mbGF0TWFwKChbdGFza10pID0+IHRhc2sud3JpdGVzXG4gICAgICAgICAgICAuZmlsdGVyKChbY2hhbiwgX10pID0+IGNoYW4gPT09IG91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgLm1hcCgoW18sIHZhbHVlXSkgPT4gW3Rhc2submFtZSwgdmFsdWVdKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cGRhdGVkID0gb3V0cHV0VGFza3MuZmxhdE1hcCgoW3Rhc2tdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHdyaXRlcyB9ID0gdGFzaztcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hhbl0gb2Ygd3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dENoYW5uZWxzLmluY2x1ZGVzKGNoYW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50c1tjaGFuXSA9IChjb3VudHNbY2hhbl0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKGNvdW50cykuc29tZSgoY291bnQpID0+IGNvdW50ID4gMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBsZSB3cml0ZXMgdG8gdGhlIHNhbWUgY2hhbm5lbDogY3JlYXRlIHNlcGFyYXRlIGVudHJpZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtjaGFuXSkgPT4gb3V0cHV0Q2hhbm5lbHMuaW5jbHVkZXMoY2hhbikpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtjaGFuLCB2YWx1ZV0pID0+IFt0YXNrLm5hbWUsIHsgW2NoYW5dOiB2YWx1ZSB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgd3JpdGUgdG8gZWFjaCBjaGFubmVsOiBjcmVhdGUgYSBzaW5nbGUgY29tYmluZWQgZW50cnlcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMod3JpdGVzLmZpbHRlcigoW2NoYW5dKSA9PiBvdXRwdXRDaGFubmVscy5pbmNsdWRlcyhjaGFuKSkpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBncm91cGVkID0ge307XG4gICAgZm9yIChjb25zdCBbbm9kZSwgdmFsdWVdIG9mIHVwZGF0ZWQpIHtcbiAgICAgICAgaWYgKCEobm9kZSBpbiBncm91cGVkKSkge1xuICAgICAgICAgICAgZ3JvdXBlZFtub2RlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwZWRbbm9kZV0ucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IHt9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBpbiBncm91cGVkKSB7XG4gICAgICAgIGlmIChncm91cGVkW25vZGVdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgW3dyaXRlXSA9IGdyb3VwZWRbbm9kZV07XG4gICAgICAgICAgICBmbGF0dGVuZWRbbm9kZV0gPSB3cml0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFtub2RlXSA9IGdyb3VwZWRbbm9kZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBmbGF0dGVuZWRbXCJfX21ldGFkYXRhX19cIl0gPSB7IGNhY2hlZCB9O1xuICAgIH1cbiAgICB5aWVsZCBmbGF0dGVuZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlKGl0ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGUtbG9vcFxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/loop.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/loop.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PregelLoop: () => (/* binding */ PregelLoop)\n/* harmony export */ });\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph-checkpoint@0.0.17_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4__/node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _channels_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../channels/base.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/base.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _algo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./algo.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/algo.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./io.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/io.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./debug.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/debug.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/stream.js\");\n\n\n\n\n\n\n\n\n\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\nfunction createDuplexStream(...streams) {\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_9__.IterableReadableWritableStream({\n        passthroughFn: (value) => {\n            for (const stream of streams) {\n                if (stream.modes.has(value[1])) {\n                    stream.push(value);\n                }\n            }\n        },\n        modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n    });\n}\nclass PregelLoop {\n    get isResuming() {\n        const hasChannelVersions = Object.keys(this.checkpoint.channel_versions).length !== 0;\n        const configHasResumingFlag = this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING] !== undefined;\n        const configIsResuming = configHasResumingFlag && this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING];\n        const inputIsNullOrUndefined = this.input === null || this.input === undefined;\n        const inputIsCommandResuming = (0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input) && this.input.resume != null;\n        const inputIsResuming = this.input === INPUT_RESUMING;\n        return (hasChannelVersions &&\n            (configIsResuming ||\n                inputIsNullOrUndefined ||\n                inputIsCommandResuming ||\n                inputIsResuming));\n    }\n    constructor(params) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"input\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointerGetNextVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"managed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointNamespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointPendingWrites\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"checkpointPreviousVersions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"step\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"skipDoneTasks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"prevCheckpointConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"pending\"\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"tasks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"stream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"checkpointerPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"isNested\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_checkpointerChainedPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: Promise.resolve()\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"interruptAfter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"interruptBefore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"toInterrupt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.input = params.input;\n        this.checkpointer = params.checkpointer;\n        // TODO: if managed values no longer needs graph we can replace with\n        // managed_specs, channel_specs\n        if (this.checkpointer !== undefined) {\n            this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer);\n        }\n        else {\n            this.checkpointerGetNextVersion = _algo_js__WEBPACK_IMPORTED_MODULE_3__.increment;\n        }\n        this.checkpoint = params.checkpoint;\n        this.checkpointMetadata = params.checkpointMetadata;\n        this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n        this.channels = params.channels;\n        this.managed = params.managed;\n        this.checkpointPendingWrites = params.checkpointPendingWrites;\n        this.step = params.step;\n        this.stop = params.stop;\n        this.config = params.config;\n        this.checkpointConfig = params.checkpointConfig;\n        this.isNested = params.isNested;\n        this.manager = params.manager;\n        this.outputKeys = params.outputKeys;\n        this.streamKeys = params.streamKeys;\n        this.nodes = params.nodes;\n        this.skipDoneTasks = params.skipDoneTasks;\n        this.store = params.store;\n        this.stream = params.stream;\n        this.checkpointNamespace = params.checkpointNamespace;\n        this.prevCheckpointConfig = params.prevCheckpointConfig;\n        this.interruptAfter = params.interruptAfter;\n        this.interruptBefore = params.interruptBefore;\n        this.debug = params.debug;\n    }\n    static async initialize(params) {\n        let { config, stream } = params;\n        if (stream !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_STREAM] !== undefined) {\n            stream = createDuplexStream(stream, config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_STREAM]);\n        }\n        const skipDoneTasks = config.configurable\n            ? !(\"checkpoint_id\" in config.configurable)\n            : true;\n        const scratchpad = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n        if (config.configurable && scratchpad) {\n            if (scratchpad.subgraphCounter > 0) {\n                config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_NS]: [\n                        config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_NS],\n                        scratchpad.subgraphCounter.toString(),\n                    ].join(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CHECKPOINT_NAMESPACE_SEPARATOR),\n                });\n            }\n            scratchpad.subgraphCounter += 1;\n        }\n        const isNested = _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_READ in (config.configurable ?? {});\n        if (!isNested &&\n            config.configurable?.checkpoint_ns !== undefined &&\n            config.configurable?.checkpoint_ns !== \"\") {\n            config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                checkpoint_ns: \"\",\n                checkpoint_id: undefined,\n            });\n        }\n        let checkpointConfig = config;\n        if (config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n            config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP]?.[config.configurable?.checkpoint_ns]) {\n            checkpointConfig = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(config, {\n                checkpoint_id: config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP][config.configurable?.checkpoint_ns],\n            });\n        }\n        const checkpointNamespace = config.configurable?.checkpoint_ns?.split(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CHECKPOINT_NAMESPACE_SEPARATOR) ?? [];\n        const saved = (await params.checkpointer?.getTuple(checkpointConfig)) ?? {\n            config,\n            checkpoint: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.emptyCheckpoint)(),\n            metadata: {\n                source: \"input\",\n                step: -2,\n                writes: null,\n                parents: {},\n            },\n            pendingWrites: [],\n        };\n        checkpointConfig = {\n            ...config,\n            ...saved.config,\n            configurable: {\n                checkpoint_ns: \"\",\n                ...config.configurable,\n                ...saved.config.configurable,\n            },\n        };\n        const prevCheckpointConfig = saved.parentConfig;\n        const checkpoint = (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint)(saved.checkpoint);\n        const checkpointMetadata = { ...saved.metadata };\n        const checkpointPendingWrites = saved.pendingWrites ?? [];\n        const channels = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.emptyChannels)(params.channelSpecs, checkpoint);\n        const step = (checkpointMetadata.step ?? 0) + 1;\n        const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n        const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n        const store = params.store\n            ? new _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.AsyncBatchedStore(params.store)\n            : undefined;\n        if (store) {\n            // Start the store. This is a batch store, so it will run continuously\n            store.start();\n        }\n        return new PregelLoop({\n            input: params.input,\n            config,\n            checkpointer: params.checkpointer,\n            checkpoint,\n            checkpointMetadata,\n            checkpointConfig,\n            prevCheckpointConfig,\n            checkpointNamespace,\n            channels,\n            managed: params.managed,\n            isNested,\n            manager: params.manager,\n            skipDoneTasks,\n            step,\n            stop,\n            checkpointPreviousVersions,\n            checkpointPendingWrites,\n            outputKeys: params.outputKeys ?? [],\n            streamKeys: params.streamKeys ?? [],\n            nodes: params.nodes,\n            stream,\n            store,\n            interruptAfter: params.interruptAfter,\n            interruptBefore: params.interruptBefore,\n            debug: params.debug,\n        });\n    }\n    _checkpointerPutAfterPrevious(input) {\n        this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => {\n            return this.checkpointer?.put(input.config, input.checkpoint, input.metadata, input.newVersions);\n        });\n        this.checkpointerPromises.push(this._checkpointerChainedPromise);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async updateManagedValues(key, values) {\n        const mv = this.managed.get(key);\n        if (mv && \"update\" in mv && typeof mv.update === \"function\") {\n            await mv.update(values);\n        }\n    }\n    /**\n     * Put writes for a task, to be read by the next tick.\n     * @param taskId\n     * @param writes\n     */\n    putWrites(taskId, writes) {\n        let writesCopy = writes;\n        if (writesCopy.length === 0) {\n            return;\n        }\n        // deduplicate writes to special channels, last write wins\n        if (writesCopy.every(([key]) => key in _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP)) {\n            writesCopy = Array.from(new Map(writesCopy.map((w) => [w[0], w])).values());\n        }\n        // save writes\n        for (const [c, v] of writesCopy) {\n            const idx = this.checkpointPendingWrites.findIndex((w) => w[0] === taskId && w[1] === c);\n            if (c in _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.WRITES_IDX_MAP && idx !== -1) {\n                this.checkpointPendingWrites[idx] = [taskId, c, v];\n            }\n            else {\n                this.checkpointPendingWrites.push([taskId, c, v]);\n            }\n        }\n        const putWritePromise = this.checkpointer?.putWrites({\n            ...this.checkpointConfig,\n            configurable: {\n                ...this.checkpointConfig.configurable,\n                checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n                checkpoint_id: this.checkpoint.id,\n            },\n        }, writesCopy, taskId);\n        if (putWritePromise !== undefined) {\n            this.checkpointerPromises.push(putWritePromise);\n        }\n        if (this.tasks) {\n            this._outputWrites(taskId, writesCopy);\n        }\n    }\n    _outputWrites(taskId, writes, cached = false) {\n        const task = this.tasks[taskId];\n        if (task !== undefined) {\n            if (task.config !== undefined &&\n                (task.config.tags ?? []).includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN)) {\n                return;\n            }\n            if (writes.length > 0 &&\n                writes[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR &&\n                writes[0][0] !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT) {\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputUpdates)(this.outputKeys, [[task, writes]], cached), \"updates\")));\n            }\n            if (!cached) {\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTaskResults)(this.step, [[task, writes]], this.streamKeys), \"debug\")));\n            }\n        }\n    }\n    /**\n     * Execute a single iteration of the Pregel loop.\n     * Returns true if more iterations are needed.\n     * @param params\n     */\n    async tick(params) {\n        if (this.store && !this.store.isRunning) {\n            this.store?.start();\n        }\n        const { inputKeys = [] } = params;\n        if (this.status !== \"pending\") {\n            throw new Error(`Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`);\n        }\n        if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n            await this._first(inputKeys);\n        }\n        else if (this.toInterrupt.length > 0) {\n            this.status = \"interrupt_before\";\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n        }\n        else if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n            // finish superstep\n            const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n            // All tasks have finished\n            const managedValueWrites = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);\n            for (const [key, values] of Object.entries(managedValueWrites)) {\n                await this.updateManagedValues(key, values);\n            }\n            // produce values output\n            const valuesOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, writes, this.channels), \"values\"));\n            this._emit(valuesOutput);\n            // clear pending writes\n            this.checkpointPendingWrites = [];\n            await this._putCheckpoint({\n                source: \"loop\",\n                writes: (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputUpdates)(this.outputKeys, Object.values(this.tasks).map((task) => [task, task.writes])).next().value ?? null,\n            });\n            // after execution, check if we should interrupt\n            if ((0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptAfter, Object.values(this.tasks))) {\n                this.status = \"interrupt_after\";\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n            }\n            // unset resuming flag\n            if (this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING] !== undefined) {\n                delete this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING];\n            }\n        }\n        else {\n            return false;\n        }\n        if (this.step > this.stop) {\n            this.status = \"out_of_steps\";\n            return false;\n        }\n        const nextTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareNextTasks)(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, true, {\n            step: this.step,\n            checkpointer: this.checkpointer,\n            isResuming: this.isResuming,\n            manager: this.manager,\n            store: this.store,\n            stream: this.stream,\n        });\n        this.tasks = nextTasks;\n        // Produce debug output\n        if (this.checkpointer) {\n            this._emit(await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugCheckpoint)(this.step - 1, // printing checkpoint for previous step\n            this.checkpointConfig, this.channels, this.streamKeys, this.checkpointMetadata, Object.values(this.tasks), this.checkpointPendingWrites, this.prevCheckpointConfig), \"debug\")));\n        }\n        if (Object.values(this.tasks).length === 0) {\n            this.status = \"done\";\n            return false;\n        }\n        // if there are pending writes from a previous loop, apply them\n        if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n            for (const [tid, k, v] of this.checkpointPendingWrites) {\n                if (k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME) {\n                    continue;\n                }\n                const task = Object.values(this.tasks).find((t) => t.id === tid);\n                if (task) {\n                    task.writes.push([k, v]);\n                }\n            }\n            for (const task of Object.values(this.tasks)) {\n                if (task.writes.length > 0) {\n                    this._outputWrites(task.id, task.writes, true);\n                }\n            }\n        }\n        // if all tasks have finished, re-tick\n        if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n            return this.tick({ inputKeys });\n        }\n        // Before execution, check if we should interrupt\n        if ((0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptBefore, Object.values(this.tasks))) {\n            this.status = \"interrupt_before\";\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.GraphInterrupt();\n        }\n        // Produce debug output\n        const debugOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTasks)(this.step, Object.values(this.tasks)), \"debug\"));\n        this._emit(debugOutput);\n        return true;\n    }\n    async finishAndHandleError(error) {\n        const suppress = this._suppressInterrupt(error);\n        if (suppress || error === undefined) {\n            this.output = (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.readChannels)(this.channels, this.outputKeys);\n        }\n        if (suppress) {\n            // emit one last \"values\" event, with pending writes applied\n            if (this.tasks !== undefined &&\n                this.checkpointPendingWrites.length > 0 &&\n                Object.values(this.tasks).some((task) => task.writes.length > 0)) {\n                const managedValueWrites = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion);\n                for (const [key, values] of Object.entries(managedValueWrites)) {\n                    await this.updateManagedValues(key, values);\n                }\n                this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, Object.values(this.tasks).flatMap((t) => t.writes), this.channels), \"values\")));\n            }\n            // Emit INTERRUPT event\n            this._emit([\n                [\n                    \"updates\",\n                    {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT]: error.interrupts,\n                    },\n                ],\n            ]);\n        }\n        return suppress;\n    }\n    acceptPush(task, writeIdx, call) {\n        if (this.interruptAfter?.length > 0 &&\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptAfter, [task])) {\n            this.toInterrupt.push(task);\n            return;\n        }\n        const pushed = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareSingleTask)([_constants_js__WEBPACK_IMPORTED_MODULE_2__.PUSH, task.path ?? [], writeIdx, task.id, call], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, task.config ?? {}, true, {\n            step: this.step,\n            checkpointer: this.checkpointer,\n            manager: this.manager,\n            store: this.store,\n            stream: this.stream,\n        });\n        if (pushed) {\n            if (this.interruptBefore?.length > 0 &&\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__.shouldInterrupt)(this.checkpoint, this.interruptBefore, [pushed])) {\n                this.toInterrupt.push(pushed);\n                return;\n            }\n            this._emit((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIteratorSync)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.mapDebugTasks)(this.step, [pushed]), \"debug\")));\n            if (this.debug) {\n                (0,_debug_js__WEBPACK_IMPORTED_MODULE_8__.printStepTasks)(this.step, [pushed]);\n            }\n            this.tasks[pushed.id] = pushed;\n            if (this.skipDoneTasks) {\n                this._matchWrites({ [pushed.id]: pushed });\n            }\n            return pushed;\n        }\n    }\n    _suppressInterrupt(e) {\n        return (0,_errors_js__WEBPACK_IMPORTED_MODULE_6__.isGraphInterrupt)(e) && !this.isNested;\n    }\n    async _first(inputKeys) {\n        /*\n         * Resuming from previous checkpoint requires\n         * - finding a previous checkpoint\n         * - receiving null input (outer graph) or RESUMING flag (subgraph)\n         */\n        const { configurable } = this.config;\n        // take resume value from parent\n        const scratchpad = configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n        if (scratchpad && scratchpad.nullResume !== undefined) {\n            this.putWrites(_constants_js__WEBPACK_IMPORTED_MODULE_2__.NULL_TASK_ID, [[_constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME, scratchpad.nullResume]]);\n        }\n        if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input)) {\n            const hasResume = this.input.resume != null;\n            if (hasResume && this.checkpointer == null) {\n                throw new Error(\"Cannot use Command(resume=...) without checkpointer\");\n            }\n            const writes = {};\n            // group writes by task id\n            for (const [tid, key, value] of (0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapCommand)(this.input, this.checkpointPendingWrites)) {\n                if (writes[tid] === undefined) {\n                    writes[tid] = [];\n                }\n                writes[tid].push([key, value]);\n            }\n            if (Object.keys(writes).length === 0) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyInputError(\"Received empty Command input\");\n            }\n            // save writes\n            for (const [tid, ws] of Object.entries(writes)) {\n                this.putWrites(tid, ws);\n            }\n        }\n        // apply null writes\n        const nullWrites = (this.checkpointPendingWrites ?? [])\n            .filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.NULL_TASK_ID)\n            .map((w) => w.slice(1));\n        if (nullWrites.length > 0) {\n            (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, [\n                {\n                    name: _constants_js__WEBPACK_IMPORTED_MODULE_2__.INPUT,\n                    writes: nullWrites,\n                    triggers: [],\n                },\n            ], this.checkpointerGetNextVersion);\n        }\n        const isCommandUpdateOrGoto = (0,_constants_js__WEBPACK_IMPORTED_MODULE_2__.isCommand)(this.input) && nullWrites.length > 0;\n        if (this.isResuming || isCommandUpdateOrGoto) {\n            for (const channelName of Object.keys(this.channels)) {\n                if (this.checkpoint.channel_versions[channelName] !== undefined) {\n                    const version = this.checkpoint.channel_versions[channelName];\n                    this.checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT] = {\n                        ...this.checkpoint.versions_seen[_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT],\n                        [channelName]: version,\n                    };\n                }\n            }\n            // produce values output\n            const valuesOutput = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixGenerator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapOutputValues)(this.outputKeys, true, this.channels), \"values\"));\n            this._emit(valuesOutput);\n        }\n        if (this.isResuming) {\n            this.input = INPUT_RESUMING;\n        }\n        else if (isCommandUpdateOrGoto) {\n            // we need to create a new checkpoint for Command(update=...) or Command(goto=...)\n            // in case the result of Command(goto=...) is an interrupt.\n            // If not done, the checkpoint containing the interrupt will be lost.\n            await this._putCheckpoint({ source: \"input\", writes: {} });\n            this.input = INPUT_DONE;\n        }\n        else {\n            // map inputs to channel updates\n            const inputWrites = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.gatherIterator)((0,_io_js__WEBPACK_IMPORTED_MODULE_5__.mapInput)(inputKeys, this.input));\n            if (inputWrites.length > 0) {\n                const discardTasks = (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._prepareNextTasks)(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.managed, this.config, true, { step: this.step });\n                (0,_algo_js__WEBPACK_IMPORTED_MODULE_3__._applyWrites)(this.checkpoint, this.channels, Object.values(discardTasks).concat([\n                    {\n                        name: _constants_js__WEBPACK_IMPORTED_MODULE_2__.INPUT,\n                        writes: inputWrites,\n                        triggers: [],\n                    },\n                ]), this.checkpointerGetNextVersion);\n                // save input checkpoint\n                await this._putCheckpoint({\n                    source: \"input\",\n                    writes: Object.fromEntries(inputWrites),\n                });\n                this.input = INPUT_DONE;\n            }\n            else if (!(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.EmptyInputError(`Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`);\n            }\n            else {\n                // done with input\n                this.input = INPUT_DONE;\n            }\n        }\n        if (!this.isNested) {\n            this.config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.patchConfigurable)(this.config, {\n                [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_RESUMING]: this.isResuming,\n            });\n        }\n    }\n    _emit(values) {\n        for (const chunk of values) {\n            if (this.stream.modes.has(chunk[0])) {\n                this.stream.push([this.checkpointNamespace, ...chunk]);\n            }\n        }\n    }\n    async _putCheckpoint(inputMetadata) {\n        // Assign step\n        const metadata = {\n            ...inputMetadata,\n            step: this.step,\n            parents: this.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n        };\n        // Bail if no checkpointer\n        if (this.checkpointer !== undefined) {\n            // store the previous checkpoint config for debug events\n            this.prevCheckpointConfig = this.checkpointConfig?.configurable\n                ?.checkpoint_id\n                ? this.checkpointConfig\n                : undefined;\n            // create new checkpoint\n            this.checkpointMetadata = metadata;\n            // child graphs keep at most one checkpoint per parent checkpoint\n            // this is achieved by writing child checkpoints as progress is made\n            // (so that error recovery / resuming from interrupt don't lose work)\n            // but doing so always with an id equal to that of the parent checkpoint\n            this.checkpoint = (0,_channels_base_js__WEBPACK_IMPORTED_MODULE_1__.createCheckpoint)(this.checkpoint, this.channels, this.step);\n            this.checkpointConfig = {\n                ...this.checkpointConfig,\n                configurable: {\n                    ...this.checkpointConfig.configurable,\n                    checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n                },\n            };\n            const channelVersions = { ...this.checkpoint.channel_versions };\n            const newVersions = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.getNewChannelVersions)(this.checkpointPreviousVersions, channelVersions);\n            this.checkpointPreviousVersions = channelVersions;\n            // save it, without blocking\n            // if there's a previous checkpoint save in progress, wait for it\n            // ensuring checkpointers receive checkpoints in order\n            void this._checkpointerPutAfterPrevious({\n                config: { ...this.checkpointConfig },\n                checkpoint: (0,_langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint)(this.checkpoint),\n                metadata: { ...this.checkpointMetadata },\n                newVersions,\n            });\n            this.checkpointConfig = {\n                ...this.checkpointConfig,\n                configurable: {\n                    ...this.checkpointConfig.configurable,\n                    checkpoint_id: this.checkpoint.id,\n                },\n            };\n        }\n        this.step += 1;\n    }\n    _matchWrites(tasks) {\n        for (const [tid, k, v] of this.checkpointPendingWrites) {\n            if (k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT || k === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME) {\n                continue;\n            }\n            const task = Object.values(tasks).find((t) => t.id === tid);\n            if (task) {\n                task.writes.push([k, v]);\n            }\n        }\n        for (const task of Object.values(tasks)) {\n            if (task.writes.length > 0) {\n                this._outputWrites(task.id, task.writes, true);\n            }\n        }\n    }\n}\n//# sourceMappingURL=loop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9sb29wLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNIO0FBQy9DO0FBQzRNO0FBQ3RLO0FBQzFCO0FBQ2M7QUFDZjtBQUNOO0FBQ3lCO0FBQ3hDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzRUFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUVBQWlFLDhEQUFtQjtBQUNwRixxRkFBcUYsOERBQW1CO0FBQ3hHO0FBQ0EsdUNBQXVDLHdEQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLCtDQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLGtDQUFrQyw0REFBaUI7QUFDbkQsb0VBQW9FLDREQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnRUFBcUI7QUFDdEU7QUFDQTtBQUNBLHlCQUF5QixrRUFBaUI7QUFDMUMscUJBQXFCLG1FQUF3QjtBQUM3Qyw0Q0FBNEMsbUVBQXdCO0FBQ3BFO0FBQ0EsMkJBQTJCLHlFQUE4QjtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFlLDhCQUE4QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyxvRUFBeUI7QUFDM0Qsa0NBQWtDLG9FQUF5QjtBQUMzRCwrQkFBK0Isa0VBQWlCO0FBQ2hELG1EQUFtRCxvRUFBeUI7QUFDNUUsYUFBYTtBQUNiO0FBQ0EsOEVBQThFLHlFQUE4QjtBQUM1RztBQUNBO0FBQ0Esd0JBQXdCLGdGQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQiwrRUFBYztBQUN6QyxxQ0FBcUM7QUFDckM7QUFDQSx5QkFBeUIsZ0VBQWE7QUFDdEM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGtCQUFrQiw4RUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyRUFBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJFQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxREFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQUs7QUFDdEMsaUNBQWlDLG9EQUFTO0FBQzFDLDJCQUEyQiw2REFBa0IsQ0FBQywwREFBZSxDQUFDLHdEQUFnQjtBQUM5RTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFrQixDQUFDLDBEQUFlLENBQUMsOERBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxnR0FBZ0csWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzREFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBYyxDQUFDLDBEQUFlLENBQUMsdURBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBZ0I7QUFDeEMsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLHlEQUFlO0FBQy9CO0FBQ0EsMEJBQTBCLHNEQUFjO0FBQ3hDO0FBQ0E7QUFDQSwyQ0FBMkMsOERBQW1CO0FBQzlELGtEQUFrRCw4REFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFjLENBQUMsMERBQWUsQ0FBQyw2REFBa0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFLLFVBQVUsb0RBQVMsVUFBVSxpREFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsWUFBWSx5REFBZTtBQUMzQjtBQUNBLHNCQUFzQixzREFBYztBQUNwQztBQUNBO0FBQ0Esa0NBQWtDLHlEQUFjLENBQUMsMERBQWUsQ0FBQyx3REFBYTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNEQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBa0IsQ0FBQywwREFBZSxDQUFDLHVEQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBUztBQUNsQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBa0IsRUFBRSwrQ0FBSSxzSkFBc0o7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2REFBa0IsQ0FBQywwREFBZSxDQUFDLHdEQUFhO0FBQ3ZFO0FBQ0EsZ0JBQWdCLHlEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSwwQ0FBMEMsZ0VBQXFCO0FBQy9EO0FBQ0EsMkJBQTJCLHVEQUFZLElBQUksaURBQU07QUFDakQ7QUFDQSxZQUFZLHdEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrREFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1REFBWTtBQUNoRDtBQUNBO0FBQ0EsWUFBWSxzREFBWTtBQUN4QjtBQUNBLDBCQUEwQixnREFBSztBQUMvQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0RBQVM7QUFDM0QseURBQXlELG9EQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQWMsQ0FBQywwREFBZSxDQUFDLHVEQUFlO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseURBQWMsQ0FBQyxnREFBUTtBQUM3RDtBQUNBLHFDQUFxQywyREFBaUIsOEdBQThHLGlCQUFpQjtBQUNyTCxnQkFBZ0Isc0RBQVk7QUFDNUI7QUFDQSw4QkFBOEIsZ0RBQUs7QUFDbkM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx1QkFBdUIsOERBQW1CLG1DQUFtQztBQUM3RSwwQkFBMEIsdURBQWUsaUNBQWlDLG1DQUFtQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBaUI7QUFDM0MsaUJBQWlCLDhEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvRUFBeUIsT0FBTztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1FQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0NBQXNDO0FBQ3RDLGdDQUFnQyxzRUFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQsNEJBQTRCLCtFQUFjO0FBQzFDLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQUssVUFBVSxvREFBUyxVQUFVLGlEQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9sb29wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcHlDaGVja3BvaW50LCBlbXB0eUNoZWNrcG9pbnQsIEFzeW5jQmF0Y2hlZFN0b3JlLCBXUklURVNfSURYX01BUCwgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2hlY2twb2ludCwgZW1wdHlDaGFubmVscywgfSBmcm9tIFwiLi4vY2hhbm5lbHMvYmFzZS5qc1wiO1xuaW1wb3J0IHsgaXNDb21tYW5kLCBDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IsIENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVAsIENPTkZJR19LRVlfUkVBRCwgQ09ORklHX0tFWV9SRVNVTUlORywgQ09ORklHX0tFWV9TVFJFQU0sIEVSUk9SLCBJTlBVVCwgSU5URVJSVVBULCBOVUxMX1RBU0tfSUQsIFJFU1VNRSwgVEFHX0hJRERFTiwgUFVTSCwgQ09ORklHX0tFWV9TQ1JBVENIUEFELCBDT05GSUdfS0VZX0NIRUNLUE9JTlRfTlMsIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgX2FwcGx5V3JpdGVzLCBfcHJlcGFyZU5leHRUYXNrcywgX3ByZXBhcmVTaW5nbGVUYXNrLCBpbmNyZW1lbnQsIHNob3VsZEludGVycnVwdCwgfSBmcm9tIFwiLi9hbGdvLmpzXCI7XG5pbXBvcnQgeyBnYXRoZXJJdGVyYXRvciwgZ2F0aGVySXRlcmF0b3JTeW5jLCBwcmVmaXhHZW5lcmF0b3IsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBtYXBDb21tYW5kLCBtYXBJbnB1dCwgbWFwT3V0cHV0VXBkYXRlcywgbWFwT3V0cHV0VmFsdWVzLCByZWFkQ2hhbm5lbHMsIH0gZnJvbSBcIi4vaW8uanNcIjtcbmltcG9ydCB7IEVtcHR5SW5wdXRFcnJvciwgR3JhcGhJbnRlcnJ1cHQsIGlzR3JhcGhJbnRlcnJ1cHQsIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0TmV3Q2hhbm5lbFZlcnNpb25zLCBwYXRjaENvbmZpZ3VyYWJsZSB9IGZyb20gXCIuL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBtYXBEZWJ1Z1Rhc2tzLCBtYXBEZWJ1Z0NoZWNrcG9pbnQsIG1hcERlYnVnVGFza1Jlc3VsdHMsIHByaW50U3RlcFRhc2tzLCB9IGZyb20gXCIuL2RlYnVnLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlV3JpdGFibGVTdHJlYW0gfSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcbmNvbnN0IElOUFVUX0RPTkUgPSBTeW1ib2wuZm9yKFwiSU5QVVRfRE9ORVwiKTtcbmNvbnN0IElOUFVUX1JFU1VNSU5HID0gU3ltYm9sLmZvcihcIklOUFVUX1JFU1VNSU5HXCIpO1xuY29uc3QgREVGQVVMVF9MT09QX0xJTUlUID0gMjU7XG5mdW5jdGlvbiBjcmVhdGVEdXBsZXhTdHJlYW0oLi4uc3RyZWFtcykge1xuICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgcGFzc3Rocm91Z2hGbjogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5tb2Rlcy5oYXModmFsdWVbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGVzOiBuZXcgU2V0KHN0cmVhbXMuZmxhdE1hcCgocykgPT4gQXJyYXkuZnJvbShzLm1vZGVzKSkpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIFByZWdlbExvb3Age1xuICAgIGdldCBpc1Jlc3VtaW5nKCkge1xuICAgICAgICBjb25zdCBoYXNDaGFubmVsVmVyc2lvbnMgPSBPYmplY3Qua2V5cyh0aGlzLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9ucykubGVuZ3RoICE9PSAwO1xuICAgICAgICBjb25zdCBjb25maWdIYXNSZXN1bWluZ0ZsYWcgPSB0aGlzLmNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1JFU1VNSU5HXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjb25maWdJc1Jlc3VtaW5nID0gY29uZmlnSGFzUmVzdW1pbmdGbGFnICYmIHRoaXMuY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfUkVTVU1JTkddO1xuICAgICAgICBjb25zdCBpbnB1dElzTnVsbE9yVW5kZWZpbmVkID0gdGhpcy5pbnB1dCA9PT0gbnVsbCB8fCB0aGlzLmlucHV0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlucHV0SXNDb21tYW5kUmVzdW1pbmcgPSBpc0NvbW1hbmQodGhpcy5pbnB1dCkgJiYgdGhpcy5pbnB1dC5yZXN1bWUgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaW5wdXRJc1Jlc3VtaW5nID0gdGhpcy5pbnB1dCA9PT0gSU5QVVRfUkVTVU1JTkc7XG4gICAgICAgIHJldHVybiAoaGFzQ2hhbm5lbFZlcnNpb25zICYmXG4gICAgICAgICAgICAoY29uZmlnSXNSZXN1bWluZyB8fFxuICAgICAgICAgICAgICAgIGlucHV0SXNOdWxsT3JVbmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBpbnB1dElzQ29tbWFuZFJlc3VtaW5nIHx8XG4gICAgICAgICAgICAgICAgaW5wdXRJc1Jlc3VtaW5nKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50ZXJHZXROZXh0VmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYW5hZ2VkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludENvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50TWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hlY2twb2ludE5hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50UGVuZGluZ1dyaXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRLZXlzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbUtleXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2tpcERvbmVUYXNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcmV2Q2hlY2twb2ludENvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwicGVuZGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YXNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja3BvaW50ZXJQcm9taXNlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzTmVzdGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGVja3BvaW50ZXJDaGFpbmVkUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hbmFnZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJydXB0QWZ0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJydXB0QmVmb3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvSW50ZXJydXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVidWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlucHV0ID0gcGFyYW1zLmlucHV0O1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRlciA9IHBhcmFtcy5jaGVja3BvaW50ZXI7XG4gICAgICAgIC8vIFRPRE86IGlmIG1hbmFnZWQgdmFsdWVzIG5vIGxvbmdlciBuZWVkcyBncmFwaCB3ZSBjYW4gcmVwbGFjZSB3aXRoXG4gICAgICAgIC8vIG1hbmFnZWRfc3BlY3MsIGNoYW5uZWxfc3BlY3NcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24gPSB0aGlzLmNoZWNrcG9pbnRlci5nZXROZXh0VmVyc2lvbi5iaW5kKHRoaXMuY2hlY2twb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24gPSBpbmNyZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja3BvaW50ID0gcGFyYW1zLmNoZWNrcG9pbnQ7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludE1ldGFkYXRhID0gcGFyYW1zLmNoZWNrcG9pbnRNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucyA9IHBhcmFtcy5jaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucztcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHBhcmFtcy5jaGFubmVscztcbiAgICAgICAgdGhpcy5tYW5hZ2VkID0gcGFyYW1zLm1hbmFnZWQ7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMgPSBwYXJhbXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXM7XG4gICAgICAgIHRoaXMuc3RlcCA9IHBhcmFtcy5zdGVwO1xuICAgICAgICB0aGlzLnN0b3AgPSBwYXJhbXMuc3RvcDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBwYXJhbXMuY29uZmlnO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRDb25maWcgPSBwYXJhbXMuY2hlY2twb2ludENvbmZpZztcbiAgICAgICAgdGhpcy5pc05lc3RlZCA9IHBhcmFtcy5pc05lc3RlZDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gcGFyYW1zLm1hbmFnZXI7XG4gICAgICAgIHRoaXMub3V0cHV0S2V5cyA9IHBhcmFtcy5vdXRwdXRLZXlzO1xuICAgICAgICB0aGlzLnN0cmVhbUtleXMgPSBwYXJhbXMuc3RyZWFtS2V5cztcbiAgICAgICAgdGhpcy5ub2RlcyA9IHBhcmFtcy5ub2RlcztcbiAgICAgICAgdGhpcy5za2lwRG9uZVRhc2tzID0gcGFyYW1zLnNraXBEb25lVGFza3M7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBwYXJhbXMuc3RvcmU7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gcGFyYW1zLnN0cmVhbTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50TmFtZXNwYWNlID0gcGFyYW1zLmNoZWNrcG9pbnROYW1lc3BhY2U7XG4gICAgICAgIHRoaXMucHJldkNoZWNrcG9pbnRDb25maWcgPSBwYXJhbXMucHJldkNoZWNrcG9pbnRDb25maWc7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0QWZ0ZXIgPSBwYXJhbXMuaW50ZXJydXB0QWZ0ZXI7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0QmVmb3JlID0gcGFyYW1zLmludGVycnVwdEJlZm9yZTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHBhcmFtcy5kZWJ1ZztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgICAgIGxldCB7IGNvbmZpZywgc3RyZWFtIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChzdHJlYW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfU1RSRUFNXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBjcmVhdGVEdXBsZXhTdHJlYW0oc3RyZWFtLCBjb25maWcuY29uZmlndXJhYmxlW0NPTkZJR19LRVlfU1RSRUFNXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcERvbmVUYXNrcyA9IGNvbmZpZy5jb25maWd1cmFibGVcbiAgICAgICAgICAgID8gIShcImNoZWNrcG9pbnRfaWRcIiBpbiBjb25maWcuY29uZmlndXJhYmxlKVxuICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICBjb25zdCBzY3JhdGNocGFkID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfU0NSQVRDSFBBRF07XG4gICAgICAgIGlmIChjb25maWcuY29uZmlndXJhYmxlICYmIHNjcmF0Y2hwYWQpIHtcbiAgICAgICAgICAgIGlmIChzY3JhdGNocGFkLnN1YmdyYXBoQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0hFQ0tQT0lOVF9OU106IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGVbQ09ORklHX0tFWV9DSEVDS1BPSU5UX05TXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hwYWQuc3ViZ3JhcGhDb3VudGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyYXRjaHBhZC5zdWJncmFwaENvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc05lc3RlZCA9IENPTkZJR19LRVlfUkVBRCBpbiAoY29uZmlnLmNvbmZpZ3VyYWJsZSA/PyB7fSk7XG4gICAgICAgIGlmICghaXNOZXN0ZWQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWd1cmFibGU/LmNoZWNrcG9pbnRfbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyAhPT0gXCJcIikge1xuICAgICAgICAgICAgY29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogXCJcIixcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hlY2twb2ludENvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0NIRUNLUE9JTlRfTUFQXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF0/Lltjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zXSkge1xuICAgICAgICAgICAgY2hlY2twb2ludENvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IGNvbmZpZy5jb25maWd1cmFibGVbQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF1bY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9uc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja3BvaW50TmFtZXNwYWNlID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucz8uc3BsaXQoQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SKSA/PyBbXTtcbiAgICAgICAgY29uc3Qgc2F2ZWQgPSAoYXdhaXQgcGFyYW1zLmNoZWNrcG9pbnRlcj8uZ2V0VHVwbGUoY2hlY2twb2ludENvbmZpZykpID8/IHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IGVtcHR5Q2hlY2twb2ludCgpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICBzdGVwOiAtMixcbiAgICAgICAgICAgICAgICB3cml0ZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyZW50czoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGVuZGluZ1dyaXRlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrcG9pbnRDb25maWcgPSB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICAuLi5zYXZlZC5jb25maWcsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICBjaGVja3BvaW50X25zOiBcIlwiLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgLi4uc2F2ZWQuY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZDaGVja3BvaW50Q29uZmlnID0gc2F2ZWQucGFyZW50Q29uZmlnO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50ID0gY29weUNoZWNrcG9pbnQoc2F2ZWQuY2hlY2twb2ludCk7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRNZXRhZGF0YSA9IHsgLi4uc2F2ZWQubWV0YWRhdGEgfTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludFBlbmRpbmdXcml0ZXMgPSBzYXZlZC5wZW5kaW5nV3JpdGVzID8/IFtdO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGVtcHR5Q2hhbm5lbHMocGFyYW1zLmNoYW5uZWxTcGVjcywgY2hlY2twb2ludCk7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAoY2hlY2twb2ludE1ldGFkYXRhLnN0ZXAgPz8gMCkgKyAxO1xuICAgICAgICBjb25zdCBzdG9wID0gc3RlcCArIChjb25maWcucmVjdXJzaW9uTGltaXQgPz8gREVGQVVMVF9MT09QX0xJTUlUKSArIDE7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zID0geyAuLi5jaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnMgfTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwYXJhbXMuc3RvcmVcbiAgICAgICAgICAgID8gbmV3IEFzeW5jQmF0Y2hlZFN0b3JlKHBhcmFtcy5zdG9yZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBzdG9yZS4gVGhpcyBpcyBhIGJhdGNoIHN0b3JlLCBzbyBpdCB3aWxsIHJ1biBjb250aW51b3VzbHlcbiAgICAgICAgICAgIHN0b3JlLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcmVnZWxMb29wKHtcbiAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjaGVja3BvaW50ZXI6IHBhcmFtcy5jaGVja3BvaW50ZXIsXG4gICAgICAgICAgICBjaGVja3BvaW50LFxuICAgICAgICAgICAgY2hlY2twb2ludE1ldGFkYXRhLFxuICAgICAgICAgICAgY2hlY2twb2ludENvbmZpZyxcbiAgICAgICAgICAgIHByZXZDaGVja3BvaW50Q29uZmlnLFxuICAgICAgICAgICAgY2hlY2twb2ludE5hbWVzcGFjZSxcbiAgICAgICAgICAgIGNoYW5uZWxzLFxuICAgICAgICAgICAgbWFuYWdlZDogcGFyYW1zLm1hbmFnZWQsXG4gICAgICAgICAgICBpc05lc3RlZCxcbiAgICAgICAgICAgIG1hbmFnZXI6IHBhcmFtcy5tYW5hZ2VyLFxuICAgICAgICAgICAgc2tpcERvbmVUYXNrcyxcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICBzdG9wLFxuICAgICAgICAgICAgY2hlY2twb2ludFByZXZpb3VzVmVyc2lvbnMsXG4gICAgICAgICAgICBjaGVja3BvaW50UGVuZGluZ1dyaXRlcyxcbiAgICAgICAgICAgIG91dHB1dEtleXM6IHBhcmFtcy5vdXRwdXRLZXlzID8/IFtdLFxuICAgICAgICAgICAgc3RyZWFtS2V5czogcGFyYW1zLnN0cmVhbUtleXMgPz8gW10sXG4gICAgICAgICAgICBub2RlczogcGFyYW1zLm5vZGVzLFxuICAgICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBpbnRlcnJ1cHRBZnRlcjogcGFyYW1zLmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgaW50ZXJydXB0QmVmb3JlOiBwYXJhbXMuaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgZGVidWc6IHBhcmFtcy5kZWJ1ZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jaGVja3BvaW50ZXJQdXRBZnRlclByZXZpb3VzKGlucHV0KSB7XG4gICAgICAgIHRoaXMuX2NoZWNrcG9pbnRlckNoYWluZWRQcm9taXNlID0gdGhpcy5fY2hlY2twb2ludGVyQ2hhaW5lZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja3BvaW50ZXI/LnB1dChpbnB1dC5jb25maWcsIGlucHV0LmNoZWNrcG9pbnQsIGlucHV0Lm1ldGFkYXRhLCBpbnB1dC5uZXdWZXJzaW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRlclByb21pc2VzLnB1c2godGhpcy5fY2hlY2twb2ludGVyQ2hhaW5lZFByb21pc2UpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHVwZGF0ZU1hbmFnZWRWYWx1ZXMoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbXYgPSB0aGlzLm1hbmFnZWQuZ2V0KGtleSk7XG4gICAgICAgIGlmIChtdiAmJiBcInVwZGF0ZVwiIGluIG12ICYmIHR5cGVvZiBtdi51cGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXdhaXQgbXYudXBkYXRlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0IHdyaXRlcyBmb3IgYSB0YXNrLCB0byBiZSByZWFkIGJ5IHRoZSBuZXh0IHRpY2suXG4gICAgICogQHBhcmFtIHRhc2tJZFxuICAgICAqIEBwYXJhbSB3cml0ZXNcbiAgICAgKi9cbiAgICBwdXRXcml0ZXModGFza0lkLCB3cml0ZXMpIHtcbiAgICAgICAgbGV0IHdyaXRlc0NvcHkgPSB3cml0ZXM7XG4gICAgICAgIGlmICh3cml0ZXNDb3B5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZHVwbGljYXRlIHdyaXRlcyB0byBzcGVjaWFsIGNoYW5uZWxzLCBsYXN0IHdyaXRlIHdpbnNcbiAgICAgICAgaWYgKHdyaXRlc0NvcHkuZXZlcnkoKFtrZXldKSA9PiBrZXkgaW4gV1JJVEVTX0lEWF9NQVApKSB7XG4gICAgICAgICAgICB3cml0ZXNDb3B5ID0gQXJyYXkuZnJvbShuZXcgTWFwKHdyaXRlc0NvcHkubWFwKCh3KSA9PiBbd1swXSwgd10pKS52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSB3cml0ZXNcbiAgICAgICAgZm9yIChjb25zdCBbYywgdl0gb2Ygd3JpdGVzQ29weSkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcy5maW5kSW5kZXgoKHcpID0+IHdbMF0gPT09IHRhc2tJZCAmJiB3WzFdID09PSBjKTtcbiAgICAgICAgICAgIGlmIChjIGluIFdSSVRFU19JRFhfTUFQICYmIGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzW2lkeF0gPSBbdGFza0lkLCBjLCB2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMucHVzaChbdGFza0lkLCBjLCB2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHV0V3JpdGVQcm9taXNlID0gdGhpcy5jaGVja3BvaW50ZXI/LnB1dFdyaXRlcyh7XG4gICAgICAgICAgICAuLi50aGlzLmNoZWNrcG9pbnRDb25maWcsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmNoZWNrcG9pbnRDb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfbnM6IHRoaXMuY29uZmlnLmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucyA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHRoaXMuY2hlY2twb2ludC5pZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIHdyaXRlc0NvcHksIHRhc2tJZCk7XG4gICAgICAgIGlmIChwdXRXcml0ZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50ZXJQcm9taXNlcy5wdXNoKHB1dFdyaXRlUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGFza3MpIHtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFdyaXRlcyh0YXNrSWQsIHdyaXRlc0NvcHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vdXRwdXRXcml0ZXModGFza0lkLCB3cml0ZXMsIGNhY2hlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLnRhc2tzW3Rhc2tJZF07XG4gICAgICAgIGlmICh0YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0YXNrLmNvbmZpZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgKHRhc2suY29uZmlnLnRhZ3MgPz8gW10pLmluY2x1ZGVzKFRBR19ISURERU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdyaXRlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgd3JpdGVzWzBdWzBdICE9PSBFUlJPUiAmJlxuICAgICAgICAgICAgICAgIHdyaXRlc1swXVswXSAhPT0gSU5URVJSVVBUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdChnYXRoZXJJdGVyYXRvclN5bmMocHJlZml4R2VuZXJhdG9yKG1hcE91dHB1dFVwZGF0ZXModGhpcy5vdXRwdXRLZXlzLCBbW3Rhc2ssIHdyaXRlc11dLCBjYWNoZWQpLCBcInVwZGF0ZXNcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdChnYXRoZXJJdGVyYXRvclN5bmMocHJlZml4R2VuZXJhdG9yKG1hcERlYnVnVGFza1Jlc3VsdHModGhpcy5zdGVwLCBbW3Rhc2ssIHdyaXRlc11dLCB0aGlzLnN0cmVhbUtleXMpLCBcImRlYnVnXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHNpbmdsZSBpdGVyYXRpb24gb2YgdGhlIFByZWdlbCBsb29wLlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBtb3JlIGl0ZXJhdGlvbnMgYXJlIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgYXN5bmMgdGljayhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmUgJiYgIXRoaXMuc3RvcmUuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlPy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5wdXRLZXlzID0gW10gfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdGljayB3aGVuIHN0YXR1cyBpcyBubyBsb25nZXIgXCJwZW5kaW5nXCIuIEN1cnJlbnQgc3RhdHVzOiBcIiR7dGhpcy5zdGF0dXN9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVtJTlBVVF9ET05FLCBJTlBVVF9SRVNVTUlOR10uaW5jbHVkZXModGhpcy5pbnB1dCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ZpcnN0KGlucHV0S2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50b0ludGVycnVwdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwiaW50ZXJydXB0X2JlZm9yZVwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoSW50ZXJydXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKS5ldmVyeSgodGFzaykgPT4gdGFzay53cml0ZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIGZpbmlzaCBzdXBlcnN0ZXBcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IE9iamVjdC52YWx1ZXModGhpcy50YXNrcykuZmxhdE1hcCgodCkgPT4gdC53cml0ZXMpO1xuICAgICAgICAgICAgLy8gQWxsIHRhc2tzIGhhdmUgZmluaXNoZWRcbiAgICAgICAgICAgIGNvbnN0IG1hbmFnZWRWYWx1ZVdyaXRlcyA9IF9hcHBseVdyaXRlcyh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hhbm5lbHMsIE9iamVjdC52YWx1ZXModGhpcy50YXNrcyksIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKG1hbmFnZWRWYWx1ZVdyaXRlcykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1hbmFnZWRWYWx1ZXMoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvZHVjZSB2YWx1ZXMgb3V0cHV0XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNPdXRwdXQgPSBhd2FpdCBnYXRoZXJJdGVyYXRvcihwcmVmaXhHZW5lcmF0b3IobWFwT3V0cHV0VmFsdWVzKHRoaXMub3V0cHV0S2V5cywgd3JpdGVzLCB0aGlzLmNoYW5uZWxzKSwgXCJ2YWx1ZXNcIikpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCh2YWx1ZXNPdXRwdXQpO1xuICAgICAgICAgICAgLy8gY2xlYXIgcGVuZGluZyB3cml0ZXNcbiAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3B1dENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJsb29wXCIsXG4gICAgICAgICAgICAgICAgd3JpdGVzOiBtYXBPdXRwdXRVcGRhdGVzKHRoaXMub3V0cHV0S2V5cywgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKS5tYXAoKHRhc2spID0+IFt0YXNrLCB0YXNrLndyaXRlc10pKS5uZXh0KCkudmFsdWUgPz8gbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWZ0ZXIgZXhlY3V0aW9uLCBjaGVjayBpZiB3ZSBzaG91bGQgaW50ZXJydXB0XG4gICAgICAgICAgICBpZiAoc2hvdWxkSW50ZXJydXB0KHRoaXMuY2hlY2twb2ludCwgdGhpcy5pbnRlcnJ1cHRBZnRlciwgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwiaW50ZXJydXB0X2FmdGVyXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoSW50ZXJydXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bnNldCByZXN1bWluZyBmbGFnXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9SRVNVTUlOR10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX1JFU1VNSU5HXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGVwID4gdGhpcy5zdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwib3V0X29mX3N0ZXBzXCI7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRhc2tzID0gX3ByZXBhcmVOZXh0VGFza3ModGhpcy5jaGVja3BvaW50LCB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLCB0aGlzLm5vZGVzLCB0aGlzLmNoYW5uZWxzLCB0aGlzLm1hbmFnZWQsIHRoaXMuY29uZmlnLCB0cnVlLCB7XG4gICAgICAgICAgICBzdGVwOiB0aGlzLnN0ZXAsXG4gICAgICAgICAgICBjaGVja3BvaW50ZXI6IHRoaXMuY2hlY2twb2ludGVyLFxuICAgICAgICAgICAgaXNSZXN1bWluZzogdGhpcy5pc1Jlc3VtaW5nLFxuICAgICAgICAgICAgbWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuICAgICAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICAgICAgICBzdHJlYW06IHRoaXMuc3RyZWFtLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YXNrcyA9IG5leHRUYXNrcztcbiAgICAgICAgLy8gUHJvZHVjZSBkZWJ1ZyBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KGF3YWl0IGdhdGhlckl0ZXJhdG9yKHByZWZpeEdlbmVyYXRvcihtYXBEZWJ1Z0NoZWNrcG9pbnQodGhpcy5zdGVwIC0gMSwgLy8gcHJpbnRpbmcgY2hlY2twb2ludCBmb3IgcHJldmlvdXMgc3RlcFxuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50Q29uZmlnLCB0aGlzLmNoYW5uZWxzLCB0aGlzLnN0cmVhbUtleXMsIHRoaXMuY2hlY2twb2ludE1ldGFkYXRhLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLCB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLCB0aGlzLnByZXZDaGVja3BvaW50Q29uZmlnKSwgXCJkZWJ1Z1wiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcImRvbmVcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgcGVuZGluZyB3cml0ZXMgZnJvbSBhIHByZXZpb3VzIGxvb3AsIGFwcGx5IHRoZW1cbiAgICAgICAgaWYgKHRoaXMuc2tpcERvbmVUYXNrcyAmJiB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RpZCwgaywgdl0gb2YgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBFUlJPUiB8fCBrID09PSBJTlRFUlJVUFQgfHwgayA9PT0gUkVTVU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKS5maW5kKCh0KSA9PiB0LmlkID09PSB0aWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sud3JpdGVzLnB1c2goW2ssIHZdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrLndyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFdyaXRlcyh0YXNrLmlkLCB0YXNrLndyaXRlcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFsbCB0YXNrcyBoYXZlIGZpbmlzaGVkLCByZS10aWNrXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLmV2ZXJ5KCh0YXNrKSA9PiB0YXNrLndyaXRlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGljayh7IGlucHV0S2V5cyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCZWZvcmUgZXhlY3V0aW9uLCBjaGVjayBpZiB3ZSBzaG91bGQgaW50ZXJydXB0XG4gICAgICAgIGlmIChzaG91bGRJbnRlcnJ1cHQodGhpcy5jaGVja3BvaW50LCB0aGlzLmludGVycnVwdEJlZm9yZSwgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJpbnRlcnJ1cHRfYmVmb3JlXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhJbnRlcnJ1cHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIGRlYnVnIG91dHB1dFxuICAgICAgICBjb25zdCBkZWJ1Z091dHB1dCA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKHByZWZpeEdlbmVyYXRvcihtYXBEZWJ1Z1Rhc2tzKHRoaXMuc3RlcCwgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKSksIFwiZGVidWdcIikpO1xuICAgICAgICB0aGlzLl9lbWl0KGRlYnVnT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGZpbmlzaEFuZEhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN1cHByZXNzID0gdGhpcy5fc3VwcHJlc3NJbnRlcnJ1cHQoZXJyb3IpO1xuICAgICAgICBpZiAoc3VwcHJlc3MgfHwgZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSByZWFkQ2hhbm5lbHModGhpcy5jaGFubmVscywgdGhpcy5vdXRwdXRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcHJlc3MpIHtcbiAgICAgICAgICAgIC8vIGVtaXQgb25lIGxhc3QgXCJ2YWx1ZXNcIiBldmVudCwgd2l0aCBwZW5kaW5nIHdyaXRlcyBhcHBsaWVkXG4gICAgICAgICAgICBpZiAodGhpcy50YXNrcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnRhc2tzKS5zb21lKCh0YXNrKSA9PiB0YXNrLndyaXRlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZWRWYWx1ZVdyaXRlcyA9IF9hcHBseVdyaXRlcyh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hhbm5lbHMsIE9iamVjdC52YWx1ZXModGhpcy50YXNrcyksIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBPYmplY3QuZW50cmllcyhtYW5hZ2VkVmFsdWVXcml0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlTWFuYWdlZFZhbHVlcyhrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoZ2F0aGVySXRlcmF0b3JTeW5jKHByZWZpeEdlbmVyYXRvcihtYXBPdXRwdXRWYWx1ZXModGhpcy5vdXRwdXRLZXlzLCBPYmplY3QudmFsdWVzKHRoaXMudGFza3MpLmZsYXRNYXAoKHQpID0+IHQud3JpdGVzKSwgdGhpcy5jaGFubmVscyksIFwidmFsdWVzXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IElOVEVSUlVQVCBldmVudFxuICAgICAgICAgICAgdGhpcy5fZW1pdChbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0lOVEVSUlVQVF06IGVycm9yLmludGVycnVwdHMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwcmVzcztcbiAgICB9XG4gICAgYWNjZXB0UHVzaCh0YXNrLCB3cml0ZUlkeCwgY2FsbCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnJ1cHRBZnRlcj8ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgc2hvdWxkSW50ZXJydXB0KHRoaXMuY2hlY2twb2ludCwgdGhpcy5pbnRlcnJ1cHRBZnRlciwgW3Rhc2tdKSkge1xuICAgICAgICAgICAgdGhpcy50b0ludGVycnVwdC5wdXNoKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hlZCA9IF9wcmVwYXJlU2luZ2xlVGFzayhbUFVTSCwgdGFzay5wYXRoID8/IFtdLCB3cml0ZUlkeCwgdGFzay5pZCwgY2FsbF0sIHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGVja3BvaW50UGVuZGluZ1dyaXRlcywgdGhpcy5ub2RlcywgdGhpcy5jaGFubmVscywgdGhpcy5tYW5hZ2VkLCB0YXNrLmNvbmZpZyA/PyB7fSwgdHJ1ZSwge1xuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGVwLFxuICAgICAgICAgICAgY2hlY2twb2ludGVyOiB0aGlzLmNoZWNrcG9pbnRlcixcbiAgICAgICAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlcixcbiAgICAgICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgICAgICAgc3RyZWFtOiB0aGlzLnN0cmVhbSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwdXNoZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVycnVwdEJlZm9yZT8ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHNob3VsZEludGVycnVwdCh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuaW50ZXJydXB0QmVmb3JlLCBbcHVzaGVkXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvSW50ZXJydXB0LnB1c2gocHVzaGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbWl0KGdhdGhlckl0ZXJhdG9yU3luYyhwcmVmaXhHZW5lcmF0b3IobWFwRGVidWdUYXNrcyh0aGlzLnN0ZXAsIFtwdXNoZWRdKSwgXCJkZWJ1Z1wiKSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBwcmludFN0ZXBUYXNrcyh0aGlzLnN0ZXAsIFtwdXNoZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFza3NbcHVzaGVkLmlkXSA9IHB1c2hlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBEb25lVGFza3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFdyaXRlcyh7IFtwdXNoZWQuaWRdOiBwdXNoZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdXBwcmVzc0ludGVycnVwdChlKSB7XG4gICAgICAgIHJldHVybiBpc0dyYXBoSW50ZXJydXB0KGUpICYmICF0aGlzLmlzTmVzdGVkO1xuICAgIH1cbiAgICBhc3luYyBfZmlyc3QoaW5wdXRLZXlzKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlc3VtaW5nIGZyb20gcHJldmlvdXMgY2hlY2twb2ludCByZXF1aXJlc1xuICAgICAgICAgKiAtIGZpbmRpbmcgYSBwcmV2aW91cyBjaGVja3BvaW50XG4gICAgICAgICAqIC0gcmVjZWl2aW5nIG51bGwgaW5wdXQgKG91dGVyIGdyYXBoKSBvciBSRVNVTUlORyBmbGFnIChzdWJncmFwaClcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgY29uZmlndXJhYmxlIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgLy8gdGFrZSByZXN1bWUgdmFsdWUgZnJvbSBwYXJlbnRcbiAgICAgICAgY29uc3Qgc2NyYXRjaHBhZCA9IGNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfU0NSQVRDSFBBRF07XG4gICAgICAgIGlmIChzY3JhdGNocGFkICYmIHNjcmF0Y2hwYWQubnVsbFJlc3VtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1dFdyaXRlcyhOVUxMX1RBU0tfSUQsIFtbUkVTVU1FLCBzY3JhdGNocGFkLm51bGxSZXN1bWVdXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29tbWFuZCh0aGlzLmlucHV0KSkge1xuICAgICAgICAgICAgY29uc3QgaGFzUmVzdW1lID0gdGhpcy5pbnB1dC5yZXN1bWUgIT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNSZXN1bWUgJiYgdGhpcy5jaGVja3BvaW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgQ29tbWFuZChyZXN1bWU9Li4uKSB3aXRob3V0IGNoZWNrcG9pbnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyaXRlcyA9IHt9O1xuICAgICAgICAgICAgLy8gZ3JvdXAgd3JpdGVzIGJ5IHRhc2sgaWRcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RpZCwga2V5LCB2YWx1ZV0gb2YgbWFwQ29tbWFuZCh0aGlzLmlucHV0LCB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzKSkge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZXNbdGlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlc1t0aWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlc1t0aWRdLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh3cml0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUlucHV0RXJyb3IoXCJSZWNlaXZlZCBlbXB0eSBDb21tYW5kIGlucHV0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2F2ZSB3cml0ZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RpZCwgd3NdIG9mIE9iamVjdC5lbnRyaWVzKHdyaXRlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dFdyaXRlcyh0aWQsIHdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBudWxsIHdyaXRlc1xuICAgICAgICBjb25zdCBudWxsV3JpdGVzID0gKHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMgPz8gW10pXG4gICAgICAgICAgICAuZmlsdGVyKCh3KSA9PiB3WzBdID09PSBOVUxMX1RBU0tfSUQpXG4gICAgICAgICAgICAubWFwKCh3KSA9PiB3LnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKG51bGxXcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgX2FwcGx5V3JpdGVzKHRoaXMuY2hlY2twb2ludCwgdGhpcy5jaGFubmVscywgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlczogbnVsbFdyaXRlcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLCB0aGlzLmNoZWNrcG9pbnRlckdldE5leHRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0NvbW1hbmRVcGRhdGVPckdvdG8gPSBpc0NvbW1hbmQodGhpcy5pbnB1dCkgJiYgbnVsbFdyaXRlcy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAodGhpcy5pc1Jlc3VtaW5nIHx8IGlzQ29tbWFuZFVwZGF0ZU9yR290bykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFubmVsTmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnQuY2hhbm5lbF92ZXJzaW9uc1tjaGFubmVsTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5jaGVja3BvaW50LmNoYW5uZWxfdmVyc2lvbnNbY2hhbm5lbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnQudmVyc2lvbnNfc2VlbltJTlRFUlJVUFRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jaGVja3BvaW50LnZlcnNpb25zX3NlZW5bSU5URVJSVVBUXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjaGFubmVsTmFtZV06IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvZHVjZSB2YWx1ZXMgb3V0cHV0XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNPdXRwdXQgPSBhd2FpdCBnYXRoZXJJdGVyYXRvcihwcmVmaXhHZW5lcmF0b3IobWFwT3V0cHV0VmFsdWVzKHRoaXMub3V0cHV0S2V5cywgdHJ1ZSwgdGhpcy5jaGFubmVscyksIFwidmFsdWVzXCIpKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQodmFsdWVzT3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1Jlc3VtaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gSU5QVVRfUkVTVU1JTkc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21tYW5kVXBkYXRlT3JHb3RvKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBjaGVja3BvaW50IGZvciBDb21tYW5kKHVwZGF0ZT0uLi4pIG9yIENvbW1hbmQoZ290bz0uLi4pXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSByZXN1bHQgb2YgQ29tbWFuZChnb3RvPS4uLikgaXMgYW4gaW50ZXJydXB0LlxuICAgICAgICAgICAgLy8gSWYgbm90IGRvbmUsIHRoZSBjaGVja3BvaW50IGNvbnRhaW5pbmcgdGhlIGludGVycnVwdCB3aWxsIGJlIGxvc3QuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wdXRDaGVja3BvaW50KHsgc291cmNlOiBcImlucHV0XCIsIHdyaXRlczoge30gfSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gSU5QVVRfRE9ORTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1hcCBpbnB1dHMgdG8gY2hhbm5lbCB1cGRhdGVzXG4gICAgICAgICAgICBjb25zdCBpbnB1dFdyaXRlcyA9IGF3YWl0IGdhdGhlckl0ZXJhdG9yKG1hcElucHV0KGlucHV0S2V5cywgdGhpcy5pbnB1dCkpO1xuICAgICAgICAgICAgaWYgKGlucHV0V3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNjYXJkVGFza3MgPSBfcHJlcGFyZU5leHRUYXNrcyh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hlY2twb2ludFBlbmRpbmdXcml0ZXMsIHRoaXMubm9kZXMsIHRoaXMuY2hhbm5lbHMsIHRoaXMubWFuYWdlZCwgdGhpcy5jb25maWcsIHRydWUsIHsgc3RlcDogdGhpcy5zdGVwIH0pO1xuICAgICAgICAgICAgICAgIF9hcHBseVdyaXRlcyh0aGlzLmNoZWNrcG9pbnQsIHRoaXMuY2hhbm5lbHMsIE9iamVjdC52YWx1ZXMoZGlzY2FyZFRhc2tzKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBJTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlczogaW5wdXRXcml0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSksIHRoaXMuY2hlY2twb2ludGVyR2V0TmV4dFZlcnNpb24pO1xuICAgICAgICAgICAgICAgIC8vIHNhdmUgaW5wdXQgY2hlY2twb2ludFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3B1dENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzOiBPYmplY3QuZnJvbUVudHJpZXMoaW5wdXRXcml0ZXMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBJTlBVVF9ET05FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShDT05GSUdfS0VZX1JFU1VNSU5HIGluICh0aGlzLmNvbmZpZy5jb25maWd1cmFibGUgPz8ge30pKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFbXB0eUlucHV0RXJyb3IoYFJlY2VpdmVkIG5vIGlucHV0IHdyaXRlcyBmb3IgJHtKU09OLnN0cmluZ2lmeShpbnB1dEtleXMsIG51bGwsIDIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uZSB3aXRoIGlucHV0XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IElOUFVUX0RPTkU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTmVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfUkVTVU1JTkddOiB0aGlzLmlzUmVzdW1pbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1pdCh2YWx1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5tb2Rlcy5oYXMoY2h1bmtbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucHVzaChbdGhpcy5jaGVja3BvaW50TmFtZXNwYWNlLCAuLi5jaHVua10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wdXRDaGVja3BvaW50KGlucHV0TWV0YWRhdGEpIHtcbiAgICAgICAgLy8gQXNzaWduIHN0ZXBcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5pbnB1dE1ldGFkYXRhLFxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGVwLFxuICAgICAgICAgICAgcGFyZW50czogdGhpcy5jb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF0gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIEJhaWwgaWYgbm8gY2hlY2twb2ludGVyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY2hlY2twb2ludCBjb25maWcgZm9yIGRlYnVnIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5wcmV2Q2hlY2twb2ludENvbmZpZyA9IHRoaXMuY2hlY2twb2ludENvbmZpZz8uY29uZmlndXJhYmxlXG4gICAgICAgICAgICAgICAgPy5jaGVja3BvaW50X2lkXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNoZWNrcG9pbnRDb25maWdcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY2hlY2twb2ludFxuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50TWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIC8vIGNoaWxkIGdyYXBocyBrZWVwIGF0IG1vc3Qgb25lIGNoZWNrcG9pbnQgcGVyIHBhcmVudCBjaGVja3BvaW50XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFjaGlldmVkIGJ5IHdyaXRpbmcgY2hpbGQgY2hlY2twb2ludHMgYXMgcHJvZ3Jlc3MgaXMgbWFkZVxuICAgICAgICAgICAgLy8gKHNvIHRoYXQgZXJyb3IgcmVjb3ZlcnkgLyByZXN1bWluZyBmcm9tIGludGVycnVwdCBkb24ndCBsb3NlIHdvcmspXG4gICAgICAgICAgICAvLyBidXQgZG9pbmcgc28gYWx3YXlzIHdpdGggYW4gaWQgZXF1YWwgdG8gdGhhdCBvZiB0aGUgcGFyZW50IGNoZWNrcG9pbnRcbiAgICAgICAgICAgIHRoaXMuY2hlY2twb2ludCA9IGNyZWF0ZUNoZWNrcG9pbnQodGhpcy5jaGVja3BvaW50LCB0aGlzLmNoYW5uZWxzLCB0aGlzLnN0ZXApO1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY2hlY2twb2ludENvbmZpZyxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jaGVja3BvaW50Q29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9uczogdGhpcy5jb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsVmVyc2lvbnMgPSB7IC4uLnRoaXMuY2hlY2twb2ludC5jaGFubmVsX3ZlcnNpb25zIH07XG4gICAgICAgICAgICBjb25zdCBuZXdWZXJzaW9ucyA9IGdldE5ld0NoYW5uZWxWZXJzaW9ucyh0aGlzLmNoZWNrcG9pbnRQcmV2aW91c1ZlcnNpb25zLCBjaGFubmVsVmVyc2lvbnMpO1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50UHJldmlvdXNWZXJzaW9ucyA9IGNoYW5uZWxWZXJzaW9ucztcbiAgICAgICAgICAgIC8vIHNhdmUgaXQsIHdpdGhvdXQgYmxvY2tpbmdcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwcmV2aW91cyBjaGVja3BvaW50IHNhdmUgaW4gcHJvZ3Jlc3MsIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAvLyBlbnN1cmluZyBjaGVja3BvaW50ZXJzIHJlY2VpdmUgY2hlY2twb2ludHMgaW4gb3JkZXJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fY2hlY2twb2ludGVyUHV0QWZ0ZXJQcmV2aW91cyh7XG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IC4uLnRoaXMuY2hlY2twb2ludENvbmZpZyB9LFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQ6IGNvcHlDaGVja3BvaW50KHRoaXMuY2hlY2twb2ludCksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHsgLi4udGhpcy5jaGVja3BvaW50TWV0YWRhdGEgfSxcbiAgICAgICAgICAgICAgICBuZXdWZXJzaW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jaGVja3BvaW50Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY2hlY2twb2ludENvbmZpZyxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jaGVja3BvaW50Q29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogdGhpcy5jaGVja3BvaW50LmlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcCArPSAxO1xuICAgIH1cbiAgICBfbWF0Y2hXcml0ZXModGFza3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBbdGlkLCBrLCB2XSBvZiB0aGlzLmNoZWNrcG9pbnRQZW5kaW5nV3JpdGVzKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gRVJST1IgfHwgayA9PT0gSU5URVJSVVBUIHx8IGsgPT09IFJFU1VNRSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFzayA9IE9iamVjdC52YWx1ZXModGFza3MpLmZpbmQoKHQpID0+IHQuaWQgPT09IHRpZCk7XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHRhc2sud3JpdGVzLnB1c2goW2ssIHZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgT2JqZWN0LnZhbHVlcyh0YXNrcykpIHtcbiAgICAgICAgICAgIGlmICh0YXNrLndyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0V3JpdGVzKHRhc2suaWQsIHRhc2sud3JpdGVzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb3AuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/loop.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/messages.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/messages.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StreamMessagesHandler: () => (/* binding */ StreamMessagesHandler)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_callbacks_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/callbacks/base */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/callbacks/base.js\");\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/messages */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/messages.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n\n\n\nfunction isChatGenerationChunk(x) {\n    return (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(x?.message);\n}\n/**\n * A callback handler that implements stream_mode=messages.\n * Collects messages from (1) chat model stream events and (2) node outputs.\n */\n// TODO: Make this import and explicitly implement the\n// CallbackHandlerPrefersStreaming interface once we drop support for core 0.2\nclass StreamMessagesHandler extends _langchain_core_callbacks_base__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n    constructor(streamFn) {\n        super();\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"StreamMessagesHandler\"\n        });\n        Object.defineProperty(this, \"streamFn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadatas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"seen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"emittedChatModelRunIds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"stableMessageIdMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.streamFn = streamFn;\n    }\n    _emit(meta, message, runId, dedupe = false) {\n        if (dedupe &&\n            message.id !== undefined &&\n            this.seen[message.id] !== undefined) {\n            return;\n        }\n        let messageId = message.id;\n        if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isToolMessage)(message)) {\n            // Distinguish tool messages by tool call ID.\n            messageId ??= `run-${runId}-tool-${message.tool_call_id}`;\n        }\n        else {\n            // For instance in ChatAnthropic, the first chunk has an message ID\n            // but the subsequent chunks do not. To avoid clients seeing two messages\n            // we rename the message ID if it's being auto-set to `run-${runId}`\n            // (see https://github.com/langchain-ai/langchainjs/pull/6646).\n            if (messageId == null || messageId === `run-${runId}`) {\n                messageId =\n                    this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;\n            }\n            this.stableMessageIdMap[runId] ??= messageId;\n        }\n        if (messageId !== message.id) {\n            // eslint-disable-next-line no-param-reassign\n            message.id = messageId;\n            // eslint-disable-next-line no-param-reassign\n            message.lc_kwargs.id = messageId;\n        }\n        if (message.id != null)\n            this.seen[message.id] = message;\n        this.streamFn([meta[0], \"messages\", [message, meta[1]]]);\n    }\n    handleChatModelStart(_llm, _messages, runId, _parentRunId, _extraParams, tags, metadata, name) {\n        if (metadata &&\n            // Include legacy LangGraph SDK tag\n            (!tags || (!tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_NOSTREAM) && !tags.includes(\"nostream\")))) {\n            this.metadatas[runId] = [\n                metadata.langgraph_checkpoint_ns.split(\"|\"),\n                { tags, name, ...metadata },\n            ];\n        }\n    }\n    handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, fields) {\n        const chunk = fields?.chunk;\n        this.emittedChatModelRunIds[runId] = true;\n        if (this.metadatas[runId] !== undefined) {\n            if (isChatGenerationChunk(chunk)) {\n                this._emit(this.metadatas[runId], chunk.message, runId);\n            }\n            else {\n                this._emit(this.metadatas[runId], new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.AIMessageChunk({ content: token }), runId);\n            }\n        }\n    }\n    handleLLMEnd(output, runId) {\n        // In JS, non-streaming runs do not call handleLLMNewToken at the model level\n        if (!this.emittedChatModelRunIds[runId]) {\n            const chatGeneration = output.generations?.[0]?.[0];\n            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(chatGeneration?.message)) {\n                this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);\n            }\n            delete this.emittedChatModelRunIds[runId];\n        }\n        delete this.metadatas[runId];\n        delete this.stableMessageIdMap[runId];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handleLLMError(_err, runId) {\n        delete this.metadatas[runId];\n    }\n    handleChainStart(_chain, inputs, runId, _parentRunId, tags, metadata, _runType, name) {\n        if (metadata !== undefined &&\n            name === metadata.langgraph_node &&\n            (tags === undefined || !tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN))) {\n            this.metadatas[runId] = [\n                metadata.langgraph_checkpoint_ns.split(\"|\"),\n                { tags, name, ...metadata },\n            ];\n            if (typeof inputs === \"object\") {\n                for (const value of Object.values(inputs)) {\n                    if (((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value) || (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk)(value)) &&\n                        value.id !== undefined) {\n                        this.seen[value.id] = value;\n                    }\n                    else if (Array.isArray(value)) {\n                        for (const item of value) {\n                            if (((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(item) || (0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk)(item)) &&\n                                item.id !== undefined) {\n                                this.seen[item.id] = item;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    handleChainEnd(outputs, runId) {\n        const metadata = this.metadatas[runId];\n        delete this.metadatas[runId];\n        if (metadata !== undefined) {\n            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(outputs)) {\n                this._emit(metadata, outputs, runId, true);\n            }\n            else if (Array.isArray(outputs)) {\n                for (const value of outputs) {\n                    if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value)) {\n                        this._emit(metadata, value, runId, true);\n                    }\n                }\n            }\n            else if (outputs != null && typeof outputs === \"object\") {\n                for (const value of Object.values(outputs)) {\n                    if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(value)) {\n                        this._emit(metadata, value, runId, true);\n                    }\n                    else if (Array.isArray(value)) {\n                        for (const item of value) {\n                            if ((0,_langchain_core_messages__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage)(item)) {\n                                this._emit(metadata, item, runId, true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handleChainError(_err, runId) {\n        delete this.metadatas[runId];\n    }\n}\n//# sourceMappingURL=messages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9tZXNzYWdlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNFO0FBQ3VDO0FBQ2xEO0FBQzNEO0FBQ0EsV0FBVyx1RUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQywrRUFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RUFBYTtBQUN6QjtBQUNBLGlDQUFpQyxNQUFNLFFBQVEscUJBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLE1BQU07QUFDL0U7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBLDBFQUEwRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVEQUFZO0FBQ2xEO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0VBQWMsR0FBRyxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxREFBVTtBQUM1RDtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUVBQWEsV0FBVyw0RUFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1RUFBYSxVQUFVLDRFQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1RUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1RUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUVBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9tZXNzYWdlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL2Jhc2VcIjtcbmltcG9ydCB7IEFJTWVzc2FnZUNodW5rLCBpc0Jhc2VNZXNzYWdlLCBpc0Jhc2VNZXNzYWdlQ2h1bmssIGlzVG9vbE1lc3NhZ2UsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgVEFHX0hJRERFTiwgVEFHX05PU1RSRUFNIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuZnVuY3Rpb24gaXNDaGF0R2VuZXJhdGlvbkNodW5rKHgpIHtcbiAgICByZXR1cm4gaXNCYXNlTWVzc2FnZSh4Py5tZXNzYWdlKTtcbn1cbi8qKlxuICogQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgaW1wbGVtZW50cyBzdHJlYW1fbW9kZT1tZXNzYWdlcy5cbiAqIENvbGxlY3RzIG1lc3NhZ2VzIGZyb20gKDEpIGNoYXQgbW9kZWwgc3RyZWFtIGV2ZW50cyBhbmQgKDIpIG5vZGUgb3V0cHV0cy5cbiAqL1xuLy8gVE9ETzogTWFrZSB0aGlzIGltcG9ydCBhbmQgZXhwbGljaXRseSBpbXBsZW1lbnQgdGhlXG4vLyBDYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nIGludGVyZmFjZSBvbmNlIHdlIGRyb3Agc3VwcG9ydCBmb3IgY29yZSAwLjJcbmV4cG9ydCBjbGFzcyBTdHJlYW1NZXNzYWdlc0hhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1Gbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlN0cmVhbU1lc3NhZ2VzSGFuZGxlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1GblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW1pdHRlZENoYXRNb2RlbFJ1bklkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWJsZU1lc3NhZ2VJZE1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3ByZWZlcl9zdHJlYW1pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtRm4gPSBzdHJlYW1GbjtcbiAgICB9XG4gICAgX2VtaXQobWV0YSwgbWVzc2FnZSwgcnVuSWQsIGRlZHVwZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkZWR1cGUgJiZcbiAgICAgICAgICAgIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5zZWVuW21lc3NhZ2UuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZUlkID0gbWVzc2FnZS5pZDtcbiAgICAgICAgaWYgKGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIC8vIERpc3Rpbmd1aXNoIHRvb2wgbWVzc2FnZXMgYnkgdG9vbCBjYWxsIElELlxuICAgICAgICAgICAgbWVzc2FnZUlkID8/PSBgcnVuLSR7cnVuSWR9LXRvb2wtJHttZXNzYWdlLnRvb2xfY2FsbF9pZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlIGluIENoYXRBbnRocm9waWMsIHRoZSBmaXJzdCBjaHVuayBoYXMgYW4gbWVzc2FnZSBJRFxuICAgICAgICAgICAgLy8gYnV0IHRoZSBzdWJzZXF1ZW50IGNodW5rcyBkbyBub3QuIFRvIGF2b2lkIGNsaWVudHMgc2VlaW5nIHR3byBtZXNzYWdlc1xuICAgICAgICAgICAgLy8gd2UgcmVuYW1lIHRoZSBtZXNzYWdlIElEIGlmIGl0J3MgYmVpbmcgYXV0by1zZXQgdG8gYHJ1bi0ke3J1bklkfWBcbiAgICAgICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9wdWxsLzY2NDYpLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VJZCA9PSBudWxsIHx8IG1lc3NhZ2VJZCA9PT0gYHJ1bi0ke3J1bklkfWApIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWJsZU1lc3NhZ2VJZE1hcFtydW5JZF0gPz8gbWVzc2FnZUlkID8/IGBydW4tJHtydW5JZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFibGVNZXNzYWdlSWRNYXBbcnVuSWRdID8/PSBtZXNzYWdlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VJZCAhPT0gbWVzc2FnZS5pZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBtZXNzYWdlLmlkID0gbWVzc2FnZUlkO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBtZXNzYWdlLmxjX2t3YXJncy5pZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWVuW21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5zdHJlYW1GbihbbWV0YVswXSwgXCJtZXNzYWdlc1wiLCBbbWVzc2FnZSwgbWV0YVsxXV1dKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhdE1vZGVsU3RhcnQoX2xsbSwgX21lc3NhZ2VzLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJlxuICAgICAgICAgICAgLy8gSW5jbHVkZSBsZWdhY3kgTGFuZ0dyYXBoIFNESyB0YWdcbiAgICAgICAgICAgICghdGFncyB8fCAoIXRhZ3MuaW5jbHVkZXMoVEFHX05PU1RSRUFNKSAmJiAhdGFncy5pbmNsdWRlcyhcIm5vc3RyZWFtXCIpKSkpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFzW3J1bklkXSA9IFtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5sYW5nZ3JhcGhfY2hlY2twb2ludF9ucy5zcGxpdChcInxcIiksXG4gICAgICAgICAgICAgICAgeyB0YWdzLCBuYW1lLCAuLi5tZXRhZGF0YSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgX2lkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpZWxkcz8uY2h1bms7XG4gICAgICAgIHRoaXMuZW1pdHRlZENoYXRNb2RlbFJ1bklkc1tydW5JZF0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YXNbcnVuSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCh0aGlzLm1ldGFkYXRhc1tydW5JZF0sIGNodW5rLm1lc3NhZ2UsIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQodGhpcy5tZXRhZGF0YXNbcnVuSWRdLCBuZXcgQUlNZXNzYWdlQ2h1bmsoeyBjb250ZW50OiB0b2tlbiB9KSwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUxMTUVuZChvdXRwdXQsIHJ1bklkKSB7XG4gICAgICAgIC8vIEluIEpTLCBub24tc3RyZWFtaW5nIHJ1bnMgZG8gbm90IGNhbGwgaGFuZGxlTExNTmV3VG9rZW4gYXQgdGhlIG1vZGVsIGxldmVsXG4gICAgICAgIGlmICghdGhpcy5lbWl0dGVkQ2hhdE1vZGVsUnVuSWRzW3J1bklkXSkge1xuICAgICAgICAgICAgY29uc3QgY2hhdEdlbmVyYXRpb24gPSBvdXRwdXQuZ2VuZXJhdGlvbnM/LlswXT8uWzBdO1xuICAgICAgICAgICAgaWYgKGlzQmFzZU1lc3NhZ2UoY2hhdEdlbmVyYXRpb24/Lm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCh0aGlzLm1ldGFkYXRhc1tydW5JZF0sIGNoYXRHZW5lcmF0aW9uPy5tZXNzYWdlLCBydW5JZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbWl0dGVkQ2hhdE1vZGVsUnVuSWRzW3J1bklkXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YXNbcnVuSWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5zdGFibGVNZXNzYWdlSWRNYXBbcnVuSWRdO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGhhbmRsZUxMTUVycm9yKF9lcnIsIHJ1bklkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhc1tydW5JZF07XG4gICAgfVxuICAgIGhhbmRsZUNoYWluU3RhcnQoX2NoYWluLCBpbnB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBfcnVuVHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbmFtZSA9PT0gbWV0YWRhdGEubGFuZ2dyYXBoX25vZGUgJiZcbiAgICAgICAgICAgICh0YWdzID09PSB1bmRlZmluZWQgfHwgIXRhZ3MuaW5jbHVkZXMoVEFHX0hJRERFTikpKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhc1tydW5JZF0gPSBbXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubGFuZ2dyYXBoX2NoZWNrcG9pbnRfbnMuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgICAgICAgIHsgdGFncywgbmFtZSwgLi4ubWV0YWRhdGEgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhpbnB1dHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXNCYXNlTWVzc2FnZSh2YWx1ZSkgfHwgaXNCYXNlTWVzc2FnZUNodW5rKHZhbHVlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vlblt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc0Jhc2VNZXNzYWdlKGl0ZW0pIHx8IGlzQmFzZU1lc3NhZ2VDaHVuayhpdGVtKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VlbltpdGVtLmlkXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YXNbcnVuSWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YXNbcnVuSWRdO1xuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlzQmFzZU1lc3NhZ2Uob3V0cHV0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KG1ldGFkYXRhLCBvdXRwdXRzLCBydW5JZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG91dHB1dHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jhc2VNZXNzYWdlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdChtZXRhZGF0YSwgdmFsdWUsIHJ1bklkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG91dHB1dHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3V0cHV0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhvdXRwdXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYXNlTWVzc2FnZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQobWV0YWRhdGEsIHZhbHVlLCBydW5JZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jhc2VNZXNzYWdlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQobWV0YWRhdGEsIGl0ZW0sIHJ1bklkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBoYW5kbGVDaGFpbkVycm9yKF9lcnIsIHJ1bklkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhc1tydW5JZF07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelRead: () => (/* binding */ ChannelRead),\n/* harmony export */   PregelNode: () => (/* binding */ PregelNode)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./write.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n\n\n\n\nclass ChannelRead extends _utils_js__WEBPACK_IMPORTED_MODULE_3__.RunnableCallable {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(channel, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper, fresh = false) {\n        super({\n            func: (_, config) => ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n        });\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"ChannelRead\"\n        });\n        Object.defineProperty(this, \"channel\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fresh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.fresh = fresh;\n        this.mapper = mapper;\n        this.channel = channel;\n        this.name = Array.isArray(channel)\n            ? `ChannelRead<${channel.join(\",\")}>`\n            : `ChannelRead<${channel}>`;\n    }\n    static doRead(config, channel, fresh, mapper) {\n        const read = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_READ];\n        if (!read) {\n            throw new Error(\"Runnable is not configured with a read function. Make sure to call in the context of a Pregel process\");\n        }\n        if (mapper) {\n            return mapper(read(channel, fresh));\n        }\n        else {\n            return read(channel, fresh);\n        }\n    }\n}\nconst defaultRunnableBound = \n/* #__PURE__ */ new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnablePassthrough();\nclass PregelNode extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableBinding {\n    constructor(fields) {\n        const { channels, triggers, mapper, writers, bound, kwargs, metadata, retryPolicy, tags, subgraphs, ends, } = fields;\n        const mergedTags = [\n            ...(fields.config?.tags ? fields.config.tags : []),\n            ...(tags ?? []),\n        ];\n        super({\n            ...fields,\n            bound: fields.bound ??\n                defaultRunnableBound,\n            config: {\n                ...(fields.config ? fields.config : {}),\n                tags: mergedTags,\n            },\n        });\n        Object.defineProperty(this, \"lc_graph_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PregelNode\"\n        });\n        Object.defineProperty(this, \"channels\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"triggers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: defaultRunnableBound\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"retryPolicy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"subgraphs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ends\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.channels = channels;\n        this.triggers = triggers;\n        this.mapper = mapper;\n        this.writers = writers ?? this.writers;\n        this.bound = bound ?? this.bound;\n        this.kwargs = kwargs ?? this.kwargs;\n        this.metadata = metadata ?? this.metadata;\n        this.tags = mergedTags;\n        this.retryPolicy = retryPolicy;\n        this.subgraphs = subgraphs;\n        this.ends = ends;\n    }\n    getWriters() {\n        const newWriters = [...this.writers];\n        while (newWriters.length > 1 &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            newWriters[newWriters.length - 1] instanceof _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            newWriters[newWriters.length - 2] instanceof _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite) {\n            // we can combine writes if they are consecutive\n            // careful to not modify the original writers list or ChannelWrite\n            const endWriters = newWriters.slice(-2);\n            const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n            newWriters[newWriters.length - 2] = new _write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite(combinedWrites, endWriters[0].config?.tags);\n            newWriters.pop();\n        }\n        return newWriters;\n    }\n    getNode() {\n        const writers = this.getWriters();\n        if (this.bound === defaultRunnableBound && writers.length === 0) {\n            return undefined;\n        }\n        else if (this.bound === defaultRunnableBound && writers.length === 1) {\n            return writers[0];\n        }\n        else if (this.bound === defaultRunnableBound) {\n            return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n                first: writers[0],\n                middle: writers.slice(1, writers.length - 1),\n                last: writers[writers.length - 1],\n                omitSequenceTags: true,\n            });\n        }\n        else if (writers.length > 0) {\n            return new _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.RunnableSequence({\n                first: this.bound,\n                middle: writers.slice(0, writers.length - 1),\n                last: writers[writers.length - 1],\n                omitSequenceTags: true,\n            });\n        }\n        else {\n            return this.bound;\n        }\n    }\n    join(channels) {\n        if (!Array.isArray(channels)) {\n            throw new Error(\"channels must be a list\");\n        }\n        if (typeof this.channels !== \"object\") {\n            throw new Error(\"all channels must be named when using .join()\");\n        }\n        return new PregelNode({\n            channels: {\n                ...this.channels,\n                ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n            },\n            triggers: this.triggers,\n            mapper: this.mapper,\n            writers: this.writers,\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            retryPolicy: this.retryPolicy,\n        });\n    }\n    pipe(coerceable) {\n        if (_write_js__WEBPACK_IMPORTED_MODULE_2__.ChannelWrite.isWriter(coerceable)) {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: [...this.writers, coerceable],\n                bound: this.bound,\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n        else if (this.bound === defaultRunnableBound) {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: this.writers,\n                bound: (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__._coerceToRunnable)(coerceable),\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n        else {\n            return new PregelNode({\n                channels: this.channels,\n                triggers: this.triggers,\n                mapper: this.mapper,\n                writers: this.writers,\n                bound: this.bound.pipe(coerceable),\n                config: this.config,\n                kwargs: this.kwargs,\n                retryPolicy: this.retryPolicy,\n            });\n        }\n    }\n}\n//# sourceMappingURL=read.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9yZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1SDtBQUNyRTtBQUNSO0FBQ0s7QUFDeEMsMEJBQTBCLHVEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQyw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLDBEQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwRUFBbUI7QUFDaEMseUJBQXlCLHNFQUFlO0FBQy9DO0FBQ0EsZ0JBQWdCLG9HQUFvRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtREFBWTtBQUNyRTtBQUNBLHlEQUF5RCxtREFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtREFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1Qix1RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksbURBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9yZWFkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlQmluZGluZywgUnVubmFibGVQYXNzdGhyb3VnaCwgUnVubmFibGVTZXF1ZW5jZSwgX2NvZXJjZVRvUnVubmFibGUsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IENPTkZJR19LRVlfUkVBRCB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IENoYW5uZWxXcml0ZSB9IGZyb20gXCIuL3dyaXRlLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZUNhbGxhYmxlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5leHBvcnQgY2xhc3MgQ2hhbm5lbFJlYWQgZXh0ZW5kcyBSdW5uYWJsZUNhbGxhYmxlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbWFwcGVyLCBmcmVzaCA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGZ1bmM6IChfLCBjb25maWcpID0+IENoYW5uZWxSZWFkLmRvUmVhZChjb25maWcsIHRoaXMuY2hhbm5lbCwgdGhpcy5mcmVzaCwgdGhpcy5tYXBwZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZ3JhcGhfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJDaGFubmVsUmVhZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyZXNoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwcGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJlc2ggPSBmcmVzaDtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMubmFtZSA9IEFycmF5LmlzQXJyYXkoY2hhbm5lbClcbiAgICAgICAgICAgID8gYENoYW5uZWxSZWFkPCR7Y2hhbm5lbC5qb2luKFwiLFwiKX0+YFxuICAgICAgICAgICAgOiBgQ2hhbm5lbFJlYWQ8JHtjaGFubmVsfT5gO1xuICAgIH1cbiAgICBzdGF0aWMgZG9SZWFkKGNvbmZpZywgY2hhbm5lbCwgZnJlc2gsIG1hcHBlcikge1xuICAgICAgICBjb25zdCByZWFkID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfUkVBRF07XG4gICAgICAgIGlmICghcmVhZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGUgaXMgbm90IGNvbmZpZ3VyZWQgd2l0aCBhIHJlYWQgZnVuY3Rpb24uIE1ha2Ugc3VyZSB0byBjYWxsIGluIHRoZSBjb250ZXh0IG9mIGEgUHJlZ2VsIHByb2Nlc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBlcihyZWFkKGNoYW5uZWwsIGZyZXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZChjaGFubmVsLCBmcmVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBkZWZhdWx0UnVubmFibGVCb3VuZCA9IFxuLyogI19fUFVSRV9fICovIG5ldyBSdW5uYWJsZVBhc3N0aHJvdWdoKCk7XG5leHBvcnQgY2xhc3MgUHJlZ2VsTm9kZSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhbm5lbHMsIHRyaWdnZXJzLCBtYXBwZXIsIHdyaXRlcnMsIGJvdW5kLCBrd2FyZ3MsIG1ldGFkYXRhLCByZXRyeVBvbGljeSwgdGFncywgc3ViZ3JhcGhzLCBlbmRzLCB9ID0gZmllbGRzO1xuICAgICAgICBjb25zdCBtZXJnZWRUYWdzID0gW1xuICAgICAgICAgICAgLi4uKGZpZWxkcy5jb25maWc/LnRhZ3MgPyBmaWVsZHMuY29uZmlnLnRhZ3MgOiBbXSksXG4gICAgICAgICAgICAuLi4odGFncyA/PyBbXSksXG4gICAgICAgIF07XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIGJvdW5kOiBmaWVsZHMuYm91bmQgPz9cbiAgICAgICAgICAgICAgICBkZWZhdWx0UnVubmFibGVCb3VuZCxcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIC4uLihmaWVsZHMuY29uZmlnID8gZmllbGRzLmNvbmZpZyA6IHt9KSxcbiAgICAgICAgICAgICAgICB0YWdzOiBtZXJnZWRUYWdzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2dyYXBoX25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiUHJlZ2VsTm9kZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmlnZ2Vyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcHBlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm91bmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGRlZmF1bHRSdW5uYWJsZUJvdW5kXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXRyeVBvbGljeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdWJncmFwaHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7XG4gICAgICAgIHRoaXMudHJpZ2dlcnMgPSB0cmlnZ2VycztcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICAgIHRoaXMud3JpdGVycyA9IHdyaXRlcnMgPz8gdGhpcy53cml0ZXJzO1xuICAgICAgICB0aGlzLmJvdW5kID0gYm91bmQgPz8gdGhpcy5ib3VuZDtcbiAgICAgICAgdGhpcy5rd2FyZ3MgPSBrd2FyZ3MgPz8gdGhpcy5rd2FyZ3M7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YSA/PyB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhZ3MgPSBtZXJnZWRUYWdzO1xuICAgICAgICB0aGlzLnJldHJ5UG9saWN5ID0gcmV0cnlQb2xpY3k7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGhzID0gc3ViZ3JhcGhzO1xuICAgICAgICB0aGlzLmVuZHMgPSBlbmRzO1xuICAgIH1cbiAgICBnZXRXcml0ZXJzKCkge1xuICAgICAgICBjb25zdCBuZXdXcml0ZXJzID0gWy4uLnRoaXMud3JpdGVyc107XG4gICAgICAgIHdoaWxlIChuZXdXcml0ZXJzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIG5ld1dyaXRlcnNbbmV3V3JpdGVycy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIENoYW5uZWxXcml0ZSAmJlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgbmV3V3JpdGVyc1tuZXdXcml0ZXJzLmxlbmd0aCAtIDJdIGluc3RhbmNlb2YgQ2hhbm5lbFdyaXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29tYmluZSB3cml0ZXMgaWYgdGhleSBhcmUgY29uc2VjdXRpdmVcbiAgICAgICAgICAgIC8vIGNhcmVmdWwgdG8gbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgd3JpdGVycyBsaXN0IG9yIENoYW5uZWxXcml0ZVxuICAgICAgICAgICAgY29uc3QgZW5kV3JpdGVycyA9IG5ld1dyaXRlcnMuc2xpY2UoLTIpO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRXcml0ZXMgPSBlbmRXcml0ZXJzWzBdLndyaXRlcy5jb25jYXQoZW5kV3JpdGVyc1sxXS53cml0ZXMpO1xuICAgICAgICAgICAgbmV3V3JpdGVyc1tuZXdXcml0ZXJzLmxlbmd0aCAtIDJdID0gbmV3IENoYW5uZWxXcml0ZShjb21iaW5lZFdyaXRlcywgZW5kV3JpdGVyc1swXS5jb25maWc/LnRhZ3MpO1xuICAgICAgICAgICAgbmV3V3JpdGVycy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3V3JpdGVycztcbiAgICB9XG4gICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgY29uc3Qgd3JpdGVycyA9IHRoaXMuZ2V0V3JpdGVycygpO1xuICAgICAgICBpZiAodGhpcy5ib3VuZCA9PT0gZGVmYXVsdFJ1bm5hYmxlQm91bmQgJiYgd3JpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ib3VuZCA9PT0gZGVmYXVsdFJ1bm5hYmxlQm91bmQgJiYgd3JpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYm91bmQgPT09IGRlZmF1bHRSdW5uYWJsZUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB3cml0ZXJzWzBdLFxuICAgICAgICAgICAgICAgIG1pZGRsZTogd3JpdGVycy5zbGljZSgxLCB3cml0ZXJzLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgIGxhc3Q6IHdyaXRlcnNbd3JpdGVycy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBvbWl0U2VxdWVuY2VUYWdzOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod3JpdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAgICAgIG1pZGRsZTogd3JpdGVycy5zbGljZSgwLCB3cml0ZXJzLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgIGxhc3Q6IHdyaXRlcnNbd3JpdGVycy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBvbWl0U2VxdWVuY2VUYWdzOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBqb2luKGNoYW5uZWxzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGFubmVscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWxzIG11c3QgYmUgYSBsaXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGFubmVscyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxsIGNoYW5uZWxzIG11c3QgYmUgbmFtZWQgd2hlbiB1c2luZyAuam9pbigpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICBjaGFubmVsczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKGNoYW5uZWxzLm1hcCgoY2hhbikgPT4gW2NoYW4sIGNoYW5dKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJpZ2dlcnM6IHRoaXMudHJpZ2dlcnMsXG4gICAgICAgICAgICBtYXBwZXI6IHRoaXMubWFwcGVyLFxuICAgICAgICAgICAgd3JpdGVyczogdGhpcy53cml0ZXJzLFxuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIHJldHJ5UG9saWN5OiB0aGlzLnJldHJ5UG9saWN5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIGlmIChDaGFubmVsV3JpdGUuaXNXcml0ZXIoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZ2VsTm9kZSh7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnM6IHRoaXMudHJpZ2dlcnMsXG4gICAgICAgICAgICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlcixcbiAgICAgICAgICAgICAgICB3cml0ZXJzOiBbLi4udGhpcy53cml0ZXJzLCBjb2VyY2VhYmxlXSxcbiAgICAgICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICAgICAgcmV0cnlQb2xpY3k6IHRoaXMucmV0cnlQb2xpY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmJvdW5kID09PSBkZWZhdWx0UnVubmFibGVCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVnZWxOb2RlKHtcbiAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVscyxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogdGhpcy50cmlnZ2VycyxcbiAgICAgICAgICAgICAgICBtYXBwZXI6IHRoaXMubWFwcGVyLFxuICAgICAgICAgICAgICAgIHdyaXRlcnM6IHRoaXMud3JpdGVycyxcbiAgICAgICAgICAgICAgICBib3VuZDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgICAgIHJldHJ5UG9saWN5OiB0aGlzLnJldHJ5UG9saWN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByZWdlbE5vZGUoe1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiB0aGlzLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiB0aGlzLnRyaWdnZXJzLFxuICAgICAgICAgICAgICAgIG1hcHBlcjogdGhpcy5tYXBwZXIsXG4gICAgICAgICAgICAgICAgd3JpdGVyczogdGhpcy53cml0ZXJzLFxuICAgICAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLnBpcGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgICAgIHJldHJ5UG9saWN5OiB0aGlzLnJldHJ5UG9saWN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/retry.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/retry.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_BACKOFF_FACTOR: () => (/* binding */ DEFAULT_BACKOFF_FACTOR),\n/* harmony export */   DEFAULT_INITIAL_INTERVAL: () => (/* binding */ DEFAULT_INITIAL_INTERVAL),\n/* harmony export */   DEFAULT_MAX_INTERVAL: () => (/* binding */ DEFAULT_MAX_INTERVAL),\n/* harmony export */   DEFAULT_MAX_RETRIES: () => (/* binding */ DEFAULT_MAX_RETRIES),\n/* harmony export */   _runWithRetry: () => (/* binding */ _runWithRetry)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _utils_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/config.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n\n\n\n\nconst DEFAULT_INITIAL_INTERVAL = 500;\nconst DEFAULT_BACKOFF_FACTOR = 2;\nconst DEFAULT_MAX_INTERVAL = 128000;\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DEFAULT_RETRY_ON_HANDLER = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        return false;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        return false;\n    }\n    return true;\n};\nasync function _runWithRetry(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npregelTask, retryPolicy, configurable, signal) {\n    const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;\n    let interval = resolvedRetryPolicy !== undefined\n        ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL\n        : 0;\n    let attempts = 0;\n    let error;\n    let result;\n    let { config } = pregelTask;\n    if (configurable) {\n        config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.patchConfigurable)(config, configurable);\n    }\n    config = {\n        ...config,\n        signal,\n    };\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (signal?.aborted) {\n            // no need to throw here - we'll throw from the runner, instead.\n            // there's just no point in retrying if the user has requested an abort.\n            break;\n        }\n        // Clear any writes from previous attempts\n        pregelTask.writes.splice(0, pregelTask.writes.length);\n        error = undefined;\n        try {\n            result = await pregelTask.proc.invoke(pregelTask.input, config);\n            break;\n        }\n        catch (e) {\n            error = e;\n            error.pregelTaskId = pregelTask.id;\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.isParentCommand)(error)) {\n                const ns = config?.configurable?.checkpoint_ns;\n                const cmd = error.command;\n                if (cmd.graph === ns) {\n                    // this command is for the current graph, handle it\n                    for (const writer of pregelTask.writers) {\n                        await writer.invoke(cmd, config);\n                    }\n                    error = undefined;\n                    break;\n                }\n                else if (cmd.graph === _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command.PARENT) {\n                    // this command is for the parent graph, assign it to the parent\n                    const parentNs = (0,_utils_config_js__WEBPACK_IMPORTED_MODULE_2__.getParentCheckpointNamespace)(ns);\n                    error.command = new _constants_js__WEBPACK_IMPORTED_MODULE_0__.Command({\n                        ...error.command,\n                        graph: parentNs,\n                    });\n                }\n            }\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphBubbleUp)(error)) {\n                break;\n            }\n            if (resolvedRetryPolicy === undefined) {\n                break;\n            }\n            attempts += 1;\n            // check if we should give up\n            if (attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)) {\n                break;\n            }\n            const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;\n            if (!retryOn(error)) {\n                break;\n            }\n            interval = Math.min(resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL, interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR));\n            const intervalWithJitter = resolvedRetryPolicy.jitter\n                ? Math.floor(interval + Math.random() * 1000)\n                : interval;\n            // sleep before retrying\n            // eslint-disable-next-line no-promise-executor-return\n            await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));\n            // log the retry\n            const errorName = error.name ??\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.constructor.unminifiable_name ??\n                error.constructor.name;\n            if (resolvedRetryPolicy?.logWarning ?? true) {\n                console.log(`Retrying task \"${String(pregelTask.name)}\" after ${interval.toFixed(2)}ms (attempt ${attempts}) after ${errorName}: ${error}`);\n            }\n            // signal subgraphs to resume (if available)\n            config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.patchConfigurable)(config, { [_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONFIG_KEY_RESUMING]: true });\n        }\n    }\n    return {\n        task: pregelTask,\n        result,\n        error: error,\n        signalAborted: signal?.aborted,\n    };\n}\n//# sourceMappingURL=retry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDQztBQUNDO0FBQ1o7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsaUJBQWlCLGtFQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTztBQUM5QztBQUNBLHFDQUFxQyw4RUFBNEI7QUFDakUsd0NBQXdDLGtEQUFPO0FBQy9DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdCQUFnQiwyREFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0JBQXdCLFVBQVUsb0JBQW9CLGNBQWMsU0FBUyxVQUFVLFVBQVUsSUFBSSxNQUFNO0FBQ3pKO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQWlCLFdBQVcsQ0FBQyw4REFBbUIsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9yZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tYW5kLCBDT05GSUdfS0VZX1JFU1VNSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgaXNHcmFwaEJ1YmJsZVVwLCBpc1BhcmVudENvbW1hbmQgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRQYXJlbnRDaGVja3BvaW50TmFtZXNwYWNlIH0gZnJvbSBcIi4vdXRpbHMvY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBwYXRjaENvbmZpZ3VyYWJsZSB9IGZyb20gXCIuL3V0aWxzL2luZGV4LmpzXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9JTklUSUFMX0lOVEVSVkFMID0gNTAwO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0lOVEVSVkFMID0gMTI4MDAwO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX1JFVFJJRVMgPSAzO1xuY29uc3QgREVGQVVMVF9TVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDIsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IERFRkFVTFRfUkVUUllfT05fSEFORExFUiA9IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSB8fFxuICAgICAgICBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cyA/PyBlcnJvcj8uc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgJiYgREVGQVVMVF9TVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChlcnJvcj8uZXJyb3I/LmNvZGUgPT09IFwiaW5zdWZmaWNpZW50X3F1b3RhXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3J1bldpdGhSZXRyeShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5wcmVnZWxUYXNrLCByZXRyeVBvbGljeSwgY29uZmlndXJhYmxlLCBzaWduYWwpIHtcbiAgICBjb25zdCByZXNvbHZlZFJldHJ5UG9saWN5ID0gcHJlZ2VsVGFzay5yZXRyeV9wb2xpY3kgPz8gcmV0cnlQb2xpY3k7XG4gICAgbGV0IGludGVydmFsID0gcmVzb2x2ZWRSZXRyeVBvbGljeSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVzb2x2ZWRSZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwgPz8gREVGQVVMVF9JTklUSUFMX0lOVEVSVkFMXG4gICAgICAgIDogMDtcbiAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB7IGNvbmZpZyB9ID0gcHJlZ2VsVGFzaztcbiAgICBpZiAoY29uZmlndXJhYmxlKSB7XG4gICAgICAgIGNvbmZpZyA9IHBhdGNoQ29uZmlndXJhYmxlKGNvbmZpZywgY29uZmlndXJhYmxlKTtcbiAgICB9XG4gICAgY29uZmlnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIHNpZ25hbCxcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHRocm93IGhlcmUgLSB3ZSdsbCB0aHJvdyBmcm9tIHRoZSBydW5uZXIsIGluc3RlYWQuXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGp1c3Qgbm8gcG9pbnQgaW4gcmV0cnlpbmcgaWYgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhbiBhYm9ydC5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGFueSB3cml0ZXMgZnJvbSBwcmV2aW91cyBhdHRlbXB0c1xuICAgICAgICBwcmVnZWxUYXNrLndyaXRlcy5zcGxpY2UoMCwgcHJlZ2VsVGFzay53cml0ZXMubGVuZ3RoKTtcbiAgICAgICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBwcmVnZWxUYXNrLnByb2MuaW52b2tlKHByZWdlbFRhc2suaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgZXJyb3IucHJlZ2VsVGFza0lkID0gcHJlZ2VsVGFzay5pZDtcbiAgICAgICAgICAgIGlmIChpc1BhcmVudENvbW1hbmQoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnMgPSBjb25maWc/LmNvbmZpZ3VyYWJsZT8uY2hlY2twb2ludF9ucztcbiAgICAgICAgICAgICAgICBjb25zdCBjbWQgPSBlcnJvci5jb21tYW5kO1xuICAgICAgICAgICAgICAgIGlmIChjbWQuZ3JhcGggPT09IG5zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tbWFuZCBpcyBmb3IgdGhlIGN1cnJlbnQgZ3JhcGgsIGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdyaXRlciBvZiBwcmVnZWxUYXNrLndyaXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlci5pbnZva2UoY21kLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21kLmdyYXBoID09PSBDb21tYW5kLlBBUkVOVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbW1hbmQgaXMgZm9yIHRoZSBwYXJlbnQgZ3JhcGgsIGFzc2lnbiBpdCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5zID0gZ2V0UGFyZW50Q2hlY2twb2ludE5hbWVzcGFjZShucyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNvbW1hbmQgPSBuZXcgQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lcnJvci5jb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IHBhcmVudE5zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNHcmFwaEJ1YmJsZVVwKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmVkUmV0cnlQb2xpY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBnaXZlIHVwXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPj0gKHJlc29sdmVkUmV0cnlQb2xpY3kubWF4QXR0ZW1wdHMgPz8gREVGQVVMVF9NQVhfUkVUUklFUykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHJ5T24gPSByZXNvbHZlZFJldHJ5UG9saWN5LnJldHJ5T24gPz8gREVGQVVMVF9SRVRSWV9PTl9IQU5ETEVSO1xuICAgICAgICAgICAgaWYgKCFyZXRyeU9uKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBNYXRoLm1pbihyZXNvbHZlZFJldHJ5UG9saWN5Lm1heEludGVydmFsID8/IERFRkFVTFRfTUFYX0lOVEVSVkFMLCBpbnRlcnZhbCAqIChyZXNvbHZlZFJldHJ5UG9saWN5LmJhY2tvZmZGYWN0b3IgPz8gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUikpO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWxXaXRoSml0dGVyID0gcmVzb2x2ZWRSZXRyeVBvbGljeS5qaXR0ZXJcbiAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IoaW50ZXJ2YWwgKyBNYXRoLnJhbmRvbSgpICogMTAwMClcbiAgICAgICAgICAgICAgICA6IGludGVydmFsO1xuICAgICAgICAgICAgLy8gc2xlZXAgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvbWlzZS1leGVjdXRvci1yZXR1cm5cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsV2l0aEppdHRlcikpO1xuICAgICAgICAgICAgLy8gbG9nIHRoZSByZXRyeVxuICAgICAgICAgICAgY29uc3QgZXJyb3JOYW1lID0gZXJyb3IubmFtZSA/P1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZXJyb3IuY29uc3RydWN0b3IudW5taW5pZmlhYmxlX25hbWUgPz9cbiAgICAgICAgICAgICAgICBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkUmV0cnlQb2xpY3k/LmxvZ1dhcm5pbmcgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXRyeWluZyB0YXNrIFwiJHtTdHJpbmcocHJlZ2VsVGFzay5uYW1lKX1cIiBhZnRlciAke2ludGVydmFsLnRvRml4ZWQoMil9bXMgKGF0dGVtcHQgJHthdHRlbXB0c30pIGFmdGVyICR7ZXJyb3JOYW1lfTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNpZ25hbCBzdWJncmFwaHMgdG8gcmVzdW1lIChpZiBhdmFpbGFibGUpXG4gICAgICAgICAgICBjb25maWcgPSBwYXRjaENvbmZpZ3VyYWJsZShjb25maWcsIHsgW0NPTkZJR19LRVlfUkVTVU1JTkddOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhc2s6IHByZWdlbFRhc2ssXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBzaWduYWxBYm9ydGVkOiBzaWduYWw/LmFib3J0ZWQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/retry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/runner.js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/runner.js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PregelRunner: () => (/* binding */ PregelRunner)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/types.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _retry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./retry.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/retry.js\");\n\n\n\n\n\n/**\n * Responsible for handling task execution on each tick of the {@link PregelLoop}.\n */\nclass PregelRunner {\n    /**\n     * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.\n     * @param loop - The PregelLoop that produces tasks for this runner to execute.\n     */\n    constructor({ loop, nodeFinished, }) {\n        Object.defineProperty(this, \"nodeFinished\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"loop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.loop = loop;\n        this.nodeFinished = nodeFinished;\n    }\n    /**\n     * Execute tasks from the current step of the PregelLoop.\n     *\n     * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.\n     * @param options - Options for the execution.\n     */\n    async tick(options = {}) {\n        const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;\n        const nodeErrors = new Set();\n        let graphBubbleUp;\n        const exceptionSignalController = new AbortController();\n        // Start task execution\n        const pendingTasks = Object.values(this.loop.tasks).filter((t) => t.writes.length === 0);\n        const currentSignals = this._initializeAbortSignals({\n            exceptionSignalController,\n            timeout,\n            signal: options.signal,\n        });\n        const taskStream = this._executeTasksWithRetry(pendingTasks, {\n            signals: currentSignals,\n            retryPolicy,\n            maxConcurrency,\n        });\n        for await (const { task, error, signalAborted } of taskStream) {\n            this._commit(task, error);\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(error)) {\n                graphBubbleUp = error;\n            }\n            else if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(error) && !(0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(graphBubbleUp)) {\n                graphBubbleUp = error;\n            }\n            else if (error && (nodeErrors.size === 0 || !signalAborted)) {\n                /*\n                 * The goal here is to capture the exception that causes the graph to terminate early. In\n                 * theory it's possible for multiple nodes to throw, so this also handles the edge case of\n                 * capturing concurrent exceptions thrown before the node saw an abort. This is checked via\n                 * the signalAborted flag, which records the state of the abort signal at the time the node\n                 * execution finished.\n                 *\n                 * There is a case however where one node throws some error causing us to trigger an abort,\n                 * which then causes other concurrently executing nodes to throw their own AbortErrors. In\n                 * this case we don't care about reporting the abort errors thrown by the other nodes,\n                 * because they don't tell the user anything about what caused the graph execution to\n                 * terminate early, so we ignore them (and any other errors that occur after the node sees\n                 * an abort signal).\n                 */\n                exceptionSignalController.abort();\n                nodeErrors.add(error);\n            }\n        }\n        onStepWrite?.(this.loop.step, Object.values(this.loop.tasks)\n            .map((task) => task.writes)\n            .flat());\n        if (nodeErrors.size === 1) {\n            throw Array.from(nodeErrors)[0];\n        }\n        else if (nodeErrors.size > 1) {\n            throw new AggregateError(Array.from(nodeErrors), `Multiple errors occurred during superstep ${this.loop.step}. See the \"errors\" field of this exception for more details.`);\n        }\n        if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(graphBubbleUp)) {\n            throw graphBubbleUp;\n        }\n        if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(graphBubbleUp) && this.loop.isNested) {\n            throw graphBubbleUp;\n        }\n    }\n    /**\n     * Initializes the current AbortSignals for the PregelRunner, handling the various ways that\n     * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary\n     * while still allowing nodes to gracefully exit.\n     *\n     * This method must only be called once per PregelRunner#tick. It has the side effect of updating\n     * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future\n     * ticks and subgraph calls.\n     *\n     * @param options - Options for the initialization.\n     * @returns The current abort signals.\n     * @internal\n     */\n    _initializeAbortSignals({ exceptionSignalController, timeout, signal, }) {\n        const previousSignals = this.loop.config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_ABORT_SIGNALS] ?? {};\n        // This is true when a node calls a subgraph and, rather than forwarding its own AbortSignal,\n        // it creates a new AbortSignal and passes that along instead.\n        const subgraphCalledWithSignalCreatedByNode = signal &&\n            previousSignals.composedAbortSignal &&\n            signal !== previousSignals.composedAbortSignal;\n        const externalAbortSignal = subgraphCalledWithSignalCreatedByNode\n            ? // Chain the signals here to make sure that the subgraph receives the external abort signal in\n                // addition to the signal created by the node.\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(previousSignals.externalAbortSignal, signal)\n            : // Otherwise, just keep using the external abort signal, or initialize it if it hasn't been\n                // assigned yet\n                previousSignals.externalAbortSignal ?? signal;\n        const errorAbortSignal = previousSignals.errorAbortSignal\n            ? // Chaining here rather than always using a fresh one handles the case where a subgraph is\n                // called in a parallel branch to some other node in the parent graph.\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(previousSignals.errorAbortSignal, exceptionSignalController.signal)\n            : exceptionSignalController.signal;\n        const timeoutAbortSignal = timeout\n            ? AbortSignal.timeout(timeout)\n            : undefined;\n        const composedAbortSignal = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(...(externalAbortSignal ? [externalAbortSignal] : []), ...(timeoutAbortSignal ? [timeoutAbortSignal] : []), errorAbortSignal);\n        const currentSignals = {\n            externalAbortSignal,\n            errorAbortSignal,\n            timeoutAbortSignal,\n            composedAbortSignal,\n        };\n        this.loop.config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.patchConfigurable)(this.loop.config, {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_ABORT_SIGNALS]: currentSignals,\n        });\n        return currentSignals;\n    }\n    /**\n     * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.\n     * @param tasks - The tasks to execute.\n     * @param options - Options for the execution.\n     */\n    async *_executeTasksWithRetry(tasks, options) {\n        const { retryPolicy, maxConcurrency, signals } = options ?? {};\n        const promiseAddedSymbol = Symbol.for(\"promiseAdded\");\n        let addedPromiseSignal;\n        let addedPromiseWait;\n        function waitHandler(resolve) {\n            addedPromiseSignal = () => {\n                addedPromiseWait = new Promise(waitHandler);\n                resolve(promiseAddedSymbol);\n            };\n        }\n        addedPromiseWait = new Promise(waitHandler);\n        const executingTasksMap = {};\n        function writer(runner, task, writes, { calls } = {}) {\n            if (writes.every(([channel]) => channel !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.PUSH)) {\n                return task.config?.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SEND]?.(writes) ?? [];\n            }\n            // Schedule PUSH tasks, collect promises\n            const scratchpad = task.config?.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SCRATCHPAD];\n            if (!scratchpad) {\n                throw new Error(`BUG: No scratchpad found on task ${task.name}__${task.id}`);\n            }\n            const rtn = {};\n            for (const [idx, write] of writes.entries()) {\n                const [channel] = write;\n                if (channel !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.PUSH) {\n                    continue;\n                }\n                const wcall = calls?.[idx];\n                const cnt = scratchpad.callCounter;\n                scratchpad.callCounter += 1;\n                if (wcall == null) {\n                    throw new Error(\"BUG: No call found\");\n                }\n                const nextTask = runner.loop.acceptPush(task, cnt, wcall);\n                if (!nextTask) {\n                    continue;\n                }\n                // Check if this task is already running\n                const existingPromise = executingTasksMap[nextTask.id];\n                if (existingPromise !== undefined) {\n                    // If the parent task was retried, the next task might already be running\n                    rtn[idx] = existingPromise;\n                }\n                else if (nextTask.writes.length > 0) {\n                    // If it already ran, return the result\n                    const returns = nextTask.writes.filter(([c]) => c === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RETURN);\n                    const errors = nextTask.writes.filter(([c]) => c === _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR);\n                    if (returns.length > 0) {\n                        // Task completed successfully\n                        if (returns.length === 1) {\n                            rtn[idx] = Promise.resolve(returns[0][1]);\n                        }\n                        else {\n                            // should be unreachable\n                            throw new Error(`BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`);\n                        }\n                    }\n                    else if (errors.length > 0) {\n                        if (errors.length === 1) {\n                            const errorValue = errors[0][1];\n                            // Task failed\n                            const error = \n                            // eslint-disable-next-line no-instanceof/no-instanceof\n                            errorValue instanceof Error\n                                ? errorValue\n                                : new Error(String(errorValue));\n                            rtn[idx] = Promise.reject(error);\n                        }\n                        else {\n                            // the only way this should happen is if the task executes multiple times and writes aren't cleared\n                            throw new Error(`BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`);\n                        }\n                    }\n                }\n                else {\n                    // Schedule the next task with retry\n                    const prom = (0,_retry_js__WEBPACK_IMPORTED_MODULE_4__._runWithRetry)(nextTask, retryPolicy, {\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SEND]: writer.bind(null, runner, nextTask),\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                        [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL]: call.bind(null, runner, nextTask),\n                    });\n                    executingTasksMap[nextTask.id] = prom;\n                    addedPromiseSignal();\n                    rtn[idx] = prom.then(({ result, error }) => {\n                        if (error) {\n                            return Promise.reject(error);\n                        }\n                        return result;\n                    });\n                }\n            }\n            return Object.values(rtn);\n        }\n        function call(runner, task, func, name, input, options = {}) {\n            const result = writer(runner, task, [[_constants_js__WEBPACK_IMPORTED_MODULE_2__.PUSH, null]], {\n                calls: [\n                    new _types_js__WEBPACK_IMPORTED_MODULE_0__.Call({\n                        func,\n                        name,\n                        input,\n                        retry: options.retry,\n                        callbacks: options.callbacks,\n                    }),\n                ],\n            });\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (result !== undefined) {\n                if (result.length === 1) {\n                    return result[0];\n                }\n                return Promise.all(result);\n            }\n            return Promise.resolve();\n        }\n        if (signals?.composedAbortSignal?.aborted) {\n            // note: don't use throwIfAborted here because it throws a DOMException,\n            // which isn't consistent with how we throw on abort below.\n            throw new Error(\"Abort\");\n        }\n        let startedTasksCount = 0;\n        let listener;\n        const timeoutOrCancelSignal = signals?.externalAbortSignal || signals?.timeoutAbortSignal\n            ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.combineAbortSignals)(...(signals.externalAbortSignal\n                ? [signals.externalAbortSignal]\n                : []), ...(signals.timeoutAbortSignal ? [signals.timeoutAbortSignal] : []))\n            : undefined;\n        const abortPromise = timeoutOrCancelSignal\n            ? new Promise((_resolve, reject) => {\n                listener = () => reject(new Error(\"Abort\"));\n                timeoutOrCancelSignal.addEventListener(\"abort\", listener, {\n                    once: true,\n                });\n            })\n            : undefined;\n        while ((startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) &&\n            tasks.length) {\n            for (; Object.values(executingTasksMap).length <\n                (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length; startedTasksCount += 1) {\n                const task = tasks[startedTasksCount];\n                executingTasksMap[task.id] = (0,_retry_js__WEBPACK_IMPORTED_MODULE_4__._runWithRetry)(task, retryPolicy, {\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_SEND]: writer?.bind(null, this, task),\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONFIG_KEY_CALL]: call?.bind(null, this, task),\n                }, signals?.composedAbortSignal).catch((error) => {\n                    return {\n                        task,\n                        error,\n                        signalAborted: signals?.composedAbortSignal?.aborted,\n                    };\n                });\n            }\n            const settledTask = await Promise.race([\n                ...Object.values(executingTasksMap),\n                ...(abortPromise ? [abortPromise] : []),\n                addedPromiseWait,\n            ]);\n            if (settledTask === promiseAddedSymbol) {\n                continue;\n            }\n            yield settledTask;\n            delete executingTasksMap[settledTask.task.id];\n        }\n    }\n    /**\n     * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.\n     *\n     * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.\n     *\n     * @param task - The task to commit.\n     * @param error - The error that occurred, if any.\n     */\n    _commit(task, error) {\n        if (error !== undefined) {\n            if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphInterrupt)(error)) {\n                if (error.interrupts.length) {\n                    const interrupts = error.interrupts.map((interrupt) => [_constants_js__WEBPACK_IMPORTED_MODULE_2__.INTERRUPT, interrupt]);\n                    const resumes = task.writes.filter((w) => w[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.RESUME);\n                    if (resumes.length) {\n                        interrupts.push(...resumes);\n                    }\n                    this.loop.putWrites(task.id, interrupts);\n                }\n            }\n            else if ((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.isGraphBubbleUp)(error) && task.writes.length) {\n                this.loop.putWrites(task.id, task.writes);\n            }\n            else {\n                this.loop.putWrites(task.id, [\n                    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ERROR, { message: error.message, name: error.name }],\n                ]);\n            }\n        }\n        else {\n            if (this.nodeFinished &&\n                (task.config?.tags == null || !task.config.tags.includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TAG_HIDDEN))) {\n                this.nodeFinished(String(task.name));\n            }\n            if (task.writes.length === 0) {\n                // Add no writes marker\n                task.writes.push([_constants_js__WEBPACK_IMPORTED_MODULE_2__.NO_WRITES, null]);\n            }\n            // Save task writes to checkpointer\n            this.loop.putWrites(task.id, task.writes);\n        }\n    }\n}\n//# sourceMappingURL=runner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9ydW5uZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1DO0FBQ3dDO0FBQ3lHO0FBQ25IO0FBQ3RCO0FBQzNDO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsZ0JBQWdCLG9EQUFvRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBLGdCQUFnQiw0REFBZ0I7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQiwyREFBZSxZQUFZLDREQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxlQUFlO0FBQ3pIO0FBQ0EsWUFBWSw0REFBZ0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksMkRBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFLGdFQUFnRSxtRUFBd0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFpQjtBQUM1QyxhQUFhLG1FQUF3QjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHlCQUF5QjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLElBQUk7QUFDNUQsd0RBQXdELCtDQUFJO0FBQzVELG1EQUFtRCwwREFBZTtBQUNsRTtBQUNBO0FBQ0EsMkRBQTJELGdFQUFxQjtBQUNoRjtBQUNBLG9FQUFvRSxVQUFVLElBQUksUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGlEQUFNO0FBQ2hGLHlFQUF5RSxnREFBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjLElBQUksWUFBWTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsY0FBYyxJQUFJLFlBQVk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3REFBYTtBQUM5Qyx5QkFBeUIsMERBQWU7QUFDeEM7QUFDQSx5QkFBeUIsMERBQWU7QUFDeEMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxrREFBa0QsK0NBQUk7QUFDdEQ7QUFDQSx3QkFBd0IsMkNBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHNGQUFzRjtBQUN0RjtBQUNBLDZDQUE2Qyx3REFBYTtBQUMxRCxxQkFBcUIsMERBQWU7QUFDcEMscUJBQXFCLDBEQUFlO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQixXQUFXLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQWdCO0FBQ2hDO0FBQ0EsNEVBQTRFLG9EQUFTO0FBQ3JGLHVFQUF1RSxpREFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQUssSUFBSSwwQ0FBMEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxxREFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9ydW5uZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FsbCwgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgY29tYmluZUFib3J0U2lnbmFscywgcGF0Y2hDb25maWd1cmFibGUsIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENPTkZJR19LRVlfU0VORCwgQ09ORklHX0tFWV9TQ1JBVENIUEFELCBQVVNILCBFUlJPUiwgSU5URVJSVVBULCBSRVNVTUUsIE5PX1dSSVRFUywgVEFHX0hJRERFTiwgUkVUVVJOLCBDT05GSUdfS0VZX0NBTEwsIENPTkZJR19LRVlfQUJPUlRfU0lHTkFMUywgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBpc0dyYXBoQnViYmxlVXAsIGlzR3JhcGhJbnRlcnJ1cHQgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBfcnVuV2l0aFJldHJ5IH0gZnJvbSBcIi4vcmV0cnkuanNcIjtcbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRhc2sgZXhlY3V0aW9uIG9uIGVhY2ggdGljayBvZiB0aGUge0BsaW5rIFByZWdlbExvb3B9LlxuICovXG5leHBvcnQgY2xhc3MgUHJlZ2VsUnVubmVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgUHJlZ2VsUnVubmVyLCB3aGljaCBleGVjdXRlcyB0YXNrcyBmcm9tIHRoZSBwcm92aWRlZCBQcmVnZWxMb29wLlxuICAgICAqIEBwYXJhbSBsb29wIC0gVGhlIFByZWdlbExvb3AgdGhhdCBwcm9kdWNlcyB0YXNrcyBmb3IgdGhpcyBydW5uZXIgdG8gZXhlY3V0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvb3AsIG5vZGVGaW5pc2hlZCwgfSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2RlRmluaXNoZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibG9vcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLm5vZGVGaW5pc2hlZCA9IG5vZGVGaW5pc2hlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0YXNrcyBmcm9tIHRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIFByZWdlbExvb3AuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBkb2VzIE5PVCBjYWxsIHtAbGluayBQcmVnZWxMb29wfSN0aWNrLiBUaGF0IG11c3QgYmUgaGFuZGxlZCBleHRlcm5hbGx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyB0aWNrKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHJldHJ5UG9saWN5LCBvblN0ZXBXcml0ZSwgbWF4Q29uY3VycmVuY3kgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG5vZGVFcnJvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBncmFwaEJ1YmJsZVVwO1xuICAgICAgICBjb25zdCBleGNlcHRpb25TaWduYWxDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAvLyBTdGFydCB0YXNrIGV4ZWN1dGlvblxuICAgICAgICBjb25zdCBwZW5kaW5nVGFza3MgPSBPYmplY3QudmFsdWVzKHRoaXMubG9vcC50YXNrcykuZmlsdGVyKCh0KSA9PiB0LndyaXRlcy5sZW5ndGggPT09IDApO1xuICAgICAgICBjb25zdCBjdXJyZW50U2lnbmFscyA9IHRoaXMuX2luaXRpYWxpemVBYm9ydFNpZ25hbHMoe1xuICAgICAgICAgICAgZXhjZXB0aW9uU2lnbmFsQ29udHJvbGxlcixcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGFza1N0cmVhbSA9IHRoaXMuX2V4ZWN1dGVUYXNrc1dpdGhSZXRyeShwZW5kaW5nVGFza3MsIHtcbiAgICAgICAgICAgIHNpZ25hbHM6IGN1cnJlbnRTaWduYWxzLFxuICAgICAgICAgICAgcmV0cnlQb2xpY3ksXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0YXNrLCBlcnJvciwgc2lnbmFsQWJvcnRlZCB9IG9mIHRhc2tTdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1pdCh0YXNrLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNHcmFwaEludGVycnVwdChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBncmFwaEJ1YmJsZVVwID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0dyYXBoQnViYmxlVXAoZXJyb3IpICYmICFpc0dyYXBoSW50ZXJydXB0KGdyYXBoQnViYmxlVXApKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhCdWJibGVVcCA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgKG5vZGVFcnJvcnMuc2l6ZSA9PT0gMCB8fCAhc2lnbmFsQWJvcnRlZCkpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZSBnb2FsIGhlcmUgaXMgdG8gY2FwdHVyZSB0aGUgZXhjZXB0aW9uIHRoYXQgY2F1c2VzIHRoZSBncmFwaCB0byB0ZXJtaW5hdGUgZWFybHkuIEluXG4gICAgICAgICAgICAgICAgICogdGhlb3J5IGl0J3MgcG9zc2libGUgZm9yIG11bHRpcGxlIG5vZGVzIHRvIHRocm93LCBzbyB0aGlzIGFsc28gaGFuZGxlcyB0aGUgZWRnZSBjYXNlIG9mXG4gICAgICAgICAgICAgICAgICogY2FwdHVyaW5nIGNvbmN1cnJlbnQgZXhjZXB0aW9ucyB0aHJvd24gYmVmb3JlIHRoZSBub2RlIHNhdyBhbiBhYm9ydC4gVGhpcyBpcyBjaGVja2VkIHZpYVxuICAgICAgICAgICAgICAgICAqIHRoZSBzaWduYWxBYm9ydGVkIGZsYWcsIHdoaWNoIHJlY29yZHMgdGhlIHN0YXRlIG9mIHRoZSBhYm9ydCBzaWduYWwgYXQgdGhlIHRpbWUgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgKiBleGVjdXRpb24gZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBpcyBhIGNhc2UgaG93ZXZlciB3aGVyZSBvbmUgbm9kZSB0aHJvd3Mgc29tZSBlcnJvciBjYXVzaW5nIHVzIHRvIHRyaWdnZXIgYW4gYWJvcnQsXG4gICAgICAgICAgICAgICAgICogd2hpY2ggdGhlbiBjYXVzZXMgb3RoZXIgY29uY3VycmVudGx5IGV4ZWN1dGluZyBub2RlcyB0byB0aHJvdyB0aGVpciBvd24gQWJvcnRFcnJvcnMuIEluXG4gICAgICAgICAgICAgICAgICogdGhpcyBjYXNlIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVwb3J0aW5nIHRoZSBhYm9ydCBlcnJvcnMgdGhyb3duIGJ5IHRoZSBvdGhlciBub2RlcyxcbiAgICAgICAgICAgICAgICAgKiBiZWNhdXNlIHRoZXkgZG9uJ3QgdGVsbCB0aGUgdXNlciBhbnl0aGluZyBhYm91dCB3aGF0IGNhdXNlZCB0aGUgZ3JhcGggZXhlY3V0aW9uIHRvXG4gICAgICAgICAgICAgICAgICogdGVybWluYXRlIGVhcmx5LCBzbyB3ZSBpZ25vcmUgdGhlbSAoYW5kIGFueSBvdGhlciBlcnJvcnMgdGhhdCBvY2N1ciBhZnRlciB0aGUgbm9kZSBzZWVzXG4gICAgICAgICAgICAgICAgICogYW4gYWJvcnQgc2lnbmFsKS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBleGNlcHRpb25TaWduYWxDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgbm9kZUVycm9ycy5hZGQoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uU3RlcFdyaXRlPy4odGhpcy5sb29wLnN0ZXAsIE9iamVjdC52YWx1ZXModGhpcy5sb29wLnRhc2tzKVxuICAgICAgICAgICAgLm1hcCgodGFzaykgPT4gdGFzay53cml0ZXMpXG4gICAgICAgICAgICAuZmxhdCgpKTtcbiAgICAgICAgaWYgKG5vZGVFcnJvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgQXJyYXkuZnJvbShub2RlRXJyb3JzKVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlRXJyb3JzLnNpemUgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoQXJyYXkuZnJvbShub2RlRXJyb3JzKSwgYE11bHRpcGxlIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgc3VwZXJzdGVwICR7dGhpcy5sb29wLnN0ZXB9LiBTZWUgdGhlIFwiZXJyb3JzXCIgZmllbGQgb2YgdGhpcyBleGNlcHRpb24gZm9yIG1vcmUgZGV0YWlscy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNHcmFwaEludGVycnVwdChncmFwaEJ1YmJsZVVwKSkge1xuICAgICAgICAgICAgdGhyb3cgZ3JhcGhCdWJibGVVcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNHcmFwaEJ1YmJsZVVwKGdyYXBoQnViYmxlVXApICYmIHRoaXMubG9vcC5pc05lc3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgZ3JhcGhCdWJibGVVcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY3VycmVudCBBYm9ydFNpZ25hbHMgZm9yIHRoZSBQcmVnZWxSdW5uZXIsIGhhbmRsaW5nIHRoZSB2YXJpb3VzIHdheXMgdGhhdFxuICAgICAqIEFib3J0U2lnbmFscyBtdXN0IGJlIGNoYWluZWQgdG9nZXRoZXIgc28gdGhhdCB0aGUgUHJlZ2VsTG9vcCBjYW4gYmUgaW50ZXJydXB0ZWQgaWYgbmVjZXNzYXJ5XG4gICAgICogd2hpbGUgc3RpbGwgYWxsb3dpbmcgbm9kZXMgdG8gZ3JhY2VmdWxseSBleGl0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBQcmVnZWxSdW5uZXIjdGljay4gSXQgaGFzIHRoZSBzaWRlIGVmZmVjdCBvZiB1cGRhdGluZ1xuICAgICAqIHRoZSBQcmVnZWxMb29wI2NvbmZpZyB3aXRoIHRoZSBuZXcgQWJvcnRTaWduYWxzIHNvIHRoZXkgbWF5IGJlIHByb3BhZ2F0ZWQgY29ycmVjdGx5IHRvIGZ1dHVyZVxuICAgICAqIHRpY2tzIGFuZCBzdWJncmFwaCBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGFib3J0IHNpZ25hbHMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2luaXRpYWxpemVBYm9ydFNpZ25hbHMoeyBleGNlcHRpb25TaWduYWxDb250cm9sbGVyLCB0aW1lb3V0LCBzaWduYWwsIH0pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTaWduYWxzID0gdGhpcy5sb29wLmNvbmZpZy5jb25maWd1cmFibGU/LltDT05GSUdfS0VZX0FCT1JUX1NJR05BTFNdID8/IHt9O1xuICAgICAgICAvLyBUaGlzIGlzIHRydWUgd2hlbiBhIG5vZGUgY2FsbHMgYSBzdWJncmFwaCBhbmQsIHJhdGhlciB0aGFuIGZvcndhcmRpbmcgaXRzIG93biBBYm9ydFNpZ25hbCxcbiAgICAgICAgLy8gaXQgY3JlYXRlcyBhIG5ldyBBYm9ydFNpZ25hbCBhbmQgcGFzc2VzIHRoYXQgYWxvbmcgaW5zdGVhZC5cbiAgICAgICAgY29uc3Qgc3ViZ3JhcGhDYWxsZWRXaXRoU2lnbmFsQ3JlYXRlZEJ5Tm9kZSA9IHNpZ25hbCAmJlxuICAgICAgICAgICAgcHJldmlvdXNTaWduYWxzLmNvbXBvc2VkQWJvcnRTaWduYWwgJiZcbiAgICAgICAgICAgIHNpZ25hbCAhPT0gcHJldmlvdXNTaWduYWxzLmNvbXBvc2VkQWJvcnRTaWduYWw7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsQWJvcnRTaWduYWwgPSBzdWJncmFwaENhbGxlZFdpdGhTaWduYWxDcmVhdGVkQnlOb2RlXG4gICAgICAgICAgICA/IC8vIENoYWluIHRoZSBzaWduYWxzIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHN1YmdyYXBoIHJlY2VpdmVzIHRoZSBleHRlcm5hbCBhYm9ydCBzaWduYWwgaW5cbiAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbiB0byB0aGUgc2lnbmFsIGNyZWF0ZWQgYnkgdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgY29tYmluZUFib3J0U2lnbmFscyhwcmV2aW91c1NpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbCwgc2lnbmFsKVxuICAgICAgICAgICAgOiAvLyBPdGhlcndpc2UsIGp1c3Qga2VlcCB1c2luZyB0aGUgZXh0ZXJuYWwgYWJvcnQgc2lnbmFsLCBvciBpbml0aWFsaXplIGl0IGlmIGl0IGhhc24ndCBiZWVuXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduZWQgeWV0XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTaWduYWxzLmV4dGVybmFsQWJvcnRTaWduYWwgPz8gc2lnbmFsO1xuICAgICAgICBjb25zdCBlcnJvckFib3J0U2lnbmFsID0gcHJldmlvdXNTaWduYWxzLmVycm9yQWJvcnRTaWduYWxcbiAgICAgICAgICAgID8gLy8gQ2hhaW5pbmcgaGVyZSByYXRoZXIgdGhhbiBhbHdheXMgdXNpbmcgYSBmcmVzaCBvbmUgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIHN1YmdyYXBoIGlzXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIGluIGEgcGFyYWxsZWwgYnJhbmNoIHRvIHNvbWUgb3RoZXIgbm9kZSBpbiB0aGUgcGFyZW50IGdyYXBoLlxuICAgICAgICAgICAgICAgIGNvbWJpbmVBYm9ydFNpZ25hbHMocHJldmlvdXNTaWduYWxzLmVycm9yQWJvcnRTaWduYWwsIGV4Y2VwdGlvblNpZ25hbENvbnRyb2xsZXIuc2lnbmFsKVxuICAgICAgICAgICAgOiBleGNlcHRpb25TaWduYWxDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgY29uc3QgdGltZW91dEFib3J0U2lnbmFsID0gdGltZW91dFxuICAgICAgICAgICAgPyBBYm9ydFNpZ25hbC50aW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY29tcG9zZWRBYm9ydFNpZ25hbCA9IGNvbWJpbmVBYm9ydFNpZ25hbHMoLi4uKGV4dGVybmFsQWJvcnRTaWduYWwgPyBbZXh0ZXJuYWxBYm9ydFNpZ25hbF0gOiBbXSksIC4uLih0aW1lb3V0QWJvcnRTaWduYWwgPyBbdGltZW91dEFib3J0U2lnbmFsXSA6IFtdKSwgZXJyb3JBYm9ydFNpZ25hbCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaWduYWxzID0ge1xuICAgICAgICAgICAgZXh0ZXJuYWxBYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGVycm9yQWJvcnRTaWduYWwsXG4gICAgICAgICAgICB0aW1lb3V0QWJvcnRTaWduYWwsXG4gICAgICAgICAgICBjb21wb3NlZEFib3J0U2lnbmFsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvb3AuY29uZmlnID0gcGF0Y2hDb25maWd1cmFibGUodGhpcy5sb29wLmNvbmZpZywge1xuICAgICAgICAgICAgW0NPTkZJR19LRVlfQUJPUlRfU0lHTkFMU106IGN1cnJlbnRTaWduYWxzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTaWduYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jdXJyZW50bHkgZXhlY3V0ZXMgdGFza3Mgd2l0aCB0aGUgcmVxdWVzdGVkIHJldHJ5IHBvbGljeSwgeWllbGRpbmcgYSB7QGxpbmsgU2V0dGxlZFByZWdlbFRhc2t9IGZvciBlYWNoIHRhc2sgYXMgaXQgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSB0YXNrcyAtIFRoZSB0YXNrcyB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyAqX2V4ZWN1dGVUYXNrc1dpdGhSZXRyeSh0YXNrcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHJldHJ5UG9saWN5LCBtYXhDb25jdXJyZW5jeSwgc2lnbmFscyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgcHJvbWlzZUFkZGVkU3ltYm9sID0gU3ltYm9sLmZvcihcInByb21pc2VBZGRlZFwiKTtcbiAgICAgICAgbGV0IGFkZGVkUHJvbWlzZVNpZ25hbDtcbiAgICAgICAgbGV0IGFkZGVkUHJvbWlzZVdhaXQ7XG4gICAgICAgIGZ1bmN0aW9uIHdhaXRIYW5kbGVyKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGFkZGVkUHJvbWlzZVNpZ25hbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRlZFByb21pc2VXYWl0ID0gbmV3IFByb21pc2Uod2FpdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZUFkZGVkU3ltYm9sKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkZWRQcm9taXNlV2FpdCA9IG5ldyBQcm9taXNlKHdhaXRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW5nVGFza3NNYXAgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVyKHJ1bm5lciwgdGFzaywgd3JpdGVzLCB7IGNhbGxzIH0gPSB7fSkge1xuICAgICAgICAgICAgaWYgKHdyaXRlcy5ldmVyeSgoW2NoYW5uZWxdKSA9PiBjaGFubmVsICE9PSBQVVNIKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmNvbmZpZz8uY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TRU5EXT8uKHdyaXRlcykgPz8gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBQVVNIIHRhc2tzLCBjb2xsZWN0IHByb21pc2VzXG4gICAgICAgICAgICBjb25zdCBzY3JhdGNocGFkID0gdGFzay5jb25maWc/LmNvbmZpZ3VyYWJsZT8uW0NPTkZJR19LRVlfU0NSQVRDSFBBRF07XG4gICAgICAgICAgICBpZiAoIXNjcmF0Y2hwYWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogTm8gc2NyYXRjaHBhZCBmb3VuZCBvbiB0YXNrICR7dGFzay5uYW1lfV9fJHt0YXNrLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcnRuID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHdyaXRlXSBvZiB3cml0ZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NoYW5uZWxdID0gd3JpdGU7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgIT09IFBVU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdjYWxsID0gY2FsbHM/LltpZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNudCA9IHNjcmF0Y2hwYWQuY2FsbENvdW50ZXI7XG4gICAgICAgICAgICAgICAgc2NyYXRjaHBhZC5jYWxsQ291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgIGlmICh3Y2FsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogTm8gY2FsbCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhc2sgPSBydW5uZXIubG9vcC5hY2NlcHRQdXNoKHRhc2ssIGNudCwgd2NhbGwpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdGFzayBpcyBhbHJlYWR5IHJ1bm5pbmdcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb21pc2UgPSBleGVjdXRpbmdUYXNrc01hcFtuZXh0VGFzay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdGFzayB3YXMgcmV0cmllZCwgdGhlIG5leHQgdGFzayBtaWdodCBhbHJlYWR5IGJlIHJ1bm5pbmdcbiAgICAgICAgICAgICAgICAgICAgcnRuW2lkeF0gPSBleGlzdGluZ1Byb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHRUYXNrLndyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGFscmVhZHkgcmFuLCByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5zID0gbmV4dFRhc2sud3JpdGVzLmZpbHRlcigoW2NdKSA9PiBjID09PSBSRVRVUk4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBuZXh0VGFzay53cml0ZXMuZmlsdGVyKChbY10pID0+IGMgPT09IEVSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydG5baWR4XSA9IFByb21pc2UucmVzb2x2ZShyZXR1cm5zWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBtdWx0aXBsZSByZXR1cm5zIGZvdW5kIGZvciB0YXNrICR7bmV4dFRhc2submFtZX1fXyR7bmV4dFRhc2suaWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JWYWx1ZSA9IGVycm9yc1swXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYXNrIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVmFsdWUgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydG5baWR4XSA9IFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvbmx5IHdheSB0aGlzIHNob3VsZCBoYXBwZW4gaXMgaWYgdGhlIHRhc2sgZXhlY3V0ZXMgbXVsdGlwbGUgdGltZXMgYW5kIHdyaXRlcyBhcmVuJ3QgY2xlYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBtdWx0aXBsZSBlcnJvcnMgZm91bmQgZm9yIHRhc2sgJHtuZXh0VGFzay5uYW1lfV9fJHtuZXh0VGFzay5pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgdGFzayB3aXRoIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb20gPSBfcnVuV2l0aFJldHJ5KG5leHRUYXNrLCByZXRyeVBvbGljeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfU0VORF06IHdyaXRlci5iaW5kKG51bGwsIHJ1bm5lciwgbmV4dFRhc2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICAgICAgW0NPTkZJR19LRVlfQ0FMTF06IGNhbGwuYmluZChudWxsLCBydW5uZXIsIG5leHRUYXNrKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGluZ1Rhc2tzTWFwW25leHRUYXNrLmlkXSA9IHByb207XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkUHJvbWlzZVNpZ25hbCgpO1xuICAgICAgICAgICAgICAgICAgICBydG5baWR4XSA9IHByb20udGhlbigoeyByZXN1bHQsIGVycm9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhydG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGwocnVubmVyLCB0YXNrLCBmdW5jLCBuYW1lLCBpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3cml0ZXIocnVubmVyLCB0YXNrLCBbW1BVU0gsIG51bGxdXSwge1xuICAgICAgICAgICAgICAgIGNhbGxzOiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeTogb3B0aW9ucy5yZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogb3B0aW9ucy5jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYWxzPy5jb21wb3NlZEFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlOiBkb24ndCB1c2UgdGhyb3dJZkFib3J0ZWQgaGVyZSBiZWNhdXNlIGl0IHRocm93cyBhIERPTUV4Y2VwdGlvbixcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzbid0IGNvbnNpc3RlbnQgd2l0aCBob3cgd2UgdGhyb3cgb24gYWJvcnQgYmVsb3cuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRlZFRhc2tzQ291bnQgPSAwO1xuICAgICAgICBsZXQgbGlzdGVuZXI7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRPckNhbmNlbFNpZ25hbCA9IHNpZ25hbHM/LmV4dGVybmFsQWJvcnRTaWduYWwgfHwgc2lnbmFscz8udGltZW91dEFib3J0U2lnbmFsXG4gICAgICAgICAgICA/IGNvbWJpbmVBYm9ydFNpZ25hbHMoLi4uKHNpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbFxuICAgICAgICAgICAgICAgID8gW3NpZ25hbHMuZXh0ZXJuYWxBYm9ydFNpZ25hbF1cbiAgICAgICAgICAgICAgICA6IFtdKSwgLi4uKHNpZ25hbHMudGltZW91dEFib3J0U2lnbmFsID8gW3NpZ25hbHMudGltZW91dEFib3J0U2lnbmFsXSA6IFtdKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBhYm9ydFByb21pc2UgPSB0aW1lb3V0T3JDYW5jZWxTaWduYWxcbiAgICAgICAgICAgID8gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydFwiKSk7XG4gICAgICAgICAgICAgICAgdGltZW91dE9yQ2FuY2VsU2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lciwge1xuICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoKHN0YXJ0ZWRUYXNrc0NvdW50ID09PSAwIHx8IE9iamVjdC5rZXlzKGV4ZWN1dGluZ1Rhc2tzTWFwKS5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKDsgT2JqZWN0LnZhbHVlcyhleGVjdXRpbmdUYXNrc01hcCkubGVuZ3RoIDxcbiAgICAgICAgICAgICAgICAobWF4Q29uY3VycmVuY3kgPz8gdGFza3MubGVuZ3RoKSAmJiBzdGFydGVkVGFza3NDb3VudCA8IHRhc2tzLmxlbmd0aDsgc3RhcnRlZFRhc2tzQ291bnQgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0YXNrc1tzdGFydGVkVGFza3NDb3VudF07XG4gICAgICAgICAgICAgICAgZXhlY3V0aW5nVGFza3NNYXBbdGFzay5pZF0gPSBfcnVuV2l0aFJldHJ5KHRhc2ssIHJldHJ5UG9saWN5LCB7XG4gICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX1NFTkRdOiB3cml0ZXI/LmJpbmQobnVsbCwgdGhpcywgdGFzayksXG4gICAgICAgICAgICAgICAgICAgIFtDT05GSUdfS0VZX0NBTExdOiBjYWxsPy5iaW5kKG51bGwsIHRoaXMsIHRhc2spLFxuICAgICAgICAgICAgICAgIH0sIHNpZ25hbHM/LmNvbXBvc2VkQWJvcnRTaWduYWwpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsQWJvcnRlZDogc2lnbmFscz8uY29tcG9zZWRBYm9ydFNpZ25hbD8uYWJvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNldHRsZWRUYXNrID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QudmFsdWVzKGV4ZWN1dGluZ1Rhc2tzTWFwKSxcbiAgICAgICAgICAgICAgICAuLi4oYWJvcnRQcm9taXNlID8gW2Fib3J0UHJvbWlzZV0gOiBbXSksXG4gICAgICAgICAgICAgICAgYWRkZWRQcm9taXNlV2FpdCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHNldHRsZWRUYXNrID09PSBwcm9taXNlQWRkZWRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHNldHRsZWRUYXNrO1xuICAgICAgICAgICAgZGVsZXRlIGV4ZWN1dGluZ1Rhc2tzTWFwW3NldHRsZWRUYXNrLnRhc2suaWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hhdCB3cml0ZXMgdG8gYXBwbHkgYmFzZWQgb24gd2hldGhlciB0aGUgdGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBhbmQgd2hhdCB0eXBlIG9mIGVycm9yIG9jY3VycmVkLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBlcnJvciBpcyBhIHtAbGluayBHcmFwaEJ1YmJsZVVwfSBlcnJvciBhbmQge0BsaW5rIFByZWdlbExvb3B9I2lzTmVzdGVkIGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFzayAtIFRoZSB0YXNrIHRvIGNvbW1pdC5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZCwgaWYgYW55LlxuICAgICAqL1xuICAgIF9jb21taXQodGFzaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0dyYXBoSW50ZXJydXB0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbnRlcnJ1cHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnJ1cHRzID0gZXJyb3IuaW50ZXJydXB0cy5tYXAoKGludGVycnVwdCkgPT4gW0lOVEVSUlVQVCwgaW50ZXJydXB0XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VtZXMgPSB0YXNrLndyaXRlcy5maWx0ZXIoKHcpID0+IHdbMF0gPT09IFJFU1VNRSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJydXB0cy5wdXNoKC4uLnJlc3VtZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vcC5wdXRXcml0ZXModGFzay5pZCwgaW50ZXJydXB0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNHcmFwaEJ1YmJsZVVwKGVycm9yKSAmJiB0YXNrLndyaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AucHV0V3JpdGVzKHRhc2suaWQsIHRhc2sud3JpdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcC5wdXRXcml0ZXModGFzay5pZCwgW1xuICAgICAgICAgICAgICAgICAgICBbRVJST1IsIHsgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgbmFtZTogZXJyb3IubmFtZSB9XSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVGaW5pc2hlZCAmJlxuICAgICAgICAgICAgICAgICh0YXNrLmNvbmZpZz8udGFncyA9PSBudWxsIHx8ICF0YXNrLmNvbmZpZy50YWdzLmluY2x1ZGVzKFRBR19ISURERU4pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZUZpbmlzaGVkKFN0cmluZyh0YXNrLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXNrLndyaXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbm8gd3JpdGVzIG1hcmtlclxuICAgICAgICAgICAgICAgIHRhc2sud3JpdGVzLnB1c2goW05PX1dSSVRFUywgbnVsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSB0YXNrIHdyaXRlcyB0byBjaGVja3BvaW50ZXJcbiAgICAgICAgICAgIHRoaXMubG9vcC5wdXRXcml0ZXModGFzay5pZCwgdGFzay53cml0ZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVubmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/runner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/stream.js":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/stream.js ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStreamWithAbortSignal: () => (/* binding */ IterableReadableStreamWithAbortSignal),\n/* harmony export */   IterableReadableWritableStream: () => (/* binding */ IterableReadableWritableStream)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/utils/stream */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/utils/stream.js\");\n\n/**\n * A wrapper around an IterableReadableStream that allows for aborting the stream when\n * {@link cancel} is called.\n */\nclass IterableReadableStreamWithAbortSignal extends _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream {\n    /**\n     * @param readableStream - The stream to wrap.\n     * @param abortController - The abort controller to use. Optional. One will be created if not provided.\n     */\n    constructor(readableStream, abortController) {\n        const reader = readableStream.getReader();\n        const ac = abortController ?? new AbortController();\n        super({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n        });\n        Object.defineProperty(this, \"_abortController\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._abortController = ac;\n        this._reader = reader;\n    }\n    /**\n     * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an\n     * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.\n     * @param reason - The reason for aborting the stream. Optional.\n     */\n    async cancel(reason) {\n        this._abortController.abort(reason);\n        this._reader.releaseLock();\n    }\n    /**\n     * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.\n     */\n    get signal() {\n        return this._abortController.signal;\n    }\n}\nclass IterableReadableWritableStream extends _langchain_core_utils_stream__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream {\n    get closed() {\n        return this._closed;\n    }\n    constructor(params) {\n        let streamControllerPromiseResolver;\n        const streamControllerPromise = new Promise((resolve) => {\n            streamControllerPromiseResolver = resolve;\n        });\n        super({\n            start: (controller) => {\n                streamControllerPromiseResolver(controller);\n            },\n        });\n        Object.defineProperty(this, \"modes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"passthroughFn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_closed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        // .start() will always be called before the stream can be interacted\n        // with anyway\n        void streamControllerPromise.then((controller) => {\n            this.controller = controller;\n        });\n        this.passthroughFn = params.passthroughFn;\n        this.modes = params.modes;\n    }\n    push(chunk) {\n        this.passthroughFn?.(chunk);\n        this.controller.enqueue(chunk);\n    }\n    close() {\n        try {\n            this.controller.close();\n        }\n        catch (e) {\n            // pass\n        }\n        finally {\n            this._closed = true;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error(e) {\n        this.controller.error(e);\n    }\n}\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxJQUFJLGNBQWM7QUFDbEI7QUFDTyxvREFBb0QsZ0ZBQXNCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUIsOEJBQThCLGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZDQUE2QyxnRkFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvc3RyZWFtXCI7XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYW4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB0aGF0IGFsbG93cyBmb3IgYWJvcnRpbmcgdGhlIHN0cmVhbSB3aGVuXG4gKiB7QGxpbmsgY2FuY2VsfSBpcyBjYWxsZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtV2l0aEFib3J0U2lnbmFsIGV4dGVuZHMgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlYWRhYmxlU3RyZWFtIC0gVGhlIHN0cmVhbSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSBhYm9ydENvbnRyb2xsZXIgLSBUaGUgYWJvcnQgY29udHJvbGxlciB0byB1c2UuIE9wdGlvbmFsLiBPbmUgd2lsbCBiZSBjcmVhdGVkIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWFkYWJsZVN0cmVhbSwgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICBjb25zdCBhYyA9IGFib3J0Q29udHJvbGxlciA/PyBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVucXVldWUgdGhlIG5leHQgZGF0YSBjaHVuayBpbnRvIG91ciB0YXJnZXQgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hYm9ydENvbnRyb2xsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBhYztcbiAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgYWJhbmRvbmluZyBhbnkgcGVuZGluZyBvcGVyYXRpb25zIGluIHByb2dyZXNzLiBDYWxsaW5nIHRoaXMgdHJpZ2dlcnMgYW5cbiAgICAgKiB7QGxpbmsgQWJvcnRTaWduYWx9IHRoYXQgaXMgcHJvcGFnYXRlZCB0byB0aGUgdGFza3MgdGhhdCBhcmUgcHJvZHVjaW5nIHRoZSBkYXRhIGZvciB0aGlzIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gcmVhc29uIC0gVGhlIHJlYXNvbiBmb3IgYWJvcnRpbmcgdGhlIHN0cmVhbS4gT3B0aW9uYWwuXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQWJvcnRTaWduYWx9IGZvciB0aGUgc3RyZWFtLiBBYm9ydGVkIHdoZW4ge0BsaW5rIGNhbmNlbH0gaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJdGVyYWJsZVJlYWRhYmxlV3JpdGFibGVTdHJlYW0gZXh0ZW5kcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIHtcbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXJQcm9taXNlUmVzb2x2ZXI7XG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXJQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgc3RhcnQ6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlclByb21pc2VSZXNvbHZlcihjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cm9sbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhc3N0aHJvdWdoRm5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Nsb3NlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC5zdGFydCgpIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHN0cmVhbSBjYW4gYmUgaW50ZXJhY3RlZFxuICAgICAgICAvLyB3aXRoIGFueXdheVxuICAgICAgICB2b2lkIHN0cmVhbUNvbnRyb2xsZXJQcm9taXNlLnRoZW4oKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhc3N0aHJvdWdoRm4gPSBwYXJhbXMucGFzc3Rocm91Z2hGbjtcbiAgICAgICAgdGhpcy5tb2RlcyA9IHBhcmFtcy5tb2RlcztcbiAgICB9XG4gICAgcHVzaChjaHVuaykge1xuICAgICAgICB0aGlzLnBhc3N0aHJvdWdoRm4/LihjaHVuayk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmVycm9yKGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/types.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/types.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   isCall: () => (/* binding */ isCall)\n/* harmony export */ });\nclass Call {\n    constructor({ func, name, input, retry, callbacks }) {\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"input\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"__lg_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"call\"\n        });\n        this.func = func;\n        this.name = name;\n        this.input = input;\n        this.retry = retry;\n        this.callbacks = callbacks;\n    }\n}\nfunction isCall(value) {\n    return (typeof value === \"object\" &&\n        value !== null &&\n        \"__lg_type\" in value &&\n        value.__lg_type === \"call\");\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1Asa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvcHJlZ2VsL3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBDYWxsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGZ1bmMsIG5hbWUsIGlucHV0LCByZXRyeSwgY2FsbGJhY2tzIH0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHJ5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2xnX3R5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY2FsbFwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmV0cnkgPSByZXRyeTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIFwiX19sZ190eXBlXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgdmFsdWUuX19sZ190eXBlID09PSBcImNhbGxcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureLangGraphConfig: () => (/* binding */ ensureLangGraphConfig),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getCurrentTaskInput: () => (/* binding */ getCurrentTaskInput),\n/* harmony export */   getParentCheckpointNamespace: () => (/* binding */ getParentCheckpointNamespace),\n/* harmony export */   getStore: () => (/* binding */ getStore),\n/* harmony export */   getWriter: () => (/* binding */ getWriter),\n/* harmony export */   recastCheckpointNamespace: () => (/* binding */ recastCheckpointNamespace)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/singletons */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n\n\nconst COPIABLE_KEYS = [\"tags\", \"metadata\", \"callbacks\", \"configurable\"];\nconst CONFIG_KEYS = [\n    \"tags\",\n    \"metadata\",\n    \"callbacks\",\n    \"runName\",\n    \"maxConcurrency\",\n    \"recursionLimit\",\n    \"configurable\",\n    \"runId\",\n    \"outputKeys\",\n    \"streamMode\",\n    \"store\",\n    \"writer\",\n    \"interruptBefore\",\n    \"interruptAfter\",\n    \"signal\",\n];\nconst DEFAULT_RECURSION_LIMIT = 25;\nfunction ensureLangGraphConfig(...configs) {\n    const empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: DEFAULT_RECURSION_LIMIT,\n        configurable: {},\n    };\n    const implicitConfig = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (implicitConfig !== undefined) {\n        for (const [k, v] of Object.entries(implicitConfig)) {\n            if (v !== undefined) {\n                if (COPIABLE_KEYS.includes(k)) {\n                    let copiedValue;\n                    if (Array.isArray(v)) {\n                        copiedValue = [...v];\n                    }\n                    else if (typeof v === \"object\") {\n                        if (k === \"callbacks\" &&\n                            \"copy\" in v &&\n                            typeof v.copy === \"function\") {\n                            copiedValue = v.copy();\n                        }\n                        else {\n                            copiedValue = { ...v };\n                        }\n                    }\n                    else {\n                        copiedValue = v;\n                    }\n                    empty[k] = copiedValue;\n                }\n                else {\n                    empty[k] = v;\n                }\n            }\n        }\n    }\n    for (const config of configs) {\n        if (config === undefined) {\n            continue;\n        }\n        for (const [k, v] of Object.entries(config)) {\n            if (v !== undefined && CONFIG_KEYS.includes(k)) {\n                empty[k] = v;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(empty.configurable)) {\n        empty.metadata = empty.metadata ?? {};\n        if (!key.startsWith(\"__\") &&\n            (typeof value === \"string\" ||\n                typeof value === \"number\" ||\n                typeof value === \"boolean\") &&\n            !(key in empty.metadata)) {\n            empty.metadata[key] = value;\n        }\n    }\n    return empty;\n}\n/**\n * A helper utility function that returns the {@link BaseStore} that was set when the graph was initialized\n *\n * @returns a reference to the {@link BaseStore} that was set when the graph was initialized\n */\nfunction getStore() {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    return config?.store;\n}\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined\n *\n * @returns a reference to the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined\n */\nfunction getWriter() {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    return config?.configurable?.writer;\n}\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized\n *\n * @returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized\n */\nfunction getConfig() {\n    return _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n}\n/**\n * A helper utility function that returns the input for the currently executing task\n *\n * @returns the input for the currently executing task\n */\nfunction getCurrentTaskInput() {\n    const config = _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    if (config === undefined) {\n        throw new Error(\"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\");\n    }\n    if (config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SCRATCHPAD]?.currentTaskInput === undefined) {\n        throw new Error(\"BUG: internal scratchpad not initialized.\");\n    }\n    return config.configurable[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SCRATCHPAD].currentTaskInput;\n}\nfunction recastCheckpointNamespace(namespace) {\n    return namespace\n        .split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR)\n        .filter((part) => !part.match(/^\\d+$/))\n        .map((part) => part.split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_END)[0])\n        .join(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n}\nfunction getParentCheckpointNamespace(namespace) {\n    const parts = namespace.split(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n    while (parts.length > 1 && parts[parts.length - 1].match(/^\\d+$/)) {\n        parts.pop();\n    }\n    return parts.slice(0, -1).join(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC91dGlscy9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQ3NDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQkFBMkIsMEZBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNPO0FBQ1AsbUJBQW1CLDBGQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGO0FBQ0EsZ0NBQWdDLHNDQUFzQztBQUN0RTtBQUNPO0FBQ1AsbUJBQW1CLDBGQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNPO0FBQ1AsV0FBVywwRkFBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsMEZBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRUFBcUI7QUFDbkQ7QUFDQTtBQUNBLCtCQUErQixnRUFBcUI7QUFDcEQ7QUFDTztBQUNQO0FBQ0EsZUFBZSx5RUFBOEI7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQXdCO0FBQzFELGNBQWMseUVBQThCO0FBQzVDO0FBQ087QUFDUCxrQ0FBa0MseUVBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5RUFBOEI7QUFDakU7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC91dGlscy9jb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvc2luZ2xldG9uc1wiO1xuaW1wb3J0IHsgQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfRU5ELCBDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IsIENPTkZJR19LRVlfU0NSQVRDSFBBRCwgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzLmpzXCI7XG5jb25zdCBDT1BJQUJMRV9LRVlTID0gW1widGFnc1wiLCBcIm1ldGFkYXRhXCIsIFwiY2FsbGJhY2tzXCIsIFwiY29uZmlndXJhYmxlXCJdO1xuY29uc3QgQ09ORklHX0tFWVMgPSBbXG4gICAgXCJ0YWdzXCIsXG4gICAgXCJtZXRhZGF0YVwiLFxuICAgIFwiY2FsbGJhY2tzXCIsXG4gICAgXCJydW5OYW1lXCIsXG4gICAgXCJtYXhDb25jdXJyZW5jeVwiLFxuICAgIFwicmVjdXJzaW9uTGltaXRcIixcbiAgICBcImNvbmZpZ3VyYWJsZVwiLFxuICAgIFwicnVuSWRcIixcbiAgICBcIm91dHB1dEtleXNcIixcbiAgICBcInN0cmVhbU1vZGVcIixcbiAgICBcInN0b3JlXCIsXG4gICAgXCJ3cml0ZXJcIixcbiAgICBcImludGVycnVwdEJlZm9yZVwiLFxuICAgIFwiaW50ZXJydXB0QWZ0ZXJcIixcbiAgICBcInNpZ25hbFwiLFxuXTtcbmNvbnN0IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUID0gMjU7XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlTGFuZ0dyYXBoQ29uZmlnKC4uLmNvbmZpZ3MpIHtcbiAgICBjb25zdCBlbXB0eSA9IHtcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgY2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCxcbiAgICAgICAgY29uZmlndXJhYmxlOiB7fSxcbiAgICB9O1xuICAgIGNvbnN0IGltcGxpY2l0Q29uZmlnID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xuICAgIGlmIChpbXBsaWNpdENvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGltcGxpY2l0Q29uZmlnKSkge1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChDT1BJQUJMRV9LRVlTLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3BpZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZFZhbHVlID0gWy4uLnZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gXCJjYWxsYmFja3NcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29weVwiIGluIHYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygdi5jb3B5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWRWYWx1ZSA9IHYuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkVmFsdWUgPSB7IC4uLnYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZFZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbXB0eVtrXSA9IGNvcGllZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnKSkge1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiBDT05GSUdfS0VZUy5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgICAgIGVtcHR5W2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhlbXB0eS5jb25maWd1cmFibGUpKSB7XG4gICAgICAgIGVtcHR5Lm1ldGFkYXRhID0gZW1wdHkubWV0YWRhdGEgPz8ge307XG4gICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCJfX1wiKSAmJlxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpICYmXG4gICAgICAgICAgICAhKGtleSBpbiBlbXB0eS5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG59XG4vKipcbiAqIEEgaGVscGVyIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB7QGxpbmsgQmFzZVN0b3JlfSB0aGF0IHdhcyBzZXQgd2hlbiB0aGUgZ3JhcGggd2FzIGluaXRpYWxpemVkXG4gKlxuICogQHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHtAbGluayBCYXNlU3RvcmV9IHRoYXQgd2FzIHNldCB3aGVuIHRoZSBncmFwaCB3YXMgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICByZXR1cm4gY29uZmlnPy5zdG9yZTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHtAbGluayBMYW5nR3JhcGhSdW5uYWJsZUNvbmZpZyN3cml0ZXJ9IGlmIFwiY3VzdG9tXCIgc3RyZWFtIG1vZGUgaXMgZW5hYmxlZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICpcbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgTGFuZ0dyYXBoUnVubmFibGVDb25maWcjd3JpdGVyfSBpZiBcImN1c3RvbVwiIHN0cmVhbSBtb2RlIGlzIGVuYWJsZWQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdyaXRlcigpIHtcbiAgICBjb25zdCBjb25maWcgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldFJ1bm5hYmxlQ29uZmlnKCk7XG4gICAgcmV0dXJuIGNvbmZpZz8uY29uZmlndXJhYmxlPy53cml0ZXI7XG59XG4vKipcbiAqIEEgaGVscGVyIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB7QGxpbmsgTGFuZ0dyYXBoUnVubmFibGVDb25maWd9IHRoYXQgd2FzIHNldCB3aGVuIHRoZSBncmFwaCB3YXMgaW5pdGlhbGl6ZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUge0BsaW5rIExhbmdHcmFwaFJ1bm5hYmxlQ29uZmlnfSB0aGF0IHdhcyBzZXQgd2hlbiB0aGUgZ3JhcGggd2FzIGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGlucHV0IGZvciB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrXG4gKlxuICogQHJldHVybnMgdGhlIGlucHV0IGZvciB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50VGFza0lucHV0KCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG5vdCByZXRyaWV2YWJsZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aG91dCBzdXBwb3J0IGZvciBBc3luY0xvY2FsU3RvcmFnZS5cIik7XG4gICAgfVxuICAgIGlmIChjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TQ1JBVENIUEFEXT8uY3VycmVudFRhc2tJbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogaW50ZXJuYWwgc2NyYXRjaHBhZCBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLmNvbmZpZ3VyYWJsZVtDT05GSUdfS0VZX1NDUkFUQ0hQQURdLmN1cnJlbnRUYXNrSW5wdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjYXN0Q2hlY2twb2ludE5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gbmFtZXNwYWNlXG4gICAgICAgIC5zcGxpdChDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpXG4gICAgICAgIC5maWx0ZXIoKHBhcnQpID0+ICFwYXJ0Lm1hdGNoKC9eXFxkKyQvKSlcbiAgICAgICAgLm1hcCgocGFydCkgPT4gcGFydC5zcGxpdChDSEVDS1BPSU5UX05BTUVTUEFDRV9FTkQpWzBdKVxuICAgICAgICAuam9pbihDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudENoZWNrcG9pbnROYW1lc3BhY2UobmFtZXNwYWNlKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoQ0hFQ0tQT0lOVF9OQU1FU1BBQ0VfU0VQQVJBVE9SKTtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbihDSEVDS1BPSU5UX05BTUVTUEFDRV9TRVBBUkFUT1IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),\n/* harmony export */   combineAbortSignals: () => (/* binding */ combineAbortSignals),\n/* harmony export */   getNewChannelVersions: () => (/* binding */ getNewChannelVersions),\n/* harmony export */   getNullChannelVersion: () => (/* binding */ getNullChannelVersion),\n/* harmony export */   patchCheckpointMap: () => (/* binding */ patchCheckpointMap),\n/* harmony export */   patchConfigurable: () => (/* binding */ patchConfigurable)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n\nfunction getNullChannelVersion(currentVersions) {\n    const versionValues = Object.values(currentVersions);\n    const versionType = versionValues.length > 0 ? typeof versionValues[0] : undefined;\n    let nullVersion;\n    if (versionType === \"number\") {\n        nullVersion = 0;\n    }\n    else if (versionType === \"string\") {\n        nullVersion = \"\";\n    }\n    return nullVersion;\n}\nfunction getNewChannelVersions(previousVersions, currentVersions) {\n    // Get new channel versions\n    if (Object.keys(previousVersions).length > 0) {\n        const nullVersion = getNullChannelVersion(currentVersions);\n        return Object.fromEntries(Object.entries(currentVersions).filter(([k, v]) => v > (previousVersions[k] ?? nullVersion)));\n    }\n    else {\n        return currentVersions;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction patchConfigurable(config, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npatch) {\n    if (config === null) {\n        return { configurable: patch };\n    }\n    else if (config?.configurable === undefined) {\n        return { ...config, configurable: patch };\n    }\n    else {\n        return {\n            ...config,\n            configurable: { ...config.configurable, ...patch },\n        };\n    }\n}\nfunction patchCheckpointMap(config, metadata) {\n    const parents = metadata?.parents ?? {};\n    if (Object.keys(parents).length > 0) {\n        return patchConfigurable(config, {\n            [_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONFIG_KEY_CHECKPOINT_MAP]: {\n                ...parents,\n                [config.configurable?.checkpoint_ns ?? \"\"]: config.configurable?.checkpoint_id,\n            },\n        });\n    }\n    else {\n        return config;\n    }\n}\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A single abort signal that is aborted if any of the input signals are aborted.\n */\nfunction combineAbortSignals(...signals) {\n    if (signals.length === 1) {\n        return signals[0];\n    }\n    if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return AbortSignal.any(signals);\n    }\n    const combinedController = new AbortController();\n    const listener = () => {\n        combinedController.abort();\n        signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n    };\n    signals.forEach((s) => s.addEventListener(\"abort\", listener));\n    if (signals.some((s) => s.aborted)) {\n        combinedController.abort();\n    }\n    return combinedController.signal;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStEO0FBQ3hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBeUI7QUFDdEM7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvcHJlZ2VsL3V0aWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPTkZJR19LRVlfQ0hFQ0tQT0lOVF9NQVAgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVsbENoYW5uZWxWZXJzaW9uKGN1cnJlbnRWZXJzaW9ucykge1xuICAgIGNvbnN0IHZlcnNpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRWZXJzaW9ucyk7XG4gICAgY29uc3QgdmVyc2lvblR5cGUgPSB2ZXJzaW9uVmFsdWVzLmxlbmd0aCA+IDAgPyB0eXBlb2YgdmVyc2lvblZhbHVlc1swXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbnVsbFZlcnNpb247XG4gICAgaWYgKHZlcnNpb25UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG51bGxWZXJzaW9uID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVyc2lvblR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbnVsbFZlcnNpb24gPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFZlcnNpb247XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV3Q2hhbm5lbFZlcnNpb25zKHByZXZpb3VzVmVyc2lvbnMsIGN1cnJlbnRWZXJzaW9ucykge1xuICAgIC8vIEdldCBuZXcgY2hhbm5lbCB2ZXJzaW9uc1xuICAgIGlmIChPYmplY3Qua2V5cyhwcmV2aW91c1ZlcnNpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG51bGxWZXJzaW9uID0gZ2V0TnVsbENoYW5uZWxWZXJzaW9uKGN1cnJlbnRWZXJzaW9ucyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY3VycmVudFZlcnNpb25zKS5maWx0ZXIoKFtrLCB2XSkgPT4gdiA+IChwcmV2aW91c1ZlcnNpb25zW2tdID8/IG51bGxWZXJzaW9uKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWZXJzaW9ucztcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5wYXRjaCkge1xuICAgIGlmIChjb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgY29uZmlndXJhYmxlOiBwYXRjaCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjb25maWc/LmNvbmZpZ3VyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmNvbmZpZywgY29uZmlndXJhYmxlOiBwYXRjaCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogeyAuLi5jb25maWcuY29uZmlndXJhYmxlLCAuLi5wYXRjaCB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENoZWNrcG9pbnRNYXAoY29uZmlnLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBtZXRhZGF0YT8ucGFyZW50cyA/PyB7fTtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyZW50cykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCB7XG4gICAgICAgICAgICBbQ09ORklHX0tFWV9DSEVDS1BPSU5UX01BUF06IHtcbiAgICAgICAgICAgICAgICAuLi5wYXJlbnRzLFxuICAgICAgICAgICAgICAgIFtjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X25zID8/IFwiXCJdOiBjb25maWcuY29uZmlndXJhYmxlPy5jaGVja3BvaW50X2lkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbn1cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBhYm9ydCBzaWduYWxzIGludG8gYSBzaW5nbGUgYWJvcnQgc2lnbmFsLlxuICogQHBhcmFtIHNpZ25hbHMgLSBUaGUgYWJvcnQgc2lnbmFscyB0byBjb21iaW5lLlxuICogQHJldHVybnMgQSBzaW5nbGUgYWJvcnQgc2lnbmFsIHRoYXQgaXMgYWJvcnRlZCBpZiBhbnkgb2YgdGhlIGlucHV0IHNpZ25hbHMgYXJlIGFib3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lQWJvcnRTaWduYWxzKC4uLnNpZ25hbHMpIHtcbiAgICBpZiAoc2lnbmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hbHNbMF07XG4gICAgfVxuICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoc2lnbmFscyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgY29tYmluZWRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaCgocykgPT4gcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpKTtcbiAgICB9O1xuICAgIHNpZ25hbHMuZm9yRWFjaCgocykgPT4gcy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpKTtcbiAgICBpZiAoc2lnbmFscy5zb21lKChzKSA9PiBzLmFib3J0ZWQpKSB7XG4gICAgICAgIGNvbWJpbmVkQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tYmluZWRDb250cm9sbGVyLnNpZ25hbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js":
/*!*********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js ***!
  \*********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findSubgraphPregel: () => (/* binding */ findSubgraphPregel),\n/* harmony export */   isPregelLike: () => (/* binding */ isPregelLike)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableSequence(x) {\n    return \"steps\" in x && Array.isArray(x.steps);\n}\nfunction isPregelLike(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nx\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return \"lg_is_pregel\" in x && x.lg_is_pregel === true;\n}\nfunction findSubgraphPregel(candidate\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const candidates = [candidate];\n    for (const candidate of candidates) {\n        if (isPregelLike(candidate)) {\n            return candidate;\n        }\n        else if (isRunnableSequence(candidate)) {\n            candidates.push(...candidate.steps);\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=subgraph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC91dGlscy9zdWJncmFwaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdXRpbHMvc3ViZ3JhcGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzUnVubmFibGVTZXF1ZW5jZSh4KSB7XG4gICAgcmV0dXJuIFwic3RlcHNcIiBpbiB4ICYmIEFycmF5LmlzQXJyYXkoeC5zdGVwcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcmVnZWxMaWtlKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gXCJsZ19pc19wcmVnZWxcIiBpbiB4ICYmIHgubGdfaXNfcHJlZ2VsID09PSB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdWJncmFwaFByZWdlbChjYW5kaWRhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gW2NhbmRpZGF0ZV07XG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICBpZiAoaXNQcmVnZWxMaWtlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSdW5uYWJsZVNlcXVlbmNlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5jYW5kaWRhdGUuc3RlcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJncmFwaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/validate.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/validate.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphValidationError: () => (/* binding */ GraphValidationError),\n/* harmony export */   validateGraph: () => (/* binding */ validateGraph),\n/* harmony export */   validateKeys: () => (/* binding */ validateKeys)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./read.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/read.js\");\n\n\nclass GraphValidationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"GraphValidationError\";\n    }\n}\nfunction validateGraph({ nodes, channels, inputChannels, outputChannels, streamChannels, interruptAfterNodes, interruptBeforeNodes, }) {\n    if (!channels) {\n        throw new GraphValidationError(\"Channels not provided\");\n    }\n    const subscribedChannels = new Set();\n    const allOutputChannels = new Set();\n    for (const [name, node] of Object.entries(nodes)) {\n        if (name === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT) {\n            throw new GraphValidationError(`\"Node name ${_constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERRUPT} is reserved\"`);\n        }\n        if (node.constructor === _read_js__WEBPACK_IMPORTED_MODULE_1__.PregelNode) {\n            node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n        }\n        else {\n            throw new GraphValidationError(`Invalid node type ${typeof node}, expected PregelNode`);\n        }\n    }\n    // side effect: update channels\n    for (const chan of subscribedChannels) {\n        if (!(chan in channels)) {\n            throw new GraphValidationError(`Subcribed channel '${String(chan)}' not in channels`);\n        }\n    }\n    if (!Array.isArray(inputChannels)) {\n        if (!subscribedChannels.has(inputChannels)) {\n            throw new GraphValidationError(`Input channel ${String(inputChannels)} is not subscribed to by any node`);\n        }\n    }\n    else {\n        if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n            throw new GraphValidationError(`None of the input channels ${inputChannels} are subscribed to by any node`);\n        }\n    }\n    if (!Array.isArray(outputChannels)) {\n        allOutputChannels.add(outputChannels);\n    }\n    else {\n        outputChannels.forEach((chan) => allOutputChannels.add(chan));\n    }\n    if (streamChannels && !Array.isArray(streamChannels)) {\n        allOutputChannels.add(streamChannels);\n    }\n    else if (Array.isArray(streamChannels)) {\n        streamChannels.forEach((chan) => allOutputChannels.add(chan));\n    }\n    for (const chan of allOutputChannels) {\n        if (!(chan in channels)) {\n            throw new GraphValidationError(`Output channel '${String(chan)}' not in channels`);\n        }\n    }\n    // validate interrupt before/after\n    if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n        for (const node of interruptAfterNodes) {\n            if (!(node in nodes)) {\n                throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n            }\n        }\n    }\n    if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n        for (const node of interruptBeforeNodes) {\n            if (!(node in nodes)) {\n                throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n            }\n        }\n    }\n}\nfunction validateKeys(keys, channels) {\n    if (Array.isArray(keys)) {\n        for (const key of keys) {\n            if (!(key in channels)) {\n                throw new Error(`Key ${String(key)} not found in channels`);\n            }\n        }\n    }\n    else {\n        if (!(keys in channels)) {\n            throw new Error(`Key ${String(keys)} not found in channels`);\n        }\n    }\n}\n//# sourceMappingURL=validate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC92YWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUNMO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw0R0FBNEc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFTO0FBQzlCLHlEQUF5RCxvREFBUyxFQUFFO0FBQ3BFO0FBQ0EsaUNBQWlDLGdEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx1QkFBdUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC9wcmVnZWwvdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSU5URVJSVVBUIH0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgUHJlZ2VsTm9kZSB9IGZyb20gXCIuL3JlYWQuanNcIjtcbmV4cG9ydCBjbGFzcyBHcmFwaFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkdyYXBoVmFsaWRhdGlvbkVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlR3JhcGgoeyBub2RlcywgY2hhbm5lbHMsIGlucHV0Q2hhbm5lbHMsIG91dHB1dENoYW5uZWxzLCBzdHJlYW1DaGFubmVscywgaW50ZXJydXB0QWZ0ZXJOb2RlcywgaW50ZXJydXB0QmVmb3JlTm9kZXMsIH0pIHtcbiAgICBpZiAoIWNoYW5uZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihcIkNoYW5uZWxzIG5vdCBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaWJlZENoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGFsbE91dHB1dENoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGVzKSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gSU5URVJSVVBUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYFwiTm9kZSBuYW1lICR7SU5URVJSVVBUfSBpcyByZXNlcnZlZFwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IFByZWdlbE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudHJpZ2dlcnMuZm9yRWFjaCgodHJpZ2dlcikgPT4gc3Vic2NyaWJlZENoYW5uZWxzLmFkZCh0cmlnZ2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYEludmFsaWQgbm9kZSB0eXBlICR7dHlwZW9mIG5vZGV9LCBleHBlY3RlZCBQcmVnZWxOb2RlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2lkZSBlZmZlY3Q6IHVwZGF0ZSBjaGFubmVsc1xuICAgIGZvciAoY29uc3QgY2hhbiBvZiBzdWJzY3JpYmVkQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKCEoY2hhbiBpbiBjaGFubmVscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaFZhbGlkYXRpb25FcnJvcihgU3ViY3JpYmVkIGNoYW5uZWwgJyR7U3RyaW5nKGNoYW4pfScgbm90IGluIGNoYW5uZWxzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0Q2hhbm5lbHMpKSB7XG4gICAgICAgIGlmICghc3Vic2NyaWJlZENoYW5uZWxzLmhhcyhpbnB1dENoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsaWRhdGlvbkVycm9yKGBJbnB1dCBjaGFubmVsICR7U3RyaW5nKGlucHV0Q2hhbm5lbHMpfSBpcyBub3Qgc3Vic2NyaWJlZCB0byBieSBhbnkgbm9kZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5wdXRDaGFubmVscy5ldmVyeSgoY2hhbm5lbCkgPT4gIXN1YnNjcmliZWRDaGFubmVscy5oYXMoY2hhbm5lbCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYE5vbmUgb2YgdGhlIGlucHV0IGNoYW5uZWxzICR7aW5wdXRDaGFubmVsc30gYXJlIHN1YnNjcmliZWQgdG8gYnkgYW55IG5vZGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0cHV0Q2hhbm5lbHMpKSB7XG4gICAgICAgIGFsbE91dHB1dENoYW5uZWxzLmFkZChvdXRwdXRDaGFubmVscyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXRDaGFubmVscy5mb3JFYWNoKChjaGFuKSA9PiBhbGxPdXRwdXRDaGFubmVscy5hZGQoY2hhbikpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtQ2hhbm5lbHMgJiYgIUFycmF5LmlzQXJyYXkoc3RyZWFtQ2hhbm5lbHMpKSB7XG4gICAgICAgIGFsbE91dHB1dENoYW5uZWxzLmFkZChzdHJlYW1DaGFubmVscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtQ2hhbm5lbHMpKSB7XG4gICAgICAgIHN0cmVhbUNoYW5uZWxzLmZvckVhY2goKGNoYW4pID0+IGFsbE91dHB1dENoYW5uZWxzLmFkZChjaGFuKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hhbiBvZiBhbGxPdXRwdXRDaGFubmVscykge1xuICAgICAgICBpZiAoIShjaGFuIGluIGNoYW5uZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsaWRhdGlvbkVycm9yKGBPdXRwdXQgY2hhbm5lbCAnJHtTdHJpbmcoY2hhbil9JyBub3QgaW4gY2hhbm5lbHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBpbnRlcnJ1cHQgYmVmb3JlL2FmdGVyXG4gICAgaWYgKGludGVycnVwdEFmdGVyTm9kZXMgJiYgaW50ZXJydXB0QWZ0ZXJOb2RlcyAhPT0gXCIqXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGludGVycnVwdEFmdGVyTm9kZXMpIHtcbiAgICAgICAgICAgIGlmICghKG5vZGUgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoVmFsaWRhdGlvbkVycm9yKGBOb2RlICR7U3RyaW5nKG5vZGUpfSBub3QgaW4gbm9kZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW50ZXJydXB0QmVmb3JlTm9kZXMgJiYgaW50ZXJydXB0QmVmb3JlTm9kZXMgIT09IFwiKlwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBpbnRlcnJ1cHRCZWZvcmVOb2Rlcykge1xuICAgICAgICAgICAgaWYgKCEobm9kZSBpbiBub2RlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhWYWxpZGF0aW9uRXJyb3IoYE5vZGUgJHtTdHJpbmcobm9kZSl9IG5vdCBpbiBub2Rlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlS2V5cyhrZXlzLCBjaGFubmVscykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBjaGFubmVscykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke1N0cmluZyhrZXkpfSBub3QgZm91bmQgaW4gY2hhbm5lbHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEoa2V5cyBpbiBjaGFubmVscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7U3RyaW5nKGtleXMpfSBub3QgZm91bmQgaW4gY2hhbm5lbHNgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelWrite: () => (/* binding */ ChannelWrite),\n/* harmony export */   PASSTHROUGH: () => (/* binding */ PASSTHROUGH),\n/* harmony export */   SKIP_WRITE: () => (/* binding */ SKIP_WRITE)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n\n\n\n\nconst SKIP_WRITE = {\n    [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\nfunction _isSkipWrite(x) {\n    return (typeof x === \"object\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        x?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined);\n}\nconst PASSTHROUGH = {\n    [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\nfunction _isPassthrough(x) {\n    return (typeof x === \"object\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        x?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined);\n}\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nclass ChannelWrite extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.RunnableCallable {\n    constructor(writes, tags) {\n        const name = `ChannelWrite<${writes\n            .map((packet) => {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_1__._isSend)(packet)) {\n                return packet.node;\n            }\n            else if (\"channel\" in packet) {\n                return packet.channel;\n            }\n            return \"...\";\n        })\n            .join(\",\")}>`;\n        super({\n            ...{ writes, name, tags },\n            func: async (input, config) => {\n                return this._write(input, config ?? {});\n            },\n        });\n        Object.defineProperty(this, \"writes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.writes = writes;\n    }\n    async _write(input, config) {\n        const writes = this.writes.map((write) => {\n            if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n                return {\n                    mapper: write.mapper,\n                    value: input,\n                };\n            }\n            else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n                return {\n                    channel: write.channel,\n                    value: input,\n                    skipNone: write.skipNone,\n                    mapper: write.mapper,\n                };\n            }\n            else {\n                return write;\n            }\n        });\n        await ChannelWrite.doWrite(config, writes);\n        return input;\n    }\n    // TODO: Support requireAtLeastOneOf\n    static async doWrite(config, writes) {\n        // validate\n        for (const w of writes) {\n            if (_isChannelWriteEntry(w)) {\n                if (w.channel === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TASKS) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"Cannot write to the reserved channel TASKS\");\n                }\n                if (_isPassthrough(w.value)) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n                }\n            }\n            if (_isChannelWriteTupleEntry(w)) {\n                if (_isPassthrough(w.value)) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n                }\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const writeEntries = [];\n        for (const w of writes) {\n            if ((0,_constants_js__WEBPACK_IMPORTED_MODULE_1__._isSend)(w)) {\n                writeEntries.push([_constants_js__WEBPACK_IMPORTED_MODULE_1__.TASKS, w]);\n            }\n            else if (_isChannelWriteTupleEntry(w)) {\n                const mappedResult = await w.mapper.invoke(w.value, config);\n                if (mappedResult != null && mappedResult.length > 0) {\n                    writeEntries.push(...mappedResult);\n                }\n            }\n            else if (_isChannelWriteEntry(w)) {\n                const mappedValue = w.mapper !== undefined\n                    ? await w.mapper.invoke(w.value, config)\n                    : w.value;\n                if (_isSkipWrite(mappedValue)) {\n                    continue;\n                }\n                if (w.skipNone && mappedValue === undefined) {\n                    continue;\n                }\n                writeEntries.push([w.channel, mappedValue]);\n            }\n            else {\n                throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n            }\n        }\n        const write = config.configurable?.[_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONFIG_KEY_SEND];\n        write(writeEntries);\n    }\n    static isWriter(runnable) {\n        return (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        runnable instanceof ChannelWrite ||\n            (IS_WRITER in runnable && !!runnable[IS_WRITER]));\n    }\n    static registerWriter(runnable) {\n        return Object.defineProperty(runnable, IS_WRITER, { value: true });\n    }\n}\nfunction _isChannelWriteEntry(x) {\n    return (x !== undefined && typeof x.channel === \"string\");\n}\nfunction _isChannelWriteTupleEntry(x) {\n    return (x !== undefined &&\n        !_isChannelWriteEntry(x) &&\n        _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(x.mapper));\n}\n//# sourceMappingURL=write.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC93cml0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNEO0FBQ1k7QUFDbkI7QUFDRztBQUMzQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsdURBQWdCO0FBQ2xEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsZ0JBQWdCLHNEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0Esc0RBQXNEO0FBQ3RELGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnREFBSztBQUN2Qyw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQU87QUFDdkIsbUNBQW1DLGdEQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVE7QUFDaEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5dGVkYW5jZS9QeWNoYXJtUHJvamVjdHMvbXlfYmVzdC9sYW5nZ3JhcGhfdGVhY2gvYWdlbnRfY2hhdF91aS9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3ByZWdlbC93cml0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSdW5uYWJsZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuaW1wb3J0IHsgX2lzU2VuZCwgQ09ORklHX0tFWV9TRU5ELCBUQVNLUyB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlQ2FsbGFibGUgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IEludmFsaWRVcGRhdGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBjb25zdCBTS0lQX1dSSVRFID0ge1xuICAgIFtTeW1ib2wuZm9yKFwiTEdfU0tJUF9XUklURVwiKV06IHRydWUsXG59O1xuZnVuY3Rpb24gX2lzU2tpcFdyaXRlKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHg/LltTeW1ib2wuZm9yKFwiTEdfU0tJUF9XUklURVwiKV0gIT09IHVuZGVmaW5lZCk7XG59XG5leHBvcnQgY29uc3QgUEFTU1RIUk9VR0ggPSB7XG4gICAgW1N5bWJvbC5mb3IoXCJMR19QQVNTVEhST1VHSFwiKV06IHRydWUsXG59O1xuZnVuY3Rpb24gX2lzUGFzc3Rocm91Z2goeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgeD8uW1N5bWJvbC5mb3IoXCJMR19QQVNTVEhST1VHSFwiKV0gIT09IHVuZGVmaW5lZCk7XG59XG5jb25zdCBJU19XUklURVIgPSBTeW1ib2woXCJJU19XUklURVJcIik7XG4vKipcbiAqIE1hcHBpbmcgb2Ygd3JpdGUgY2hhbm5lbHMgdG8gUnVubmFibGVzIHRoYXQgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLFxuICogb3IgTm9uZSB0byBza2lwIHdyaXRpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFubmVsV3JpdGUgZXh0ZW5kcyBSdW5uYWJsZUNhbGxhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXMsIHRhZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGBDaGFubmVsV3JpdGU8JHt3cml0ZXNcbiAgICAgICAgICAgIC5tYXAoKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKF9pc1NlbmQocGFja2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwiY2hhbm5lbFwiIGluIHBhY2tldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQuY2hhbm5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIi4uLlwiO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpfT5gO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi57IHdyaXRlcywgbmFtZSwgdGFncyB9LFxuICAgICAgICAgICAgZnVuYzogYXN5bmMgKGlucHV0LCBjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoaW5wdXQsIGNvbmZpZyA/PyB7fSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JpdGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3JpdGVzID0gd3JpdGVzO1xuICAgIH1cbiAgICBhc3luYyBfd3JpdGUoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBjb25zdCB3cml0ZXMgPSB0aGlzLndyaXRlcy5tYXAoKHdyaXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2lzQ2hhbm5lbFdyaXRlVHVwbGVFbnRyeSh3cml0ZSkgJiYgX2lzUGFzc3Rocm91Z2god3JpdGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVyOiB3cml0ZS5tYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzQ2hhbm5lbFdyaXRlRW50cnkod3JpdGUpICYmIF9pc1Bhc3N0aHJvdWdoKHdyaXRlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHdyaXRlLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE5vbmU6IHdyaXRlLnNraXBOb25lLFxuICAgICAgICAgICAgICAgICAgICBtYXBwZXI6IHdyaXRlLm1hcHBlcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgQ2hhbm5lbFdyaXRlLmRvV3JpdGUoY29uZmlnLCB3cml0ZXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIC8vIFRPRE86IFN1cHBvcnQgcmVxdWlyZUF0TGVhc3RPbmVPZlxuICAgIHN0YXRpYyBhc3luYyBkb1dyaXRlKGNvbmZpZywgd3JpdGVzKSB7XG4gICAgICAgIC8vIHZhbGlkYXRlXG4gICAgICAgIGZvciAoY29uc3QgdyBvZiB3cml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChfaXNDaGFubmVsV3JpdGVFbnRyeSh3KSkge1xuICAgICAgICAgICAgICAgIGlmICh3LmNoYW5uZWwgPT09IFRBU0tTKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXBkYXRlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gdGhlIHJlc2VydmVkIGNoYW5uZWwgVEFTS1NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNQYXNzdGhyb3VnaCh3LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiUEFTU1RIUk9VR0ggdmFsdWUgbXVzdCBiZSByZXBsYWNlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzQ2hhbm5lbFdyaXRlVHVwbGVFbnRyeSh3KSkge1xuICAgICAgICAgICAgICAgIGlmIChfaXNQYXNzdGhyb3VnaCh3LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVwZGF0ZUVycm9yKFwiUEFTU1RIUk9VR0ggdmFsdWUgbXVzdCBiZSByZXBsYWNlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgd3JpdGVFbnRyaWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdyBvZiB3cml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChfaXNTZW5kKHcpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVFbnRyaWVzLnB1c2goW1RBU0tTLCB3XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNDaGFubmVsV3JpdGVUdXBsZUVudHJ5KHcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVzdWx0ID0gYXdhaXQgdy5tYXBwZXIuaW52b2tlKHcudmFsdWUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZFJlc3VsdCAhPSBudWxsICYmIG1hcHBlZFJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRW50cmllcy5wdXNoKC4uLm1hcHBlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzQ2hhbm5lbFdyaXRlRW50cnkodykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHcubWFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCB3Lm1hcHBlci5pbnZva2Uody52YWx1ZSwgY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICA6IHcudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKF9pc1NraXBXcml0ZShtYXBwZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3LnNraXBOb25lICYmIG1hcHBlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlRW50cmllcy5wdXNoKFt3LmNoYW5uZWwsIG1hcHBlZFZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd3JpdGUgZW50cnk6ICR7SlNPTi5zdHJpbmdpZnkodyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JpdGUgPSBjb25maWcuY29uZmlndXJhYmxlPy5bQ09ORklHX0tFWV9TRU5EXTtcbiAgICAgICAgd3JpdGUod3JpdGVFbnRyaWVzKTtcbiAgICB9XG4gICAgc3RhdGljIGlzV3JpdGVyKHJ1bm5hYmxlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgcnVubmFibGUgaW5zdGFuY2VvZiBDaGFubmVsV3JpdGUgfHxcbiAgICAgICAgICAgIChJU19XUklURVIgaW4gcnVubmFibGUgJiYgISFydW5uYWJsZVtJU19XUklURVJdKSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3RlcldyaXRlcihydW5uYWJsZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJ1bm5hYmxlLCBJU19XUklURVIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2lzQ2hhbm5lbFdyaXRlRW50cnkoeCkge1xuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB4LmNoYW5uZWwgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gX2lzQ2hhbm5lbFdyaXRlVHVwbGVFbnRyeSh4KSB7XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIV9pc0NoYW5uZWxXcml0ZUVudHJ5KHgpICYmXG4gICAgICAgIFJ1bm5hYmxlLmlzUnVubmFibGUoeC5tYXBwZXIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyaXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/write.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js":
/*!*****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js ***!
  \*****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunnableCallable: () => (/* binding */ RunnableCallable),\n/* harmony export */   gatherIterator: () => (/* binding */ gatherIterator),\n/* harmony export */   gatherIteratorSync: () => (/* binding */ gatherIteratorSync),\n/* harmony export */   isAsyncGeneratorFunction: () => (/* binding */ isAsyncGeneratorFunction),\n/* harmony export */   isGeneratorFunction: () => (/* binding */ isGeneratorFunction),\n/* harmony export */   patchConfigurable: () => (/* binding */ patchConfigurable),\n/* harmony export */   prefixGenerator: () => (/* binding */ prefixGenerator)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/runnables */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/runnables.js\");\n/* harmony import */ var _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/singletons */ \"(ssr)/./node_modules/.pnpm/@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4_/node_modules/@langchain/core/singletons.js\");\n/* harmony import */ var _pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pregel/utils/config.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/pregel/utils/config.js\");\n\n\n\nclass RunnableCallable extends _langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langgraph\"]\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"recurse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.name = fields.name ?? fields.func.name;\n        this.func = fields.func;\n        this.config = fields.tags ? { tags: fields.tags } : undefined;\n        this.trace = fields.trace ?? this.trace;\n        this.recurse = fields.recurse ?? this.recurse;\n    }\n    async _tracedInvoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n            });\n            void _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    const output = await this.func(input, childConfig);\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnValue;\n        const config = (0,_pregel_utils_config_js__WEBPACK_IMPORTED_MODULE_2__.ensureLangGraphConfig)(options);\n        const mergedConfig = (0,_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.mergeConfigs)(this.config, config);\n        if (this.trace) {\n            returnValue = await this._callWithConfig(this._tracedInvoke, input, mergedConfig);\n        }\n        else {\n            returnValue = await _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => this.func(input, mergedConfig));\n        }\n        if (_langchain_core_runnables__WEBPACK_IMPORTED_MODULE_0__.Runnable.isRunnable(returnValue) && this.recurse) {\n            return await _langchain_core_singletons__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => returnValue.invoke(input, mergedConfig));\n        }\n        return returnValue;\n    }\n}\nfunction* prefixGenerator(generator, prefix) {\n    if (prefix === undefined) {\n        yield* generator;\n    }\n    else {\n        for (const value of generator) {\n            yield [prefix, value];\n        }\n    }\n}\n// https://github.com/tc39/proposal-array-from-async\nasync function gatherIterator(i) {\n    const out = [];\n    for await (const item of await i) {\n        out.push(item);\n    }\n    return out;\n}\nfunction gatherIteratorSync(i) {\n    const out = [];\n    for (const item of i) {\n        out.push(item);\n    }\n    return out;\n}\nfunction patchConfigurable(config, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\npatch) {\n    if (!config) {\n        return {\n            configurable: patch,\n        };\n    }\n    else if (!(\"configurable\" in config)) {\n        return {\n            ...config,\n            configurable: patch,\n        };\n    }\n    else {\n        return {\n            ...config,\n            configurable: {\n                ...config.configurable,\n                ...patch,\n            },\n        };\n    }\n}\nfunction isAsyncGeneratorFunction(val) {\n    return (val != null &&\n        typeof val === \"function\" &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        val instanceof Object.getPrototypeOf(async function* () { }).constructor);\n}\nfunction isGeneratorFunction(val) {\n    return (val != null &&\n        typeof val === \"function\" &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        val instanceof Object.getPrototypeOf(function* () { }).constructor);\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBaUY7QUFDRDtBQUNmO0FBQzFELCtCQUErQiwrREFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNFQUFXO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQiwwRkFBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEVBQXFCO0FBQzVDLDZCQUE2Qix1RUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwRkFBa0M7QUFDbEU7QUFDQSxZQUFZLCtEQUFRO0FBQ3BCLHlCQUF5QiwwRkFBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnl0ZWRhbmNlL1B5Y2hhcm1Qcm9qZWN0cy9teV9iZXN0L2xhbmdncmFwaF90ZWFjaC9hZ2VudF9jaGF0X3VpL25vZGVfbW9kdWxlcy8ucG5wbS9AbGFuZ2NoYWluK2xhbmdncmFwaEAwLjIuNzJfQGxhbmdjaGFpbitjb3JlQDAuMy41Nl9vcGVuYWlANC4xMDAuMF93c0A4LjE4LjJfem9kQDMuMjQuNF9fX3JlYWNfN2pncW10N3l3eHozZ2x5M3Fma3N1bXI1Z2Uvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoL2Rpc3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVyZ2VDb25maWdzLCBwYXRjaENvbmZpZywgUnVubmFibGUsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3NpbmdsZXRvbnNcIjtcbmltcG9ydCB7IGVuc3VyZUxhbmdHcmFwaENvbmZpZyB9IGZyb20gXCIuL3ByZWdlbC91dGlscy9jb25maWcuanNcIjtcbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUNhbGxhYmxlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdncmFwaFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjdXJzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWUgPz8gZmllbGRzLmZ1bmMubmFtZTtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZmllbGRzLnRhZ3MgPyB7IHRhZ3M6IGZpZWxkcy50YWdzIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudHJhY2UgPSBmaWVsZHMudHJhY2UgPz8gdGhpcy50cmFjZTtcbiAgICAgICAgdGhpcy5yZWN1cnNlID0gZmllbGRzLnJlY3Vyc2UgPz8gdGhpcy5yZWN1cnNlO1xuICAgIH1cbiAgICBhc3luYyBfdHJhY2VkSW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2b2lkIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZnVuYyhpbnB1dCwgY2hpbGRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlucHV0LCBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVMYW5nR3JhcGhDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1lcmdlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXQgdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5fdHJhY2VkSW52b2tlLCBpbnB1dCwgbWVyZ2VkQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKG1lcmdlZENvbmZpZywgYXN5bmMgKCkgPT4gdGhpcy5mdW5jKGlucHV0LCBtZXJnZWRDb25maWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUnVubmFibGUuaXNSdW5uYWJsZShyZXR1cm5WYWx1ZSkgJiYgdGhpcy5yZWN1cnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKG1lcmdlZENvbmZpZywgYXN5bmMgKCkgPT4gcmV0dXJuVmFsdWUuaW52b2tlKGlucHV0LCBtZXJnZWRDb25maWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uKiBwcmVmaXhHZW5lcmF0b3IoZ2VuZXJhdG9yLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWllbGQqIGdlbmVyYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB5aWVsZCBbcHJlZml4LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1mcm9tLWFzeW5jXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2F0aGVySXRlcmF0b3IoaSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBhd2FpdCBpKSB7XG4gICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdhdGhlckl0ZXJhdG9yU3luYyhpKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGkpIHtcbiAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25maWd1cmFibGUoY29uZmlnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5wYXRjaCkge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHBhdGNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICghKFwiY29uZmlndXJhYmxlXCIgaW4gY29uZmlnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBwYXRjaCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHtcbiAgICAgICAgICAgICAgICAuLi5jb25maWcuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgIC4uLnBhdGNoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvckZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKiAoKSB7IH0pLmNvbnN0cnVjdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKiAoKSB7IH0pLmNvbnN0cnVjdG9yKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/web.js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/web.js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),\n/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.AsyncBatchedStore),\n/* harmony export */   BaseChannel: () => (/* reexport safe */ _channels_index_js__WEBPACK_IMPORTED_MODULE_2__.BaseChannel),\n/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.BaseCheckpointSaver),\n/* harmony export */   BaseLangGraphError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.BaseLangGraphError),\n/* harmony export */   BaseStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.BaseStore),\n/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _channels_index_js__WEBPACK_IMPORTED_MODULE_2__.BinaryOperatorAggregate),\n/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ChannelKeyPlaceholder),\n/* harmony export */   Command: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.Command),\n/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.CompiledStateGraph),\n/* harmony export */   END: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.END),\n/* harmony export */   EmptyChannelError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyChannelError),\n/* harmony export */   EmptyInputError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.EmptyInputError),\n/* harmony export */   Graph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.Graph),\n/* harmony export */   GraphBubbleUp: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphBubbleUp),\n/* harmony export */   GraphInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphInterrupt),\n/* harmony export */   GraphRecursionError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphRecursionError),\n/* harmony export */   GraphValueError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.GraphValueError),\n/* harmony export */   InMemoryStore: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.InMemoryStore),\n/* harmony export */   InvalidUpdateError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUpdateError),\n/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.IsLastStepManager),\n/* harmony export */   ManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ManagedValue),\n/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.ManagedValueMapping),\n/* harmony export */   MemorySaver: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.MemorySaver),\n/* harmony export */   MessageGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.MessageGraph),\n/* harmony export */   MessagesAnnotation: () => (/* reexport safe */ _graph_messages_annotation_js__WEBPACK_IMPORTED_MODULE_7__.MessagesAnnotation),\n/* harmony export */   MultipleSubgraphsError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.MultipleSubgraphsError),\n/* harmony export */   NodeInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.NodeInterrupt),\n/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.NoopManagedValue),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.ParentCommand),\n/* harmony export */   RemoteException: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.RemoteException),\n/* harmony export */   START: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.START),\n/* harmony export */   Send: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.Send),\n/* harmony export */   SharedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.SharedValue),\n/* harmony export */   StateGraph: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.StateGraph),\n/* harmony export */   UnreachableNodeError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.UnreachableNodeError),\n/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.WritableManagedValue),\n/* harmony export */   addMessages: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),\n/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.copyCheckpoint),\n/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__.emptyCheckpoint),\n/* harmony export */   entrypoint: () => (/* reexport safe */ _func_index_js__WEBPACK_IMPORTED_MODULE_6__.entrypoint),\n/* harmony export */   getSubgraphsSeenSet: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.getSubgraphsSeenSet),\n/* harmony export */   isCommand: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_3__.isCommand),\n/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.isConfiguredManagedValue),\n/* harmony export */   isGraphBubbleUp: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphBubbleUp),\n/* harmony export */   isGraphInterrupt: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isGraphInterrupt),\n/* harmony export */   isManagedValue: () => (/* reexport safe */ _managed_index_js__WEBPACK_IMPORTED_MODULE_5__.isManagedValue),\n/* harmony export */   isParentCommand: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.isParentCommand),\n/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _graph_index_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),\n/* harmony export */   task: () => (/* reexport safe */ _func_index_js__WEBPACK_IMPORTED_MODULE_6__.task)\n/* harmony export */ });\n/* harmony import */ var _graph_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/errors.js\");\n/* harmony import */ var _channels_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channels/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/channels/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/constants.js\");\n/* harmony import */ var _langchain_langgraph_checkpoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @langchain/langgraph-checkpoint */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph-checkpoint@0.0.17_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4__/node_modules/@langchain/langgraph-checkpoint/index.js\");\n/* harmony import */ var _managed_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./managed/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/managed/index.js\");\n/* harmony import */ var _func_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./func/index.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/func/index.js\");\n/* harmony import */ var _graph_messages_annotation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graph/messages_annotation.js */ \"(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/graph/messages_annotation.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxhbmdjaGFpbitsYW5nZ3JhcGhAMC4yLjcyX0BsYW5nY2hhaW4rY29yZUAwLjMuNTZfb3BlbmFpQDQuMTAwLjBfd3NAOC4xOC4yX3pvZEAzLjI0LjRfX19yZWFjXzdqZ3FtdDd5d3h6M2dseTNxZmtzdW1yNWdlL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC9kaXN0L3dlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStKO0FBQ25JO0FBQ2dEO0FBQ0w7QUFDMkY7QUFDL0g7QUFDaUI7QUFDZ0I7QUFDcEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvUHljaGFybVByb2plY3RzL215X2Jlc3QvbGFuZ2dyYXBoX3RlYWNoL2FnZW50X2NoYXRfdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0BsYW5nY2hhaW4rbGFuZ2dyYXBoQDAuMi43Ml9AbGFuZ2NoYWluK2NvcmVAMC4zLjU2X29wZW5haUA0LjEwMC4wX3dzQDguMTguMl96b2RAMy4yNC40X19fcmVhY183amdxbXQ3eXd4ejNnbHkzcWZrc3VtcjVnZS9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgvZGlzdC93ZWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgR3JhcGgsIFN0YXRlR3JhcGgsIENvbXBpbGVkU3RhdGVHcmFwaCwgTWVzc2FnZUdyYXBoLCBtZXNzYWdlc1N0YXRlUmVkdWNlciwgbWVzc2FnZXNTdGF0ZVJlZHVjZXIgYXMgYWRkTWVzc2FnZXMsIEFubm90YXRpb24sIH0gZnJvbSBcIi4vZ3JhcGgvaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgQmFzZUNoYW5uZWwsIEJpbmFyeU9wZXJhdG9yQWdncmVnYXRlLCB9IGZyb20gXCIuL2NoYW5uZWxzL2luZGV4LmpzXCI7XG5leHBvcnQgeyBTZW5kLCBDb21tYW5kLCBpc0NvbW1hbmQsIFNUQVJULCBFTkQsIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5leHBvcnQgeyBNZW1vcnlTYXZlciwgY29weUNoZWNrcG9pbnQsIGVtcHR5Q2hlY2twb2ludCwgQmFzZUNoZWNrcG9pbnRTYXZlciwgQmFzZVN0b3JlLCBBc3luY0JhdGNoZWRTdG9yZSwgSW5NZW1vcnlTdG9yZSwgfSBmcm9tIFwiQGxhbmdjaGFpbi9sYW5nZ3JhcGgtY2hlY2twb2ludFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWFuYWdlZC9pbmRleC5qc1wiO1xuZXhwb3J0IHsgZW50cnlwb2ludCwgdGFzaywgfSBmcm9tIFwiLi9mdW5jL2luZGV4LmpzXCI7XG5leHBvcnQgeyBNZXNzYWdlc0Fubm90YXRpb24gfSBmcm9tIFwiLi9ncmFwaC9tZXNzYWdlc19hbm5vdGF0aW9uLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/web.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/web.js":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/web.js ***!
  \**********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Annotation: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.Annotation),
/* harmony export */   AsyncBatchedStore: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.AsyncBatchedStore),
/* harmony export */   BaseChannel: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.BaseChannel),
/* harmony export */   BaseCheckpointSaver: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.BaseCheckpointSaver),
/* harmony export */   BaseLangGraphError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.BaseLangGraphError),
/* harmony export */   BaseStore: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.BaseStore),
/* harmony export */   BinaryOperatorAggregate: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.BinaryOperatorAggregate),
/* harmony export */   ChannelKeyPlaceholder: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.ChannelKeyPlaceholder),
/* harmony export */   Command: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.Command),
/* harmony export */   CompiledStateGraph: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.CompiledStateGraph),
/* harmony export */   END: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.END),
/* harmony export */   EmptyChannelError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.EmptyChannelError),
/* harmony export */   EmptyInputError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.EmptyInputError),
/* harmony export */   Graph: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.Graph),
/* harmony export */   GraphBubbleUp: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.GraphBubbleUp),
/* harmony export */   GraphInterrupt: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.GraphInterrupt),
/* harmony export */   GraphRecursionError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.GraphRecursionError),
/* harmony export */   GraphValueError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.GraphValueError),
/* harmony export */   InMemoryStore: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.InMemoryStore),
/* harmony export */   InvalidUpdateError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUpdateError),
/* harmony export */   IsLastStepManager: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.IsLastStepManager),
/* harmony export */   ManagedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValue),
/* harmony export */   ManagedValueMapping: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.ManagedValueMapping),
/* harmony export */   MemorySaver: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.MemorySaver),
/* harmony export */   MessageGraph: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.MessageGraph),
/* harmony export */   MessagesAnnotation: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.MessagesAnnotation),
/* harmony export */   MultipleSubgraphsError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.MultipleSubgraphsError),
/* harmony export */   NodeInterrupt: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.NodeInterrupt),
/* harmony export */   NoopManagedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.NoopManagedValue),
/* harmony export */   ParentCommand: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.ParentCommand),
/* harmony export */   RemoteException: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.RemoteException),
/* harmony export */   START: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.START),
/* harmony export */   Send: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.Send),
/* harmony export */   SharedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.SharedValue),
/* harmony export */   StateGraph: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.StateGraph),
/* harmony export */   UnreachableNodeError: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.UnreachableNodeError),
/* harmony export */   WritableManagedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.WritableManagedValue),
/* harmony export */   addMessages: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.addMessages),
/* harmony export */   copyCheckpoint: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.copyCheckpoint),
/* harmony export */   emptyCheckpoint: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.emptyCheckpoint),
/* harmony export */   entrypoint: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.entrypoint),
/* harmony export */   getSubgraphsSeenSet: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.getSubgraphsSeenSet),
/* harmony export */   isCommand: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isCommand),
/* harmony export */   isConfiguredManagedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isConfiguredManagedValue),
/* harmony export */   isGraphBubbleUp: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isGraphBubbleUp),
/* harmony export */   isGraphInterrupt: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isGraphInterrupt),
/* harmony export */   isManagedValue: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isManagedValue),
/* harmony export */   isParentCommand: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.isParentCommand),
/* harmony export */   messagesStateReducer: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.messagesStateReducer),
/* harmony export */   task: () => (/* reexport safe */ _dist_web_js__WEBPACK_IMPORTED_MODULE_0__.task)
/* harmony export */ });
/* harmony import */ var _dist_web_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/web.js */ "(ssr)/./node_modules/.pnpm/@langchain+langgraph@0.2.72_@langchain+core@0.3.56_openai@4.100.0_ws@8.18.2_zod@3.24.4___reac_7jgqmt7ywxz3gly3qfksumr5ge/node_modules/@langchain/langgraph/dist/web.js");


/***/ })

};
;