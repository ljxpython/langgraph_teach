# 中断处理问题解答

## 问题描述

在使用 LangGraph API 运行带有 `interrupt_on` 配置的 agent 时：

1. 界面显示工具调用信息（如 write_file）
2. 用户输入 "approve" 后
3. 显示错误：`Tool call write_file with id call_00_xxx was cancelled - another message came in before it could be completed.`

## 问题根源

**你不应该输入 "approve" 作为消息！**

当你在界面输入 "approve" 时，系统会将其当作一条新的用户消息发送给 agent，这会：
1. 启动一个新的 agent 运行
2. 取消之前等待批准的工具调用
3. 导致中断失败

## 正确的做法

### 核心概念

LangGraph 的 Human-in-the-Loop 中断机制需要使用 **Command 结构** 而不是普通消息来恢复执行。

### 数据结构

```python
# 中断发生时的数据结构
interrupt = {
    "id": "interrupt_id_xxx",  # 中断的唯一标识
    "value": {
        "action_requests": [
            {
                "name": "write_file",
                "args": {"file_path": "/test.txt", "content": "Hello"},
                "description": "写入文件"
            }
        ]
    }
}

# 恢复执行时需要的数据结构
resume_payload = {
    "interrupt_id_xxx": {  # 使用中断的 ID
        "decisions": [
            {"type": "approve"}  # 批准
            # 或 {"type": "reject", "message": "拒绝原因"}  # 拒绝
            # 或 {"type": "edit", "args": {...}}  # 编辑参数
        ]
    }
}
```

### 在 Web 界面中实现

如果你使用的是 LangGraph Studio 或自定义 Web 界面，需要：

#### 1. 监听中断事件

```javascript
// 使用 stream 模式监听
const stream = client.runs.stream(threadId, assistantId, {
    input: userInput,
    streamMode: ["messages", "updates"]  // 必须包含 updates
});

for await (const chunk of stream) {
    // 检查 updates 流中的中断
    if (chunk.event === "updates" && chunk.data.__interrupt__) {
        const interrupts = chunk.data.__interrupt__;
        
        // 保存中断信息
        for (const interrupt of interrupts) {
            saveInterrupt(interrupt.id, interrupt.value);
            
            // 显示批准/拒绝按钮
            showApprovalButtons(interrupt);
        }
    }
}
```

#### 2. 创建批准/拒绝按钮

```javascript
function showApprovalButtons(interrupt) {
    const actionRequests = interrupt.value.action_requests;
    
    for (const action of actionRequests) {
        // 显示工具信息
        displayToolInfo(action.name, action.args, action.description);
        
        // 创建按钮
        createButton("Approve", () => handleDecision(interrupt.id, "approve"));
        createButton("Reject", () => handleDecision(interrupt.id, "reject"));
        createButton("Edit", () => handleDecision(interrupt.id, "edit", editedArgs));
    }
}
```

#### 3. 处理用户决策

```javascript
async function handleDecision(interruptId, decisionType, editedArgs = null) {
    let decision;
    
    if (decisionType === "approve") {
        decision = { type: "approve" };
    } else if (decisionType === "reject") {
        decision = { type: "reject", message: "User rejected" };
    } else if (decisionType === "edit") {
        decision = { type: "edit", args: editedArgs };
    }
    
    // 构建 resume payload
    const resumePayload = {
        [interruptId]: {
            decisions: [decision]
        }
    };
    
    // 使用 Command 恢复（注意：不是发送消息！）
    const stream = client.runs.stream(threadId, assistantId, {
        command: { resume: resumePayload },  // 使用 command，不是 input
        streamMode: ["messages", "updates"]
    });
    
    // 继续处理流
    for await (const chunk of stream) {
        // 处理后续消息
    }
}
```

### 在 Python 中实现

```python
from langgraph.types import Command

# 1. 触发中断
pending_interrupts = {}

async for chunk in agent.astream(
    {"messages": [{"role": "user", "content": "写入文件"}]},
    config=config,
    stream_mode=["messages", "updates"]
):
    if isinstance(chunk, tuple):
        namespace, stream_mode, data = chunk
        
        if stream_mode == "updates" and "__interrupt__" in data:
            for interrupt in data["__interrupt__"]:
                pending_interrupts[interrupt.id] = interrupt.value

# 2. 构建决策
hitl_response = {}
for interrupt_id, interrupt_value in pending_interrupts.items():
    decisions = []
    for action_req in interrupt_value["action_requests"]:
        # 批准
        decisions.append({"type": "approve"})
    
    hitl_response[interrupt_id] = {"decisions": decisions}

# 3. 使用 Command 恢复
async for chunk in agent.astream(
    Command(resume=hitl_response),  # 使用 Command，不是普通消息
    config=config,
    stream_mode=["messages", "updates"]
):
    # 处理后续流
    pass
```

## 关键要点

1. ❌ **不要**：在聊天框输入 "approve"、"reject" 等文本
2. ✅ **要**：使用 `Command(resume=...)` 结构
3. ✅ **要**：监听 `stream_mode=["updates"]` 获取中断信息
4. ✅ **要**：保存 `interrupt.id` 用于恢复
5. ✅ **要**：构建正确的 `decisions` 数组

## 三种决策类型

### 1. Approve (批准)
```python
{"type": "approve"}
```
执行原始的工具调用，不做任何修改。

### 2. Reject (拒绝)
```python
{"type": "reject", "message": "拒绝原因"}
```
取消工具调用，agent 会收到拒绝消息并重新规划。

### 3. Edit (编辑)
```python
{"type": "edit", "args": {"file_path": "/new_path.txt", "content": "Modified"}}
```
使用修改后的参数执行工具调用。

## 测试示例

参考文件：
- `deepagents_agent/interrupt_test_example.py` - 完整的测试示例
- `deepagents-docs/LangGraph-API中断处理分析.md` - 详细分析文档

## 参考实现

DeepAgents CLI 的完整实现：
- `deepagents_v2/deepagents-cli/deepagents_cli/execution.py`
- 第 246-573 行：完整的中断处理流程

